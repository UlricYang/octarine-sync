# LeetCode 450 - åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

## 1. é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªå€¼ `key`ï¼Œåˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­å€¼ç­‰äº `key` çš„èŠ‚ç‚¹ã€‚è¿”å›äºŒå‰æœç´¢æ ‘ï¼ˆæœ‰å¯èƒ½è¢«æ›´æ–°ï¼‰çš„æ ¹èŠ‚ç‚¹çš„å¼•ç”¨

ä¸€èˆ¬æ¥è¯´ï¼Œåˆ é™¤èŠ‚ç‚¹å¯åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š

1. é¦–å…ˆæ‰¾åˆ°éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼›
1. å¦‚æœæ‰¾åˆ°äº†ï¼Œåˆ é™¤å®ƒ

### ç¤ºä¾‹ 1:

è¾“å…¥: `root = [5,3,6,2,4,null,7]`, `key = 3`
è¾“å‡º: `[5,4,6,2,null,null,7]`

> è§£é‡Šï¼šç»™å®šéœ€è¦åˆ é™¤çš„èŠ‚ç‚¹å€¼æ˜¯ 3ï¼Œæ‰€ä»¥æˆ‘ä»¬é¦–å…ˆæ‰¾åˆ° 3 è¿™ä¸ªèŠ‚ç‚¹ï¼Œç„¶ååˆ é™¤å®ƒã€‚ä¸€ä¸ªæ­£ç¡®çš„ç­”æ¡ˆæ˜¯ `[5,4,6,2,null,null,7]`ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚å¦ä¸€ä¸ªæ­£ç¡®ç­”æ¡ˆæ˜¯ `[5,2,6,null,4,null,7]`

### ç¤ºä¾‹ 2:

è¾“å…¥: `root = [5,3,6,2,4,null,7]`, `key = 0`
è¾“å‡º: `[5,3,6,2,4,null,7]`

> è§£é‡Šï¼šäºŒå‰æ ‘ä¸åŒ…å«å€¼ä¸º 0 çš„èŠ‚ç‚¹

### ç¤ºä¾‹ 3:

è¾“å…¥: `root = []`, `key = 0`
è¾“å‡º: `[]`

### æç¤º:

- èŠ‚ç‚¹æ•°çš„èŒƒå›´ `[0, 10^4]`.
- `-10^5 <= Node.val <= 10^5`
- èŠ‚ç‚¹å€¼å”¯ä¸€
- `root` æ˜¯åˆæ³•çš„äºŒå‰æœç´¢æ ‘
- `-10^5 <= key <= 10^5`

## 2. è§£æ³•æ ¸å¿ƒç»“è®º

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯ä½¿ç”¨é€’å½’éå†ç»“åˆ BST ç‰¹æ€§çš„æŸ¥æ‰¾å’Œåˆ é™¤ç­–ç•¥ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºç»“æ„æ¸…æ™°ã€é€»è¾‘ç»Ÿä¸€ä¸”æ˜“äºå®ç°

#### æ”¯æ’‘è®ºç‚¹ A â€”â€” ç†è®ºåˆ†æ

BST ç»“æ„å¤©ç„¶æ”¯æŒæœ‰åºè®¿é—®ï¼Œåœ¨åˆ é™¤æ“ä½œä¸­ï¼Œå¯ä»¥é€šè¿‡é€’å½’æˆ–è¿­ä»£çš„æ–¹å¼å®šä½ç›®æ ‡èŠ‚ç‚¹ï¼Œå¹¶æ ¹æ®è¯¥èŠ‚ç‚¹çš„ä¸åŒå­æ ‘æƒ…å†µè¿›è¡Œåˆ é™¤ï¼Œä»è€Œä¿æŒ BST æ€§è´¨ä¸å˜

#### æ”¯æ’‘è®ºç‚¹ B â€”â€” å¯¹æ¯”å…¶ä»–æ–¹æ³•

æš´åŠ›æ–¹æ³•ä¼šé€€åŒ–ä¸ºçº¿æ€§æ‰«æï¼Œæ•ˆç‡ä½ä¸‹ï¼›è€Œè¿­ä»£æ–¹å¼è™½ç„¶èŠ‚çœæ ˆç©ºé—´ï¼Œä½†ä»£ç ç¹çéš¾æ‡‚ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œé€’å½’æ–¹æ³•åˆ©ç”¨äº† BST è‡ªç„¶çš„ç»“æ„ç‰¹æ€§ï¼Œå…·å¤‡æ›´å¼ºçš„å¯è¯»æ€§å’Œé²æ£’æ€§

#### æ”¯æ’‘è®ºç‚¹ C â€”â€” è¾¹ç•Œé€‚ç”¨æ¡ä»¶

æœ¬æ–¹æ³•é€‚ç”¨äºä»¥ä¸‹æƒ…å†µï¼š

- è¾“å…¥ä¸ºæœ‰æ•ˆçš„ BSTï¼›
- æ‰€æœ‰èŠ‚ç‚¹å€¼å”¯ä¸€ï¼›
- èŠ‚ç‚¹æ€»æ•°ä¸è¶…è¿‡ $10^4$

#### æ”¯æ’‘è®ºç‚¹ D â€”â€” å·¥ç¨‹å®è·µè€ƒé‡

é€’å½’æ–¹æ³•èƒ½å¤Ÿè‡ªç„¶åœ°å¤„ç†ä¸‰ç§å…¸å‹çš„åˆ é™¤æƒ…å½¢ï¼š

1. å¾…åˆ èŠ‚ç‚¹æ— å·¦å³å­©å­ â†’ ç›´æ¥åˆ é™¤ï¼›
1. å¾…åˆ èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­ â†’ æ›¿æ¢ä¸ºå…¶å­©å­ï¼›
1. å¾…åˆ èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­©å­ â†’ å°†å…¶æ›¿æ¢ä¸ºå…¶å³å­æ ‘ä¸­æœ€å·¦èŠ‚ç‚¹ï¼ˆå³åç»§èŠ‚ç‚¹ï¼‰

### æ€»ç»“

å› æ­¤ï¼Œé€’å½’éå†+BSTç‰¹æ€§çš„åˆ é™¤ç­–ç•¥æ˜¯åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ—¶é—´æ•ˆç‡å’Œå·¥ç¨‹å®ç°å¤æ‚åº¦ä¹‹é—´çš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°å¯¹æ¯”

### æ ¸å¿ƒç»“è®º

é€šè¿‡å¯¹æ¯”å››ç§ä¸»æµè¯­è¨€çš„å®ç°ï¼Œå¯ä»¥éªŒè¯è¯¥ç®—æ³•çš„é€šç”¨æ€§ï¼Œå¹¶æ´å¯Ÿä¸åŒè¯­è¨€åœ¨æ€§èƒ½ã€å†…å­˜ç®¡ç†å’Œå¹¶å‘æ¨¡å‹ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°ä¸æ€§èƒ½å‰–æ

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// deleteNode åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil { // è‹¥å½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™è¯´æ˜æœªæ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›nil
        return nil
    }

    if key < root.Val { // å¦‚æœkeyå°äºå½“å‰èŠ‚ç‚¹å€¼ï¼Œåˆ™å»å·¦å­æ ‘æŸ¥æ‰¾å¹¶åˆ é™¤
        root.Left = deleteNode(root.Left, key)
    } else if key > root.Val { // å¦‚æœkeyå¤§äºå½“å‰èŠ‚ç‚¹å€¼ï¼Œåˆ™å»å³å­æ ‘æŸ¥æ‰¾å¹¶åˆ é™¤
        root.Right = deleteNode(root.Right, key)
    } else { // å½“å‰èŠ‚ç‚¹å°±æ˜¯å¾…åˆ é™¤èŠ‚ç‚¹
        if root.Left == nil && root.Right == nil { // æƒ…å†µä¸€ï¼šå¶å­èŠ‚ç‚¹
            return nil
        }
        if root.Left == nil { // æƒ…å†µäºŒï¼šåªæœ‰å³å­æ ‘
            return root.Right
        }
        if root.Right == nil { // æƒ…å†µä¸‰ï¼šåªæœ‰å·¦å­æ ‘
            return root.Left
        }
        // æƒ…å†µå››ï¼šå·¦å³å­æ ‘éƒ½æœ‰ -> å¯»æ‰¾å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹æ›¿ä»£å½“å‰èŠ‚ç‚¹
        minRight := findMin(root.Right)
        root.Val = minRight.Val           // ç”¨åç»§èŠ‚ç‚¹å€¼æ›¿æ¢å½“å‰èŠ‚ç‚¹å€¼
        root.Right = deleteNode(root.Right, minRight.Val) // å†é€’å½’åˆ é™¤è¿™ä¸ªåç»§èŠ‚ç‚¹
    }

    return root // è¿”å›ä¿®æ”¹åçš„æ ¹èŠ‚ç‚¹
}

// findMin æŸ¥æ‰¾æŸä¸ªå­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼ˆæœ€å·¦ä¾§èŠ‚ç‚¹ï¼‰
func findMin(node *TreeNode) *TreeNode {
    for node.Left != nil {
        node = node.Left
    }
    return node
}
```

#### ç®—æ³•æ·±å…¥è§£æ

è¿™æ®µ Go å®ç°é‡‡ç”¨äº†ç»å…¸çš„é€’å½’ç­–ç•¥æ¥åˆ é™¤ BST ä¸­æŒ‡å®šå€¼çš„èŠ‚ç‚¹ï¼Œä½“ç°äº†è‰¯å¥½çš„å·¥ç¨‹å®è·µï¼š

- é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šå¦‚æœå½“å‰èŠ‚ç‚¹ä¸º `nil`ï¼Œè¡¨ç¤ºæ²¡æœ‰æ‰¾åˆ°è¦åˆ é™¤çš„ç›®æ ‡èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›ï¼›
- BST æŸ¥æ‰¾è·¯å¾„ï¼šé€šè¿‡æ¯”è¾ƒ `key` å’Œå½“å‰èŠ‚ç‚¹å€¼å¤§å°å†³å®šå¾€å“ªä¸€è¾¹ç»§ç»­é€’å½’ï¼›
- èŠ‚ç‚¹åˆ é™¤é€»è¾‘ï¼šåˆ†ä¸ºå››ä¸ªåŸºæœ¬æƒ…å½¢ï¼š
  - å¶èŠ‚ç‚¹åˆ é™¤ï¼šç›´æ¥è¿”å› `nil` å³å¯å®Œæˆåˆ é™¤ï¼›
  - ä»…æœ‰ä¸€ä¸ªå­©å­çš„èŠ‚ç‚¹ï¼šç›´æ¥å°†å…¶å­©å­ä½œä¸ºæ–°æ ¹èŠ‚ç‚¹è¿”å›ï¼›
  - æ‹¥æœ‰ä¸¤ä¸ªå­©å­çš„èŠ‚ç‚¹ï¼šæ‰¾åˆ°å³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼ˆä¸­åºåç»§ï¼‰è¿›è¡Œå€¼äº¤æ¢ï¼Œç„¶åé€’å½’åˆ é™¤é‚£ä¸ªåç»§èŠ‚ç‚¹

è¿™ç§æ–¹å¼å……åˆ†å°Šé‡äº† BST çš„ç»“æ„æ€§è´¨ï¼Œä½¿æ¯ä¸€æ¬¡æ“ä½œéƒ½èƒ½ç»´æŒåŸæœ‰æ€§è´¨ï¼Œé¿å…ç ´åæ•´ä½“ç»“æ„

### B. Python ğŸ å®ç°ä¸æ€§èƒ½å‰–æ

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def deleteNode(root: TreeNode, key: int) -> TreeNode:
    if not root:  # åŸºæœ¬ç»ˆæ­¢æ¡ä»¶ï¼šèŠ‚ç‚¹ä¸ºç©º
        return None

    if key < root.val:  # å‘å·¦é€’å½’å¯»æ‰¾è¦åˆ é™¤çš„èŠ‚ç‚¹
        root.left = deleteNode(root.left, key)
    elif key > root.val:  # å‘å³é€’å½’å¯»æ‰¾è¦åˆ é™¤çš„èŠ‚ç‚¹
        root.right = deleteNode(root.right, key)
    else:  # æ‰¾åˆ°äº†å¾…åˆ é™¤çš„èŠ‚ç‚¹
        if not root.left and not root.right:  # å¶å­èŠ‚ç‚¹ï¼Œç›´æ¥åˆ é™¤
            return None
        elif not root.left:  # ä»…æœ‰å³å­æ ‘
            return root.right
        elif not root.right:  # ä»…æœ‰å·¦å­æ ‘
            return root.left
        else:  # å·¦å³å­æ ‘å‡å­˜åœ¨ -> ä½¿ç”¨å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹æ›¿æ¢å½“å‰èŠ‚ç‚¹
            successor = find_min(root.right)
            root.val = successor.val  # æ›¿æ¢å½“å‰èŠ‚ç‚¹å€¼
            root.right = deleteNode(root.right, successor.val)  # ç»§ç»­é€’å½’åˆ é™¤è¿™ä¸ªåç»§èŠ‚ç‚¹

    return root  # è¿”å›æ›´æ–°åçš„æ ¹èŠ‚ç‚¹


def find_min(node):  # å¯»æ‰¾æŸæ£µå­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼ˆæœ€å·¦èŠ‚ç‚¹ï¼‰
    while node.left:
        node = node.left
    return node
```

#### ç®—æ³•æ·±å…¥è§£æ

Python çš„å®ç°å»¶ç»­äº† Go ç‰ˆæœ¬çš„åŸºæœ¬æ€è·¯ï¼Œä½†å€ŸåŠ©åŠ¨æ€ç±»å‹ç‰¹æ€§å‡å°‘äº†ç»“æ„å£°æ˜è´Ÿæ‹…ï¼Œä½¿ä»£ç æ›´ä¸ºç´§å‡‘ï¼š

- åˆ©ç”¨äº† Python çš„é»˜è®¤å‚æ•°ä¼ é€’æœºåˆ¶ï¼Œç®€åŒ–äº†èŠ‚ç‚¹åˆå§‹åŒ–è¿‡ç¨‹ï¼›
- `find_min()` å‡½æ•°è´Ÿè´£è·å–æŸä¸€å­æ ‘ä¸­æœ€å·¦è¾¹çš„èŠ‚ç‚¹ï¼›
- ä¸»å‡½æ•°ä¸­é€’å½’å¤„ç†æ‰€æœ‰æƒ…å†µï¼Œç‰¹åˆ«æ³¨æ„åœ¨åˆ é™¤æœ‰ä¸¤å­©å­çš„èŠ‚ç‚¹æ—¶ï¼Œä½¿ç”¨äº†"ä¸­åºåç»§"ä»£æ›¿åŸèŠ‚ç‚¹çš„åšæ³•ï¼Œè¿™åœ¨é€»è¾‘ä¸Šéå¸¸ä¼˜é›…ä¸”å®ç”¨ï¼›
- æœ€ç»ˆè¿”å›çš„æ˜¯æ•´ä¸ªå­æ ‘çš„æ–°æ ¹èŠ‚ç‚¹ï¼Œç”±çˆ¶èŠ‚ç‚¹æ‰¿æ¥æ›´æ–°ç»“æœ

è¿™ç§åšæ³•å±•ç°äº† Python å¼ºå¤§çš„çµæ´»æ€§å’Œç®€æ´æ€§ï¼Œä½¿å¾—å¼€å‘è€…æ›´å®¹æ˜“ä¸“æ³¨äºç®—æ³•æœ¬èº«è€Œéåº•å±‚å®ç°ç»†èŠ‚

### C. TypeScript ğŸŸ¦ å®ç°ä¸æ€§èƒ½å‰–æ

```typescript
class TreeNode {
  val: number;
  left: TreeNode | null;
  right: TreeNode | null;

  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
  }
}

function deleteNode(root: TreeNode | null, key: number): TreeNode | null {
  if (!root) return null; // èŠ‚ç‚¹ä¸å­˜åœ¨æ—¶ç›´æ¥è¿”å›null

  if (key < root.val) {
    // å‘å·¦å­æ ‘æŸ¥æ‰¾å¹¶åˆ é™¤
    root.left = deleteNode(root.left, key);
  } else if (key > root.val) {
    // å‘å³å­æ ‘æŸ¥æ‰¾å¹¶åˆ é™¤
    root.right = deleteNode(root.right, key);
  } else {
    // å½“å‰èŠ‚ç‚¹æ˜¯è¦åˆ é™¤çš„èŠ‚ç‚¹
    if (!root.left && !root.right) {
      // å¶å­èŠ‚ç‚¹
      return null;
    }
    if (!root.left) {
      // ä»…å³å­æ ‘
      return root.right;
    }
    if (!root.right) {
      // ä»…å·¦å­æ ‘
      return root.left;
    }

    const successor = findMin(root.right); // è·å–å³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹
    root.val = successor.val; // ç”¨åç»§èŠ‚ç‚¹æ›¿æ¢å½“å‰èŠ‚ç‚¹
    root.right = deleteNode(root.right, successor.val); // ç»§ç»­åˆ é™¤åç»§èŠ‚ç‚¹
  }

  return root; // è¿”å›æ›´æ–°åçš„æ ¹èŠ‚ç‚¹
}

function findMin(node: TreeNode): TreeNode {
  while (node.left !== null) {
    node = node.left;
  }
  return node;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

TypeScript çš„å®ç°å±•ç¤ºäº†é™æ€ç±»å‹çš„ä¼˜ç‚¹ï¼š

- ç±»å‹æ³¨è§£å¸®åŠ©ç¼–è¯‘å™¨åœ¨æ—©æœŸå‘ç°é—®é¢˜ï¼›
- æ˜ç¡®çš„ `null` æ£€æŸ¥æå‡äº†å¥å£®æ€§ï¼›
- ç»“æ„æ¸…æ™°ï¼Œé€»è¾‘ä¸¥è°¨ï¼Œç‰¹åˆ«é€‚åˆå¤§å‹é¡¹ç›®åä½œåœºæ™¯

`deleteNode()` å‡½æ•°å®ç°äº†æ ‡å‡†çš„ BST åˆ é™¤ç®—æ³•ï¼Œæ¯ä¸€æ­¥æ“ä½œéƒ½ç»è¿‡ä¸¥æ ¼ç±»å‹éªŒè¯ï¼Œå¢å¼ºäº†ä»£ç çš„å®‰å…¨æ€§å’Œç¨³å®šæ€§ã€‚åŒæ—¶ä¿ç•™äº†åŸæœ‰çš„é€’å½’ç»“æ„ï¼Œä¾¿äºè°ƒè¯•ä¸ä¼˜åŒ–

### D. Rust ğŸ¦€ å®ç°ä¸æ€§èƒ½å‰–æ

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug, PartialEq, Eq)]
pub struct TreeNode {
    pub val: i32,
    pub left: Option<Rc<RefCell<TreeNode>>>,
    pub right: Option<Rc<RefCell<TreeNode>>>,
}

impl TreeNode {
    #[inline]
    pub fn new(val: i32) -> Self {
        TreeNode {
            val,
            left: None,
            right: None,
        }
    }
}

pub fn delete_node(
    root: Option<Rc<RefCell<TreeNode>>>,
    key: i32,
) -> Option<Rc<RefCell<TreeNode>>> {
    match root {
        Some(node_rc) => {
            let mut node_ref = node_rc.borrow_mut();
            if key < node_ref.val {
                drop(node_ref); // é‡Šæ”¾å€Ÿç”¨ä»¥ä¾¿é€’å½’è°ƒç”¨
                let updated_left = delete_node(node_rc.borrow().left.clone(), key);
                node_rc.borrow_mut().left = updated_left;
            } else if key > node_ref.val {
                drop(node_ref);
                let updated_right = delete_node(node_rc.borrow().right.clone(), key);
                node_rc.borrow_mut().right = updated_right;
            } else {
                drop(node_ref);

                // åˆ†ä¸‰ç§æƒ…å†µ
                let left = &mut node_rc.borrow_mut().left.take();
                let right = &mut node_rc.borrow_mut().right.take();

                if left.is_none() && right.is_none() {
                    return None;
                } else if left.is_none() {
                    return right.clone();
                } else if right.is_none() {
                    return left.clone();
                } else {
                    // å·¦å³å­æ ‘éƒ½æœ‰ -> æ‰¾åˆ°å³å­æ ‘æœ€å°èŠ‚ç‚¹
                    let min_node = find_min(right.as_ref().unwrap());
                    let min_val = min_node.borrow().val;
                    drop(min_node);

                    node_rc.borrow_mut().val = min_val;
                    let new_right = delete_node(Some(Rc::clone(right.as_ref().unwrap())), min_val);
                    node_rc.borrow_mut().right = new_right;
                }
            }
            Some(node_rc)
        },
        None => None,
    }
}

fn find_min(mut node: &Rc<RefCell<TreeNode>>) -> Rc<RefCell<TreeNode>> {
    loop {
        let next = node.borrow().left.as_ref().map(|n| Rc::clone(n));
        match next {
            Some(child) => node = child,
            None => break,
        }
    }
    Rc::clone(node)
}
```

#### ç®—æ³•æ·±å…¥è§£æ

Rust å®ç°åœ¨è¯­æ³•å±‚é¢æ˜¾å¾—ç¨å¤æ‚ï¼Œä¸»è¦æ˜¯ç”±äºæ‰€æœ‰æƒå’Œå€Ÿç”¨æœºåˆ¶çš„å­˜åœ¨ï¼Œä½†å®ƒæä¾›äº†å†…å­˜å®‰å…¨ä¸é«˜æ€§èƒ½å…¼å¤‡çš„èƒ½åŠ›ï¼š

- ä½¿ç”¨ `Rc<RefCell<T>>` æ¥ç®¡ç†å…±äº«æ‰€æœ‰æƒï¼Œæ¨¡æ‹Ÿç±»ä¼¼åƒåœ¾å›æ”¶çš„è¡Œä¸ºï¼›
- `borrow_mut()` æ–¹æ³•ç”¨äºè·å¾—å†…éƒ¨å¯å˜å¼•ç”¨ï¼Œå¿…é¡»å°å¿ƒæ§åˆ¶ä½œç”¨åŸŸé˜²æ­¢å¤šé‡å€Ÿç”¨å†²çªï¼›
- åœ¨å…³é”®åœ°æ–¹æ’å…¥ `drop()` æ˜¾å¼é‡Šæ”¾å€Ÿç”¨é”ï¼Œé˜²æ­¢é€’å½’è¿‡ç¨‹ä¸­å‡ºç°å€Ÿç”¨å†²çªï¼›
- `take()` ç”¨äºè½¬ç§»å­—æ®µæ‰€æœ‰æƒï¼Œé¿å…å¤šæ¬¡å€Ÿç”¨å¯¼è‡´ panic

å°½ç®¡å®ç°ç¨æ˜¾æ›²æŠ˜ï¼Œä½†è¿™æ°æ°ä½“ç°å‡º Rust å¯¹ç³»ç»Ÿå®‰å…¨çš„é«˜åº¦å…³æ³¨ï¼Œä¹Ÿåæ˜ äº†å®ƒåœ¨åµŒå…¥å¼ã€åŒºå—é“¾ç­‰é«˜æ€§èƒ½é¢†åŸŸçš„é‡è¦æ€§

### E. å››ç§è¯­è¨€ç»¼åˆå¯¹æ¯”

| ç¼–ç¨‹è¯­è¨€      | æ˜¯å¦æ”¯æŒæ™ºèƒ½æŒ‡é’ˆ | å†…å­˜å®‰å…¨ç­‰çº§ | ç±»å‹æ£€æŸ¥å¼ºåº¦ | å¼€å‘ä½“éªŒ     |
| ------------- | ---------------- | ------------ | ------------ | ------------ |
| Go ğŸ¹         | å¦               | å®‰å…¨         | å¼±           | ç®€æ´é«˜æ•ˆ     |
| Python ğŸ     | å¦               | å®‰å…¨         | å¼±           | æè‡´ä¾¿åˆ©     |
| TypeScript ğŸŸ¦ | æ˜¯               | å®‰å…¨         | å¼º           | æ¸è¿›å¯é      |
| Rust ğŸ¦€       | æ˜¯               | æç«¯å®‰å…¨     | æå¼º         | å­¦ä¹ æˆæœ¬è¾ƒé«˜ |

#### æ€»ç»“

å¤šç§è¯­è¨€çš„å®ç°åœ¨ç®—æ³•æœ¬è´¨ä¸Šä¿æŒä¸€è‡´ï¼Œåªæ˜¯å—é™äºå„è‡ªè¯­è¨€ç‰¹æ€§çš„é™åˆ¶è€Œè¡¨ç°ç•¥æœ‰ä¸åŒã€‚Go é€‚åˆé«˜æ€§èƒ½æœåŠ¡ç«¯å¼€å‘ï¼›Python æ›´åŠ çµæ´»å¿«æ·ï¼Œé€‚åˆå¿«é€ŸåŸå‹å¼€å‘ï¼›TypeScript æå‡äº†å‰ç«¯å¼€å‘çš„è´¨é‡ä¿éšœï¼›Rust åˆ™é€‚ç”¨äºå¯¹æ€§èƒ½ä¸å®‰å…¨æ€§æé«˜è¦æ±‚çš„åº”ç”¨

## 4. ä¼ªä»£ç ä¸å¯è§†åŒ–æµç¨‹å›¾

### ä¼ªä»£ç 

```
å‡½æ•° deleteNode(node, key)
    å¦‚æœ node æ˜¯ç©ºèŠ‚ç‚¹
        è¿”å› ç©º
    å¦åˆ™å¦‚æœ key å°äº node.val
        è®¾ç½® node.left ä¸º deleteNode(node.left, key) çš„ç»“æœ
    å¦åˆ™å¦‚æœ key å¤§äº node.val
        è®¾ç½® node.right ä¸º deleteNode(node.right, key) çš„ç»“æœ
    å¦åˆ™ // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
        å¦‚æœ node æ²¡æœ‰å·¦å³å­èŠ‚ç‚¹
            è¿”å› ç©º
        å¦åˆ™å¦‚æœ node åªæœ‰å·¦å­èŠ‚ç‚¹
            è¿”å› node.left
        å¦åˆ™å¦‚æœ node åªæœ‰å³å­èŠ‚ç‚¹
            è¿”å› node.right
        å¦åˆ™ // æ—¢æœ‰å·¦åˆæœ‰å³
            æ‰¾åˆ°å³å­æ ‘ä¸­çš„æœ€å°èŠ‚ç‚¹ minRight
            å°† node.val è®¾ç½®ä¸º minRight.val
            è®¾ç½® node.right ä¸º deleteNode(node.right, minRight.val)
    è¿”å› node
```

### Mermaid æµç¨‹å›¾

```mermaid
graph TD
    A[å¼€å§‹] --> B{æ˜¯å¦ä¸ºNULL?}
    B -- æ˜¯ --> C[è¿”å›NULL]
    B -- å¦ --> D{key < node.val?}
    D -- æ˜¯ --> E[å‘å·¦é€’å½’]
    D -- å¦ --> F{key > node.val?}
    F -- æ˜¯ --> G[å‘å³é€’å½’]
    F -- å¦ --> H[æ˜¯å¦å¶å­èŠ‚ç‚¹?]
    H -- æ˜¯ --> I[è¿”å›NULL]
    H -- å¦ --> J{æ˜¯å¦åªæœ‰å·¦å­èŠ‚ç‚¹?}
    J -- æ˜¯ --> K[è¿”å›å·¦å­èŠ‚ç‚¹]
    J -- å¦ --> L{æ˜¯å¦åªæœ‰å³å­èŠ‚ç‚¹?}
    L -- æ˜¯ --> M[è¿”å›å³å­èŠ‚ç‚¹]
    L -- å¦ --> N[è·å–å³å­æ ‘æœ€å°èŠ‚ç‚¹]
    N --> O[äº¤æ¢å€¼å¹¶é€’å½’åˆ é™¤åç»§]
    O --> P[è¿”å›node]
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤ºä¸æµ‹è¯•ä»£ç 

### æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤ºï¼ˆä»¥ç¤ºä¾‹1ä¸ºä¾‹ï¼‰

| æ­¥éª¤ | å½“å‰èŠ‚ç‚¹å€¼ | å·¦å­æ ‘ | å³å­æ ‘ | æ“ä½œ                    |
| ---- | ---------- | ------ | ------ | ----------------------- |
| 1    | 5          | 3      | 6      | key = 3ï¼Œå‘å·¦èµ°         |
| 2    | 3          | 2      | 4      | æ‰¾åˆ°ç›®æ ‡èŠ‚ç‚¹            |
| 3    | 3ï¼ˆæ›¿æ¢ï¼‰  | 2      | 4      | æ›¿æ¢ä¸ºå³å­æ ‘ä¸­æœ€å°èŠ‚ç‚¹4 |
| 4    | 4ï¼ˆåˆ é™¤ï¼‰  | 2      | NULL   | åˆ é™¤èŠ‚ç‚¹4               |
| 5    | 5          | 4      | 6      | è¿”å›æœ€ç»ˆæ ‘              |

### å®Œæ•´æµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func deleteNode(root *TreeNode, key int) *TreeNode {
	if root == nil {
		return nil
	}
	if key < root.Val {
		root.Left = deleteNode(root.Left, key)
	} else if key > root.Val {
		root.Right = deleteNode(root.Right, key)
	} else {
		if root.Left == nil && root.Right == nil {
			return nil
		}
		if root.Left == nil {
			return root.Right
		}
		if root.Right == nil {
			return root.Left
		}
		minRight := findMin(root.Right)
		root.Val = minRight.Val
		root.Right = deleteNode(root.Right, minRight.Val)
	}
	return root
}

func findMin(node *TreeNode) *TreeNode {
	for node.Left != nil {
		node = node.Left
	}
	return node
}

func buildTree(vals []interface{}) *TreeNode {
	if len(vals) == 0 || vals[0] == nil {
		return nil
	}
	nodes := make([]*TreeNode, len(vals))
	for i := range vals {
		if v, ok := vals[i].(int); ok {
			nodes[i] = &TreeNode{Val: v}
		}
	}
	queue := []*TreeNode{nodes[0]}
	i := 1
	for len(queue) > 0 && i < len(vals) {
		curr := queue[0]
		queue = queue[1:]
		if i < len(vals) && vals[i] != nil {
			v := vals[i].(int)
			curr.Left = nodes[i]
			queue = append(queue, curr.Left)
		}
		i++
		if i < len(vals) && vals[i] != nil {
			v := vals[i].(int)
			curr.Right = nodes[i]
			queue = append(queue, curr.Right)
		}
		i++
	}
	return nodes[0]
}

func printInOrder(root *TreeNode) {
	if root == nil {
		return
	}
	printInOrder(root.Left)
	fmt.Print(root.Val, " ")
	printInOrder(root.Right)
}

func main() {
	tree := buildTree([]interface{}{5, 3, 6, 2, 4, nil, 7})
	fmt.Println("Before deletion:")
	printInOrder(tree)

	result := deleteNode(tree, 3)
	fmt.Println("\nAfter deletion:")
	printInOrder(result)
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

è¯¥ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(h)ï¼Œå…¶ä¸­ h ä¸ºæ ‘çš„é«˜åº¦ï¼›ç©ºé—´å¤æ‚åº¦ä¹Ÿä¸º O(h)ï¼Œä¸»è¦ç”¨äºé€’å½’è°ƒç”¨æ ˆ

#### æ”¯æ’‘è®ºç‚¹ A â€”â€” æ—¶é—´å¤æ‚åº¦åˆ†æ

- å¹³å‡æƒ…å†µä¸‹ï¼ˆå¹³è¡¡æ ‘ï¼‰ï¼šO(log n)ï¼›
- æœ€åæƒ…å†µä¸‹ï¼ˆé€€åŒ–æˆé“¾è¡¨ï¼‰ï¼šO(n)ï¼›
- åˆ é™¤æ“ä½œæœ€å¤šåªæ¶‰åŠä¸€æ¬¡æ—‹è½¬æˆ–æ›¿ä»£æ“ä½œï¼Œå› æ­¤æ¯æ¬¡æ“ä½œä¸º O(1)

#### æ”¯æ’‘è®ºç‚¹ B â€”â€” ç©ºé—´å¤æ‚åº¦åˆ†æ

- é€’å½’æ·±åº¦ç­‰äºæ ‘é«˜ hï¼›
- é¢å¤–ç©ºé—´ä»…ç”¨äºå­˜å‚¨å‡½æ•°è°ƒç”¨æ ˆå¸§ï¼›
- ä¸ä½¿ç”¨é¢å¤–æ•°ç»„æˆ–å…¶ä»–æ•°æ®ç»“æ„

#### æ”¯æ’‘è®ºç‚¹ C â€”â€” å¸¸æ•°å› å­ä¸å·¥ç¨‹å½±å“

- é€’å½’å‡½æ•°å¼€é”€è¾ƒå°ï¼›
- ä¸æ¶‰åŠå¤§é‡å¤åˆ¶æˆ–è½¬æ¢æ“ä½œï¼›
- æ€§èƒ½å—æ ‘å½¢çŠ¶å½±å“æ˜¾è‘—

#### æ”¯æ’‘è®ºç‚¹ D â€”â€” ç“¶é¢ˆè¯†åˆ«ä¸ä¼˜åŒ–æ–¹å‘

- ç“¶é¢ˆç‚¹ï¼šé€’å½’æ·±åº¦è¿‡å¤§æ—¶ï¼Œå¯èƒ½å¯¼è‡´çˆ†æ ˆï¼›
- ä¼˜åŒ–æ–¹å‘ï¼šå¯æ”¹å†™ä¸ºè¿­ä»£å®ç°ä»¥å‡å°‘æ ˆæ¶ˆè€—ï¼›
- è¿›ä¸€æ­¥ä¼˜åŒ–ï¼šç»´æŠ¤ AVL æˆ–çº¢é»‘æ ‘å±æ€§ï¼Œä¿è¯å¹³è¡¡

#### æ”¯æ’‘è®ºç‚¹ E â€”â€” ä¸åŒè§„æ¨¡ä¸‹çš„æ€§èƒ½æ›²çº¿ï¼ˆç†è®º vs å®é™…ï¼‰

| æ•°æ®è§„æ¨¡ n | ç†è®ºå¤æ‚åº¦    | å®é™…è¿è¡Œæ—¶é—´ä¼°ç®— |
| ---------- | ------------- | ---------------- |
| 10         | O(log 10)     | ~å‡ å¾®ç§’          |
| 1000       | O(log 1000)   | ~å‡ åå¾®ç§’        |
| 10000      | O(log 10000)  | ~ç™¾å¾®ç§’          |
| 100000     | O(log 100000) | ~æ¯«ç§’çº§åˆ«        |

### æ€»ç»“

è¯¥ç®—æ³•åœ¨å¤šæ•°æƒ…å†µä¸‹è¡¨ç°å‡ºä¼˜å¼‚æ€§èƒ½ï¼Œå°¤å…¶åœ¨æ¥è¿‘å¹³è¡¡çš„ BST ä¸Šæ•ˆæœæ›´å¥½ã€‚ä½†åœ¨æç«¯ä¸å¹³è¡¡çš„æ ‘ä¸­ä»æœ‰æ”¹è¿›ç©ºé—´

## 7. æŠ€å·§å½’çº³ä¸ç›¸ä¼¼é¢˜ç›®æ˜ å°„

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ¬è´¨æ˜¯"BST åˆ é™¤ç­–ç•¥"ï¼Œå…¶æ ¸å¿ƒæ€æƒ³åœ¨äºï¼šé€šè¿‡ä¸­åºåç»§æ›¿ä»£ + é€’å½’é‡æ„ï¼Œå®ŒæˆèŠ‚ç‚¹åˆ é™¤çš„åŒæ—¶ç»´æŒ BST ç»“æ„

#### æ”¯æ’‘è®ºç‚¹ A â€”â€” è®¾è®¡å“²å­¦æ€è€ƒ

BST åˆ é™¤ä¹‹æ‰€ä»¥æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºå®ƒå·§å¦™åœ°åˆ©ç”¨äº†"æœ‰åºæ€§"çš„ç»“æ„æ€§ä¼˜åŠ¿ï¼Œå°†å¤æ‚çš„ç»“æ„ç»´æŠ¤ä»»åŠ¡è½¬åŒ–ä¸ºç®€å•çš„æ•°å€¼æ›¿æ¢ä¸ç»“æ„è°ƒæ•´æ“ä½œ

#### æ”¯æ’‘è®ºç‚¹ B â€”â€” ç›¸ä¼¼é¢˜ç›®æ˜ å°„ä¸å…±æ€§åˆ†æ

| é¢˜ç›®ç¼–å· | åç§°                   | æ ¸å¿ƒæ€æƒ³                  |
| -------- | ---------------------- | ------------------------- |
| 701      | æ’å…¥äºŒå‰æœç´¢æ ‘         | åˆ©ç”¨ BST å±æ€§è¿›è¡Œæ’å…¥å®šä½ |
| 700      | æœç´¢äºŒå‰æœç´¢æ ‘         | åˆ©ç”¨ BST å±æ€§åŠ é€ŸæŸ¥æ‰¾     |
| 98       | éªŒè¯äºŒå‰æœç´¢æ ‘         | é€’å½’åˆ¤æ–­å·¦å³å­æ ‘åˆæ³•æ€§    |
| 450      | åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹ | æ›¿ä»£+é‡æ„ç­–ç•¥             |

#### æ”¯æ’‘è®ºç‚¹ C â€”â€” æ³›åŒ–ä¸åº”ç”¨æ‹“å±•

- æœç´¢ç±»åº”ç”¨ï¼šæœç´¢å¼•æ“å€’æ’ç´¢å¼•ç»“æ„ï¼›
- æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–ï¼šB/B+æ ‘çš„èŠ‚ç‚¹ç®¡ç†ï¼›
- å®æ—¶æ—¥å¿—åˆ†æç³»ç»Ÿï¼šé«˜æ•ˆæ£€ç´¢ä¸æ¸…ç†å†å²è®°å½•

#### æ”¯æ’‘è®ºç‚¹ D â€”â€” å·¥ä¸šç•Œå®é™…æ¡ˆä¾‹åˆ†æ

- Redis å­—å…¸å®ç°ï¼šä½¿ç”¨è·³è·ƒè¡¨ç»´æŠ¤æœ‰åºé›†åˆï¼›
- MySQL InnoDB ç´¢å¼•ï¼šB+æ ‘çš„é¡µåˆ†è£‚ä¸åˆå¹¶ï¼›
- åˆ†å¸ƒå¼è°ƒåº¦ç³»ç»Ÿï¼šé€šè¿‡æœ‰åºé˜Ÿåˆ—è¿›è¡Œä»»åŠ¡åˆ†é…ä¸å›æ”¶

#### æ”¯æ’‘è®ºç‚¹ E â€”â€” ç®—æ³•æ·±å…¥è§£æ

ä»ç†è®ºè§’åº¦çœ‹ï¼Œ"åˆ é™¤"æ“ä½œå®é™…ä¸Šæ˜¯å¯¹æœ€ä¼˜å­ç»“æ„çš„é‡æ–°ç»„åˆï¼Œä½“ç°äº†åŠ¨æ€è§„åˆ’æ€æƒ³çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µ

### æ€»ç»“

æŒæ¡ BST åˆ é™¤ç­–ç•¥ä¸ä»…èƒ½è§£å†³æœ¬é¢˜ï¼Œæ›´æ˜¯ä¸€ç§é€šç”¨çš„è®¾è®¡æ€æƒ³ï¼Œå¯ç”¨äºå¤šç§å®é™…ç³»ç»Ÿä¸­éœ€è¦é«˜æ•ˆå¢åˆ æŸ¥æ”¹çš„åœºæ™¯

## 8. é¢è¯•è¿½é—®ä¸é«˜åˆ†å›ç­”èŒƒå¼

### æ ¸å¿ƒç»“è®º

é’ˆå¯¹æœ¬é¢˜çš„é¢è¯•è¿½é—®ï¼Œå…¶è€ƒå¯Ÿæ ¸å¿ƒåœ¨äºæ•°æ®ç»“æ„ç†è§£èƒ½åŠ›ã€è¾¹ç•Œå¤„ç†èƒ½åŠ›å’Œç®—æ³•è¿ç§»èƒ½åŠ›

#### æ”¯æ’‘è®ºç‚¹ A â€”â€” åŸºç¡€è¿½é—®é›†

1. é—®é¢˜ï¼šä½ èƒ½å¦è§£é‡Šä¸€ä¸‹ä»€ä¹ˆæ˜¯ BSTï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šBST æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªèŠ‚ç‚¹æ»¡è¶³å·¦å­æ ‘å€¼å°äºè‡ªèº«ï¼Œå³å­æ ‘å€¼å¤§äºè‡ªèº«çš„æ€§è´¨
   åŠ åˆ†å›ç­”ï¼šBST çš„è¿™ä¸€ç‰¹æ€§è®©æˆ‘ä»¬å¯ä»¥åœ¨ O(log n) æ—¶é—´å†…å®Œæˆæœç´¢ã€æ’å…¥ã€åˆ é™¤ç­‰æ“ä½œï¼Œå‰ææ˜¯å®ƒæ˜¯å¹³è¡¡çš„

1. é—®é¢˜ï¼šå¦‚æœåˆ é™¤èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­©å­ï¼Œä½ æ€ä¹ˆå¤„ç†ï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šæˆ‘ä¼šæ‰¾åˆ°å®ƒçš„ä¸­åºåç»§ï¼ˆå³å­æ ‘çš„æœ€å°èŠ‚ç‚¹ï¼‰ï¼Œç”¨è¯¥èŠ‚ç‚¹å€¼æ›¿æ¢å¾…åˆ èŠ‚ç‚¹ï¼Œç„¶åå†é€’å½’åˆ é™¤è¿™ä¸ªåç»§èŠ‚ç‚¹
   åŠ åˆ†å›ç­”ï¼šè¿™æ˜¯ä¸ºäº†å°½é‡ä¿ç•™åŸå§‹æ ‘ç»“æ„çš„ä¸€è‡´æ€§ï¼ŒåŒæ—¶ä¹Ÿé¿å…ç ´å BST æ€§è´¨

1. é—®é¢˜ï¼šä½ èƒ½è¯´å‡ºåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦å—ï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šå¹³å‡æƒ…å†µæ˜¯ O(log n)ï¼Œæœ€åæ˜¯ O(n)
   åŠ åˆ†å›ç­”ï¼šè¿™æ˜¯å› ä¸ºæœ€åæƒ…å†µä¸‹æ ‘é€€åŒ–æˆäº†é“¾è¡¨ï¼Œæ­¤æ—¶æ¯æ¬¡åˆ é™¤éƒ½éœ€è¦ä»å¤´éå†åˆ°åº•éƒ¨æ‰èƒ½æ‰¾åˆ°èŠ‚ç‚¹

1. é—®é¢˜ï¼šæœ‰æ²¡æœ‰åŠæ³•é™ä½æœ€åæƒ…å†µçš„å‘ç”Ÿæ¦‚ç‡ï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šå¯ä»¥é€šè¿‡è‡ªå¹³è¡¡æœºåˆ¶ï¼Œæ¯”å¦‚ AVL æ ‘æˆ–çº¢é»‘æ ‘
   åŠ åˆ†å›ç­”ï¼šè¿™ç±»ç»“æ„é€šè¿‡å¯¹æ—‹è½¬æ“ä½œç»´æŠ¤æ ‘çš„é«˜åº¦å·®ï¼Œä»è€Œä¿è¯æ“ä½œå¤æ‚åº¦ç¨³å®šåœ¨ O(log n)

#### æ”¯æ’‘è®ºç‚¹ B â€”â€” é«˜é˜¶è¿½é—®é›†

1. é—®é¢˜ï¼šå¦‚æœä½ è¦åœ¨ä¸€æ£µå·¨å¤§çš„ BST ä¸­é¢‘ç¹åˆ é™¤èŠ‚ç‚¹ï¼Œä½ ä¼šæ€ä¹ˆåšï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šæˆ‘ä¼šå®šæœŸå¯¹æ ‘åš rebalance æ“ä½œï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨çº¢é»‘æ ‘ç»“æ„
   åŠ åˆ†å›ç­”ï¼šç”šè‡³å¯ä»¥ç»“åˆå¸ƒéš†è¿‡æ»¤å™¨é¢„å…ˆç­›é™¤ä¸å¯èƒ½å­˜åœ¨çš„å…ƒç´ ï¼Œå‡å°‘æ— æ•ˆæŸ¥æ‰¾æ¬¡æ•°

1. é—®é¢˜ï¼šä½ èƒ½ä¸èƒ½æŠŠè¿™æ®µä»£ç æ”¹æˆè¿­ä»£å½¢å¼ï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šå¯ä»¥ï¼Œéœ€è¦ç”¨æ˜¾å¼æ ˆä¿å­˜è·¯å¾„èŠ‚ç‚¹
   åŠ åˆ†å›ç­”ï¼šè€Œä¸”è¿˜éœ€è¦é¢å¤–å˜é‡è®°å½•çˆ¶å­å…³ç³»ï¼Œé˜²æ­¢ä¸¢å¤±ä¸Šä¸‹æ–‡ä¿¡æ¯

1. é—®é¢˜ï¼šä½ å¦‚ä½•ç¡®ä¿åˆ é™¤æ“ä½œä¸ä¼šç ´å BST çš„æ€§è´¨ï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šæˆ‘ä¼šåœ¨æ¯ä¸€æ­¥æ“ä½œä¹‹åæ£€æŸ¥å·¦å³å­æ ‘çš„å…³ç³»æ˜¯å¦ä¾ç„¶æ»¡è¶³ BST è¦æ±‚
   åŠ åˆ†å›ç­”ï¼šæ­¤å¤–è¿˜å¯ä»¥åŠ å…¥å…¨å±€éªŒè¯å‡½æ•°ï¼Œæ¯æ¬¡ä¿®æ”¹å®Œåè‡ªåŠ¨è§¦å‘å®Œæ•´æ€§æ ¡éªŒ

1. é—®é¢˜ï¼šå¦‚æœè®©ä½ è®¾è®¡ä¸€ä¸ªæ•°æ®åº“ç´¢å¼•ç®¡ç†ç³»ç»Ÿï¼Œä½ ä¼šæ€ä¹ˆå€Ÿé‰´ BST åˆ é™¤ç­–ç•¥ï¼Ÿ
   æ ‡å‡†å›ç­”ï¼šæˆ‘å¯èƒ½ä¼šé€‰ç”¨ B+æ ‘ï¼Œå¹¶å‚è€ƒ BST åˆ é™¤ä¸­çš„"èŠ‚ç‚¹æ›¿ä»£"ç­–ç•¥
   åŠ åˆ†å›ç­”ï¼šç‰¹åˆ«æ˜¯åœ¨èŠ‚ç‚¹åˆå¹¶é˜¶æ®µï¼Œå¯ä»¥ç”¨ç±»ä¼¼çš„æ€æƒ³è¿›è¡Œé¡µçº§åˆ«çš„åˆå¹¶ä¼˜åŒ–

#### æ”¯æ’‘è®ºç‚¹ C â€”â€” è¿½é—®èƒŒåçš„åŸç†å‰–æ

é¢è¯•å®˜æé—®çš„æ ¹æœ¬ç›®çš„æ˜¯æ£€éªŒå€™é€‰äººæ˜¯å¦å…·å¤‡ä»¥ä¸‹å‡ ç§æ ¸å¿ƒç´ è´¨ï¼š

- é€»è¾‘æ€ç»´ä¸¥å¯†æ€§ï¼šæ˜¯å¦èƒ½æ¸…æ¥šåœ°åŒºåˆ†å„ç§è¾¹ç•Œæƒ…å†µï¼›
- å·¥ç¨‹å®è·µç»éªŒç§¯ç´¯ï¼šæ˜¯å¦äº†è§£ç®—æ³•çš„å®é™…å±€é™æ€§ä¸ä¼˜åŒ–ç©ºé—´ï¼›
- ç³»ç»Ÿæ¶æ„æ„è¯†ï¼šèƒ½å¦è·³å‡ºå•ä¸€é—®é¢˜èŒƒç•´ï¼Œæ€è€ƒå…¶åœ¨æ•´ä¸ªç³»ç»Ÿä¸­çš„è§’è‰²ä¸è´£ä»»

### æ€»ç»“

ç³»ç»Ÿçš„å‡†å¤‡è¿™äº›è¿½é—®ä¸ä»…èƒ½å±•ç¤ºæ‰å®çš„çŸ¥è¯†å‚¨å¤‡ï¼Œæ›´èƒ½ä½“ç°è‰¯å¥½çš„æ²Ÿé€šè¡¨è¾¾èƒ½åŠ›ï¼Œä»è€Œèµ¢å¾—é¢è¯•å®˜çš„å¥½è¯„ã€‚ğŸŒŸ

## 9. å¤ä¹ è¦ç‚¹æç‚¼ä¸æ¨¡æ¿æ€»ç»“

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜çš„å…³é”®åœ¨äºç‰¢è®° BST åˆ é™¤ç­–ç•¥ã€è§„é¿å¸¸è§è¯¯åŒºï¼Œå¹¶å½¢æˆä¸€å¥—ç¨³å®šçš„è§£é¢˜æ¨¡æ¿

#### æ”¯æ’‘è®ºç‚¹ A â€”â€” å…³é”®è®°å¿†ç‚¹æ€»ç»“ ğŸŒŸ

- âœ… è®°ä½ BST åˆ é™¤çš„ä¸‰ç§æƒ…å½¢ï¼šå¶å­ã€å•å­©ã€åŒå­©ï¼›
- âœ… æŒæ¡ä¸­åºåç»§æ›¿ä»£ç­–ç•¥ï¼›
- âœ… æ³¨æ„é€’å½’è¿”å›æ›´æ–°æ ¹èŠ‚ç‚¹ï¼›
- âœ… ä¿æŒæ ‘ç»“æ„ä¸å˜æ€§çš„å…³é”®æ˜¯å€¼æ›¿æ¢+é€’å½’åˆ é™¤

#### æ”¯æ’‘è®ºç‚¹ B â€”â€” å¸¸è§æ˜“é”™é™·é˜± âš ï¸

| é”™è¯¯ç‚¹                     | åŸå› åˆ†æ                   |
| -------------------------- | -------------------------- |
| å¿˜è®°æ›´æ–°çˆ¶èŠ‚ç‚¹æŒ‡å‘         | ä¼šå¯¼è‡´åˆ é™¤æ— æ•ˆï¼Œæ ‘ç»“æ„æ–­è£‚ |
| æ··æ·†å‰åé©±ä¸å·¦å³å­æ ‘       | å½±å“æ›¿æ¢èŠ‚ç‚¹é€‰å–           |
| æœªæ­£ç¡®å¤„ç†ç©ºæŒ‡é’ˆ           | å¯èƒ½å¼•å‘è¿è¡ŒæœŸå´©æºƒ         |
| é”™è¯¯ä½¿ç”¨åç»§èŠ‚ç‚¹åœ°å€è€Œéå€¼ | é€ æˆä¸å¿…è¦çš„å¯¹è±¡å¤åˆ¶       |

#### æ”¯æ’‘è®ºç‚¹ C â€”â€” é¢è¯•è¯„åˆ†å…³é”®è¯ âœ…

| å…³é”®è¯          | å«ä¹‰è¯´æ˜                 |
| --------------- | ------------------------ |
| ä¸­åºåç»§        | BST åˆ é™¤ç­–ç•¥æ ¸å¿ƒæ€æƒ³     |
| é€’å½’å›ä¼         | æ›´æ–°çˆ¶èŠ‚ç‚¹æŒ‡å‘çš„å¿…è¦æ‰‹æ®µ |
| å€¼æ›¿æ¢          | ä¿æŒç»“æ„ä¸€è‡´æ€§çš„é‡è¦æ–¹æ³• |
| æ—¶é—´/ç©ºé—´å¤æ‚åº¦ | è¡¡é‡ç®—æ³•è´¨é‡çš„æ ‡å‡†       |

#### æ”¯æ’‘è®ºç‚¹ D â€”â€” å¤ä¹ å»ºè®®ä¸çŸ¥è¯†å›¾è°± ğŸ“šğŸš€

- ğŸ” å®šæœŸåˆ·ç»ƒç›¸ä¼¼é¢˜å‹ï¼ŒåŠ å¼ºæ‰‹å†™èƒ½åŠ›ï¼›
- ğŸ“˜ ç³»ç»Ÿå­¦ä¹  BST ç›¸å…³æ“ä½œï¼ˆæ’å…¥/åˆ é™¤/æŸ¥æ‰¾ï¼‰ï¼›
- ğŸ’¡ äº†è§£ AVLã€çº¢é»‘æ ‘ç­‰è¿›é˜¶ç»“æ„ï¼›
- ğŸ§ª è‡ªä¸»ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œæé«˜ä»£ç è´¨é‡æ„è¯†

#### æ”¯æ’‘è®ºç‚¹ E â€”â€” å¯å¤ç”¨è§£é¢˜æ¨¡æ¿æç‚¼

```text
function deleteNode(node, key)
    if node is null
        return null
    if key < node.val
        node.left = deleteNode(node.left, key)
    else if key > node.val
        node.right = deleteNode(node.right, key)
    else
        if no children
            return null
        if only one child
            return that child
        else
            replace with inorder successor
            recursively delete the successor
    return node
```

### æ€»ç»“

å°†ä¸Šè¿°çŸ¥è¯†ç‚¹ç³»ç»Ÿæ¶ˆåŒ–å¸æ”¶åï¼Œå°±èƒ½è½»æ¾åº”å¯¹å„ç§ BST åˆ é™¤ç›¸å…³é¢˜ç›®ï¼ŒçœŸæ­£å®ç°ä»"ä¼šåš"åˆ°"ç²¾é€š"çš„è·¨è¶Šã€‚ğŸ‰
