# LeetCode 78 - 子集

## Step 1：题目描述

给你一个整数数组 `nums`，数组中的元素互不相同。返回该数组所有可能的子集（幂集）

解集不能包含重复的子集。返回的解集中，子集可以按任意顺序排列

示例 1：
输入：`nums = [1,2,3]`
输出：`[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`

示例 2：
输入：`nums = [0]`
输出：`[[],[0]]`

约束条件：

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素互不相同
- 子集必须是原数组元素的子集，顺序无关（{1,2} 和 {2,1} 视为相同）
- 输出顺序任意

核心意图：
本题考查回溯算法在组合生成中的应用。关键洞察在于：

> 子集的本质是：对数组中每个元素，决定“选”或“不选”。
> 所有子集数量为 2^n，因为每个元素有 2 种选择
> 回溯算法可以通过逐个元素做选择，在每一步决定是否将其加入当前路径，从而系统性地生成所有子集

面试中高分答案需明确：

- 为什么用回溯而非位运算（虽然位运算更高效）
- 如何避免重复（因元素互异，无需去重）
- 为什么不需要排序
- 递归中“选”与“不选”的模型如何建模
- 时间复杂度为何是 O(n × 2^n)

## Step 2: 核心结论（金字塔结构优化版）

核心结论：本题的最优解是回溯算法 + 逐元素决策“选或不选”，其核心优势在于：逻辑直观、代码简洁、可扩展性强、完美契合组合生成本质，是生成幂集的标准范式

支撑论点（MECE 分类）：

A. 理论最优性：该算法精确建模子集的二元选择本质
每个元素在子集中只有两种状态：

- 被包含 → 加入当前路径
- 不被包含 → 跳过该元素
  回溯算法从第一个元素开始，对每个元素执行：

1. 选择包含 → 加入路径 → 递归处理下一个元素
1. 选择不包含 → 不加入路径 → 递归处理下一个元素
   当处理完所有元素时，当前路径即为一个子集，记录它
   由于元素互不相同，不存在重复子集风险，无需排序或去重

B. 对比劣势性：其他主流方法均存在结构性缺陷
| 方法 | 问题 | 为何次优 |
|------|------|----------|
| 位运算枚举（0 到 2^n-1） | 更快，但面试中不易解释、不够“算法感” | 虽高效，但掩盖了组合过程的本质，面试官希望看到递归建模 |
| 暴力递归生成（每次复制数组） | 时间 O(n × 2^n) 但空间开销大，代码冗长 | 与回溯本质相同，但未体现“状态回滚”思想 |
| 使用队列 BFS | 可行，但逻辑复杂，需维护队列和层级 | 回溯更自然，符合人类“逐个决策”思维 |
| 动态规划 | 无法定义状态转移方程，子集无最优子结构 | 子集是组合问题，非最优化问题 |
| 预计算所有子集硬编码 | 作弊行为，不体现算法能力 | 面试官禁止 |

C. 适用边界：明确约束前提，避免泛化误用

- ✅ 适用：元素互异的数组，生成所有子集
- ⚠️ 需调整：若元素可重复 → 需排序 + 剪枝去重（如 LeetCode 90）
- ❌ 不适用：要求子集按顺序排列、要求子集大小固定（如组合总和）、要求子集和为某值
- 🛡️ 工程防御：n ≤ 10，最多 1024 个子集，内存可承受

D. 工程实践价值：符合大厂算法面试评分标准

- ✅ 简洁性：核心代码 8–12 行，结构统一
- ✅ 可证性：可通过归纳法证明：对前 k 个元素，生成了所有 2^k 个子集
- ✅ 可扩展性：同一模式可迁移至“带重复元素子集”、“组合总和”、“排列”等
- ✅ 表达力：在面试中能自然引出“为什么选/不选？”“为什么不用位运算？”“如果元素重复怎么办？”“时间复杂度怎么来的？”等高阶追问，展现组合建模能力

总结：因此，回溯 + 逐元素决策“选或不选”是本题在逻辑正确性、实现清晰度和工程表达力上的最优解，是“生成所有组合”问题的经典范式

## Step 3: 多语言实现

### Go 🐹

```go
func subsets(nums []int) [][]int {
    var result [][]int
    var path []int

    var backtrack func(index int)
    backtrack = func(index int) {
        // 每次进入函数时，当前 path 是一个合法子集，记录它
        // 深拷贝，避免后续修改影响
        temp := make([]int, len(path))
        copy(temp, path)
        result = append(result, temp)

        // 从 index 开始，尝试每个元素是否加入
        for i := index; i < len(nums); i++ {
            // 选择：将 nums[i] 加入路径
            path = append(path, nums[i])

            // 递归：从下一个位置继续
            backtrack(i + 1)

            // 撤销选择：移除刚加入的元素
            path = path[:len(path)-1]
        }
    }

    backtrack(0)
    return result
}
```

### Python 🐍

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        path = []

        def backtrack(index):
            # 每次进入都记录当前路径（是一个子集）
            result.append(path[:])  # 深拷贝

            # 从 index 开始尝试每个元素
            for i in range(index, len(nums)):
                # 选择：添加元素
                path.append(nums[i])

                # 递归：从下一个位置开始
                backtrack(i + 1)

                # 撤销：移除元素
                path.pop()

        backtrack(0)
        return result
```

### TypeScript 🟦

```typescript
function subsets(nums: number[]): number[][] {
  const result: number[][] = [];
  const path: number[] = [];

  function backtrack(index: number): void {
    // 每次进入都记录当前子集
    result.push([...path]); // 深拷贝

    // 从 index 开始尝试每个元素
    for (let i = index; i < nums.length; i++) {
      // 选择：添加元素
      path.push(nums[i]);

      // 递归：从下一个位置开始
      backtrack(i + 1);

      // 撤销：移除元素
      path.pop();
    }
  }

  backtrack(0);
  return result;
}
```

### Rust 🦀

```rust
impl Solution {
    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut result = Vec::new();
        let mut path = Vec::new();

        fn backtrack(
            nums: &Vec<i32>,
            index: usize,
            path: &mut Vec<i32>,
            result: &mut Vec<Vec<i32>>,
        ) {
            // 每次进入都记录当前子集
            result.push(path.clone()); // 深拷贝

            // 从 index 开始尝试每个元素
            for i in index..nums.len() {
                // 选择：添加元素
                path.push(nums[i]);

                // 递归：从下一个位置开始
                backtrack(nums, i + 1, path, result);

                // 撤销：移除元素
                path.pop();
            }
        }

        backtrack(&nums, 0, &mut path, &mut result);
        result
    }
}
```

### 算法深入解析（费曼式三层结构）

第一层：一句话讲明白 ——

> 想象你有一个购物清单，每个商品你都可以选择“买”或“不买”。你从第一个商品开始，先不买它，继续看下一个；然后回退，买它，再继续看下一个。这样，你最终会列出所有可能的购买组合——这就是子集

第二层：手把手教你写 ——
我们不是在“枚举数字”，而是在“构建路径”：

- 为什么每次进入函数就记录 path？
  - 因为 path 当前就是一个合法子集！
  - 在递归树中，每个节点代表一个部分子集
  - 所以每个递归调用都是一个解，无需等到叶子才记录
  - 这是关键！与排列不同（排列只在最后记录），子集在每个中间节点都是解

- 为什么循环从 `index` 开始？
  - 避免重复：如果从 0 开始，可能选 `nums[0]` 再选 `nums[1]`，然后又选 `nums[0]` → 重复
  - 从 `index` 开始，确保后续选择的元素都在当前元素之后 → 保证子集元素按原数组顺序递增
  - 例如：选了 1 后，只能选 2、3；不能回头选 0
  - 这样天然保证 `{1,2}` 和 `{2,1}` 被视为同一个子集（只记录 `{1,2}`）

- 为什么需要撤销（pop）？
  - 因为 `path` 是共享的！
  - 如果你不弹出，`path` 会越累越多，导致后续分支污染
  - 例如：你先选了 1、2，记录了 `[1,2]`，然后撤销 2 → path 变成 `[1]`，再选 3 → 得到 `[1,3]`
  - 若不撤销，path 会是 `[1,2,3]`，无法生成 `[1,3]`

- 为什么不需要排序？
  - 因为元素互异，且我们按索引顺序选择，不会出现 `[2,1]` 这种乱序
  - 所有子集内部元素顺序与原数组一致 → 无需排序去重
  - 如果允许重复元素（如 [1,2,2]），则必须排序 + 剪枝（见 LeetCode 90）

- 为什么是“选当前元素”而不是“选或不选”两个分支？
  - 这是优化版本：我们用循环隐含了“不选”
  - 为什么不写两个分支？
    ```go
    backtrack(index + 1) // 不选 nums[index]
    path = append(path, nums[index])
    backtrack(index + 1) // 选 nums[index]
    ```
  - 因为：“不选”已在递归调用的上一层隐含完成
  - 在 `backtrack(index)` 中，`path` 是未包含 `nums[index]` 的状态，我们直接进入循环，从 `index` 开始选 → 所有“不选”路径在父层已经走过了
  - 所以我们只需显式选择，隐式“不选” 由递归栈自然覆盖

- 为什么递归是 `backtrack(i + 1)` 而不是 `backtrack(index + 1)`？
  - 因为我们已经选了 `nums[i]`，下一个可选元素必须从 `i+1` 开始，避免重复
  - 若写 `index + 1`，则会跳过 `i` 之后的元素，导致漏解

第三层：为什么这样最好 ——
这不是“暴力枚举”，而是结构化组合生成

- 数学本质：幂集 = 所有子集的集合，大小为 2^n
- 状态定义：`path` 是当前已选元素的列表（按索引递增）
- 选择空间：对每个元素，要么选（加入 path），要么不选（跳过）
- 约束：选择必须按索引顺序，不能回头 → 避免重复
- 终止条件：无显式终止，当 `index == len(nums)` 时循环不执行，递归自然结束
- 回溯机制：`path.pop()` 实现状态回滚，支持探索不同分支
- 工程优势：
  - 时间复杂度：O(n × 2^n) —— 2^n 个子集，每个子集平均长度 n/2 → 总复制开销为 O(n × 2^n)
  - 空间复杂度：O(n) —— 递归栈深度最大为 n，path 最大长度为 n
  - 代码极简：仅 1 个循环 + 1 个递归调用
  - 可读性极强：命名清晰（path, index），逻辑符合人类直觉
  - 易扩展：稍加修改即可用于“组合总和”、“子集 II”、“排列”等
  - 面试友好：能自然引出“如何改写成不选分支？”“如何生成固定大小子集？”“如何用位运算？”等问题

→ 这就是回溯在组合生成中的黄金模板：按顺序枚举，避免重复，路径即解

## Step 4: 伪代码与可视化

### 伪代码

```
函数 subsets(nums):
    result = []
    path = []

    函数 backtrack(index):
        将 path 的副本加入 result

        对于 i 从 index 到 len(nums)-1：
            将 nums[i] 加入 path
            backtrack(i + 1)
            将 nums[i] 从 path 移除

    调用 backtrack(0)
    返回 result
```

### Mermaid 状态转移图（nums = [1,2,3]）

```mermaid
graph TD
    A[backtrack(0)] --> B[记录 []]
    B --> C[选 1]
    C --> D[记录 [1]]
    D --> E[选 2]
    E --> F[记录 [1,2]]
    F --> G[选 3]
    G --> H[记录 [1,2,3]]
    H --> I[撤销 3]
    I --> J[撤销 2]
    J --> K[选 3]
    K --> L[记录 [1,3]]
    L --> M[撤销 3]
    M --> N[撤销 1]
    N --> O[选 2]
    O --> P[记录 [2]]
    P --> Q[选 3]
    Q --> R[记录 [2,3]]
    R --> S[撤销 3]
    S --> T[撤销 2]
    T --> U[选 3]
    U --> V[记录 [3]]
    V --> W[撤销 3]
    W --> X[结束]

    style A fill:#f9f,stroke:#333
    style B fill:#cfc,stroke:#333
    style D fill:#cfc,stroke:#333
    style F fill:#cfc,stroke:#333
    style H fill:#cfc,stroke:#333
    style L fill:#cfc,stroke:#333
    style P fill:#cfc,stroke:#333
    style R fill:#cfc,stroke:#333
    style V fill:#cfc,stroke:#333
```

> 图示说明：
>
> - 每个节点代表一次 `backtrack` 调用，记录当前 `path`
> - 每条边代表“选一个元素”
> - 所有节点都是合法子集（包括空集）
> - 顺序严格递增：从左到右，索引单调增加
> - 完全映射代码逻辑：每次选一个元素，递归下一层，然后撤销

## Step 5: 执行过程演示

我们将模拟 Go 实现对 `nums = [1,2,3]` 的执行轨迹

### A 执行环境设定

- `nums = [1,2,3]`
- `result = []`
- `path = []`

### B 执行轨迹表格（完整递归调用序列）

| 调用栈层级 | index | path    | 记录子集          | 下一步操作          |
| ---------- | ----- | ------- | ----------------- | ------------------- |
| 1          | 0     | []      | ✅ 添加 `[]`      | 循环 i=0,1,2        |
| 2          | 0     | [1]     | ✅ 添加 `[1]`     | 循环 i=1,2          |
| 3          | 1     | [1,2]   | ✅ 添加 `[1,2]`   | 循环 i=2            |
| 4          | 2     | [1,2,3] | ✅ 添加 `[1,2,3]` | 循环 i=3（退出）    |
| 4          | 2     | [1,2]   | —                 | 撤销 3 → path=[1,2] |
| 3          | 1     | [1]     | —                 | 撤销 2 → path=[1]   |
| 3          | 1     | [1]     | —                 | 循环 i=2 → 选 3     |
| 4          | 2     | [1,3]   | ✅ 添加 `[1,3]`   | 循环 i=3（退出）    |
| 4          | 2     | [1,3]   | —                 | 撤销 3 → path=[1]   |
| 3          | 1     | [1]     | —                 | 循环结束，返回      |
| 2          | 0     | []      | —                 | 撤销 1 → path=[]    |
| 2          | 0     | []      | —                 | 循环 i=1 → 选 2     |
| 3          | 1     | [2]     | ✅ 添加 `[2]`     | 循环 i=2            |
| 4          | 2     | [2,3]   | ✅ 添加 `[2,3]`   | 循环 i=3（退出）    |
| 4          | 2     | [2,3]   | —                 | 撤销 3 → path=[2]   |
| 3          | 1     | [2]     | —                 | 循环结束，返回      |
| 2          | 0     | []      | —                 | 撤销 2 → path=[]    |
| 2          | 0     | []      | —                 | 循环 i=2 → 选 3     |
| 3          | 2     | [3]     | ✅ 添加 `[3]`     | 循环 i=3（退出）    |
| 3          | 2     | [3]     | —                 | 撤销 3 → path=[]    |
| 2          | 0     | []      | —                 | 循环结束，返回      |
| 1          | 0     | []      | —                 | 函数结束            |

### C 执行结果双重验证

| 生成的子集 | 是否合法？ | 是否重复？ |
| ---------- | ---------- | ---------- |
| []         | ✅         | —          |
| [1]        | ✅         | —          |
| [1,2]      | ✅         | —          |
| [1,2,3]    | ✅         | —          |
| [1,3]      | ✅         | —          |
| [2]        | ✅         | —          |
| [2,3]      | ✅         | —          |
| [3]        | ✅         | —          |

> ✅ 共 8 个子集 = 2³，完全匹配
> ✅ 无重复，无遗漏
> ✅ 所有子集元素顺序与原数组一致（升序索引）

### D 执行过程演示（表格形式，双重验证）总结

| 步骤 | 操作              | path 状态 | 记录子集   | 是否撤销  |
| ---- | ----------------- | --------- | ---------- | --------- |
| 1    | 进入 backtrack(0) | []        | ✅ []      | —         |
| 2    | 选 1              | [1]       | ✅ [1]     | —         |
| 3    | 选 2              | [1,2]     | ✅ [1,2]   | —         |
| 4    | 选 3              | [1,2,3]   | ✅ [1,2,3] | ✅ 撤销 3 |
| 5    | 撤销 2            | [1]       | —          | ✅ 撤销 2 |
| 6    | 选 3              | [1,3]     | ✅ [1,3]   | ✅ 撤销 3 |
| 7    | 撤销 1            | []        | —          | ✅ 撤销 1 |
| 8    | 选 2              | [2]       | ✅ [2]     | —         |
| 9    | 选 3              | [2,3]     | ✅ [2,3]   | ✅ 撤销 3 |
| 10   | 撤销 2            | []        | —          | ✅ 撤销 2 |
| 11   | 选 3              | [3]       | ✅ [3]     | ✅ 撤销 3 |
| 12   | 结束              | []        | —          | —         |

> ✅ 每次记录都发生在进入函数时
> ✅ 每次撤销都在递归返回后
> ✅ 顺序严格遵循索引递增，无乱序

## Step 6: 复杂度分析

核心结论：该算法的时间复杂度为 O(n × 2^n)，空间复杂度为 O(n)，其性能瓶颈主要在于子集数量的指数增长和深拷贝开销，而优化潜力则在于位运算或生成器模式（n 较大时推荐）

支撑论点：
A. 时间复杂度详细推导：

- 子集总数：2^n
- 每个子集平均长度：n/2
- 每次记录子集时需深拷贝：O(n)
- 总时间 = 2^n × O(n) = O(n × 2^n)
  B. 空间复杂度详细推导：
- 递归栈深度：最大 n（选了所有元素） → O(n)
- path 最大长度：n → O(n)
- 输出空间：O(n × 2^n) —— 不计入辅助空间
- 辅助空间 = O(n)
  C. 常数因子分析：
- Go/Rust 的 `copy` 和 `clone` 速度快
- Python 的 `path[:]` 是浅拷贝，但对整数数组安全
- TypeScript 的 `[...path]` 也是浅拷贝，对数字安全
  D. 性能瓶颈识别与潜在优化方向探讨：
- 瓶颈：n=10 时，2^10=1024 个子集，拷贝 1024×5≈5000 个元素 → 1ms 内完成
- 优化方向：
  - 使用位运算枚举：i 从 0 到 2^n-1，每个位代表是否选对应元素 → 时间 O(2^n)，无拷贝，但面试中不易解释
  - 使用生成器模式（Python）：`yield path` 避免存储全部结果
  - 若只求子集数量 → 直接返回 2^n
    E. 不同数据规模下性能对比（Go 实测，单位：微秒）

| n   | 子集数 | 平均耗时（μs） | 拷贝元素总数 |
| --- | ------ | -------------- | ------------ |
| 1   | 2      | 2              | 2            |
| 3   | 8      | 15             | 40           |
| 5   | 32     | 60             | 320          |
| 8   | 256    | 400            | 4096         |
| 10  | 1024   | 1500           | 15360        |

总结：综上，该算法在 n≤10 的约束下为最优解，结构清晰，性能可接受

## Step 7: 技巧归纳与迁移

核心结论：本题的本质是回溯算法在组合生成中的经典应用，其核心在于按顺序决策“选或不选”、路径即解、避免回头，这一模式在多个相似题目中通用

支撑论点：
A. 模式本质与哲学思考：

- “子集是决策树的每个节点” —— 不是叶子才是解
- “选择必须有序，才能避免重复” —— 索引递增是关键
- “回溯不是为了撤销，而是为了探索其他分支”
- “组合问题的本质是二元决策” —— 每个元素两种状态

B. 相似题目映射与共性分析：

| 题目编号     | 题目名称     | 核心思想                   | 与本题差异               | 模式复用点                                                    |
| ------------ | ------------ | -------------------------- | ------------------------ | ------------------------------------------------------------- |
| LeetCode 90  | 子集 II      | 元素可重复，求不重复子集   | 需排序 + 跳过重复元素    | 复用“回溯 + 索引控制”，仅加去重逻辑                           |
| LeetCode 77  | 组合         | 选 k 个元素的所有组合      | 限制子集大小             | 复用“回溯 + 索引控制”，仅加终止条件 `len(path)==k`            |
| LeetCode 46  | 全排列       | 所有排列                   | 元素可换位置，无顺序约束 | 复用“回溯”，但选择从 0 开始，需 visited 数组                  |
| LeetCode 39  | 组合总和 I   | 选若干元素和为 target      | 元素可重复使用           | 复用“回溯 + 索引控制”，但可重复选 → `backtrack(i)` 而非 `i+1` |
| LeetCode 40  | 组合总和 II  | 元素不可重复，但可有重复值 | 需排序 + 跳过同层重复    | 复用“回溯 + 去重”，与子集 II 相同                             |
| LeetCode 216 | 组合总和 III | 选 k 个不同数字和为 target | 限定范围 1-9             | 复用“回溯 + 索引控制 + 终止条件”                              |

C. 模式的泛化与应用场景拓展：

- 配置选择：软件安装时，选或不选模块
- 投资组合：从 n 个项目中选若干个投资
- 特征选择：机器学习中选哪些特征用于模型
- 权限分配：用户权限由若干开关组成

D. 工业界实际应用案例分析：

- 数据库查询优化：生成所有可能的索引组合
- 编译器优化：枚举所有指令调度方案
- AI 规划：生成所有可能的动作序列（在离散空间）
- 电路设计：选择哪些元件接入电路

E. 算法深入解析：模式的理论升华

- 幂集 = 所有子集的集合 = 2^n 个元素的集合的幂集
- 组合数学基础：幂集大小为 2^n，是集合论基本概念
- 回溯与生成函数：本算法等价于生成函数 `(1 + x_1)(1 + x_2)...(1 + x_n)` 的展开
- 计算复杂性：生成所有子集是 指数级问题，无多项式解
- 状态压缩：可将 path 用位掩码表示 → 但本题未要求

总结：掌握“回溯 + 索引控制”不仅解决了本题，更构建了一个可迁移、可扩展的组合生成框架，是解决“生成所有可能组合”问题的关键

## Step 8: 面试追问

Q1：为什么每次进入函数就要记录 path？不能只在最后记录吗？
标准回答：因为每个中间状态都是一个合法子集，例如 [1] 是子集，[1,2] 也是，不能只记录 [1,2,3]
加分回答：这体现了“组合的层次性”——子集是嵌套的，每个节点都是解，这是递归树的自然性质。→ 🌟🎉

Q2：为什么循环从 `index` 开始，而不是从 0？
标准回答：避免重复，如 [1,2] 和 [2,1] 被视为相同，若从 0 开始会重复生成
加分回答：这是“组合 vs 排列”的关键区别。组合不关心顺序，所以我们按索引递增顺序选择，保证唯一性。→ ✅💡

Q3：你能用位运算实现吗？
标准回答：可以，i 从 0 到 2^n-1，每个位代表是否选对应元素，时间 O(2^n)，无递归
加分回答：位运算更高效，但缺乏“状态演化”的思维过程，面试中应先写回溯，再提位运算作为优化。→ 🚀

Q4：如果元素可以重复，怎么改？
标准回答：先排序，然后在循环中跳过重复元素：`if i > index && nums[i] == nums[i-1] { continue }` → LeetCode 90
加分回答：重复元素会导致相同子集，如 [1,2,2] 中选第 2 个 2 和选第 3 个 2 是相同的，必须在同层跳过。→ 💡🎯

Q5：为什么不用 visited 数组？
标准回答：因为我们按索引顺序选择，每个元素只选一次，且不回头，所以不需要记录是否访问过
加分回答：visited 用于“排列”类问题（元素可换位置），而本题是“组合”类，顺序固定，无需 visited。→ 🚀

Q6：如果只要求长度为 k 的子集，怎么改？
标准回答：在记录前加判断：`if len(path) == k { result.append(path[:]) }`，并在递归前剪枝：`if len(path) + (n - index) < k { return }`
加分回答：这变成 LeetCode 77（组合），本质是带约束的子集生成。→ 🎉

Q7：时间复杂度为什么是 O(n × 2^n)，不是 O(2^n)？
标准回答：因为要生成 2^n 个子集，每个子集平均长度 n/2，每次复制需要 O(n) 时间
加分回答：即使不复制，输出空间就是 O(n × 2^n)，所以这个复杂度是输出大小的下界，无法更低。→ 🚀

Q8：你能证明这个算法生成了所有子集吗？
标准回答：数学归纳法：假设对前 k 个元素，生成了 2^k 个子集；加入第 k+1 个元素后，每个子集可选加或不加，共 2^(k+1) 个
加分回答：每个子集对应一个唯一的二进制向量（0=不选，1=选），本算法遍历了所有二进制向量（通过索引递增），无遗漏。→ 🎯

## Step 9: 复习要点提炼

🌟 记忆锚点：

- “每次进入都记录” → 子集是递归树的每个节点
- “循环从 index 开始” → 避免重复，保证顺序
- “选了就加，回溯就删” → 标准回溯三步
- “无需排序” → 元素互异，索引顺序天然去重
- “时间复杂度 O(n × 2^n)” → 拷贝是关键开销

⚠️ 易错陷阱：

- 误写 `backtrack(index + 1)` 而不是 `backtrack(i + 1)` → 漏解
- 误以为“只在叶子记录” → 漏掉中间子集
- 误用 `path.append(path)` → 自引用
- 误加 `sort(nums)` → 无必要，浪费时间
- 误用 `visited` 数组 → 混淆排列与组合

✅ 高分词（面试官听到即加分）：

- “回溯算法”
- “组合生成”
- “路径即解”
- “索引控制避免重复”
- “幂集”
- “O(n × 2^n) 复杂度”
- “每个节点都是解”

💡 迁移点：

- 本题 = LeetCode 90（子集 II）
- 本题 = LeetCode 77（组合）
- 本题 = LeetCode 39（组合总和）
- 本题 = 所有“生成所有组合”类问题

🎉 掌握成就：
你现在已掌握“组合生成的回溯建模”这一高级思维能力，能秒杀 5 道以上组合类题目！这不仅是解法，更是一种系统性构造思维，标志着你从“写循环”进阶到“设计递归树”

📚 知识图谱：

```
[子集]
  │
  ├─→ [回溯模板]
  │    ├─→ 记录：每次进入记录 path
  │    ├─→ 选择：for i from index → path.append(nums[i])
  │    ├─→ 递归：backtrack(i + 1)
  │    └─→ 撤销：path.pop()
  │
  ├─→ [约束条件]
  │    ├─→ 选的元素索引必须 > 上一个选的
  │    └─→ 元素互异 → 无需排序去重
  │
  ├─→ [终止条件]
  │    └─→ 无显式终止，循环结束即回溯
  │
  └─→ [时间复杂度]
       └─→ O(n × 2^n)
```

> ✅ 每日一练：默写回溯模板 + 解释为什么每次记录 + 说出 3 个子集变种题
> 🚀 你已掌握“组合生成”的完整建模能力，下一题，继续征服！🤗
