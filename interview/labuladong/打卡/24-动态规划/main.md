# 动态规划

首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗

- 虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出正确的「状态转移方程」，才能正确地穷举
- 需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值
- 动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。在实际的算法问题中，写出状态转移方程是最困难的，总结的一个思维框架，辅助思考状态转移方程：

> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义

```python
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

## 斐波那契数列

### 暴力递归

```go
// f(n) 计算第 n 个斐波那契数
func fib(n int) int {
    // base case
    if n == 0 || n == 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}
```

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251204212615019.jpg)

递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间

- 首先计算子问题个数，即递归树中节点的总数。这棵递归树的高度为 n，所以二叉树的节点总数为 2^n
- 然后计算解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)
- 所以算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸

观察递归树，很明显发现了算法低效的原因：存在大量重复计算

#### 备忘录

即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后顺便记到「备忘录」里；每次遇到一个子问题别急着计算，先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了

```go
func fib(n int) int {
    // 备忘录全初始化为 -1
    // 因为斐波那契数肯定是非负整数，所以初始化为特殊值 -1 表示未计算

    // 因为数组的索引从 0 开始，所以需要 n + 1 个空间
    // 这样才能把 `f(0) ~ f(n)` 都记录到 memo 中
    memo := make([]int, n+1)
    for i := range memo {
        memo[i] = -1
    }

    return dp(memo, n)
}

// 带着备忘录进行递归
func dp(memo []int, n int) int {
    // base case
    if n == 0 || n == 1 {
        return n
    }
    // 已经计算过，不用再计算了
    if memo[n] != -1 {
        return memo[n]
    }
    // 在返回结果之前，存入备忘录
    memo[n] = dp(memo, n-1) + dp(memo, n-2)
    return memo[n]
}
```

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251204213107628.jpg)

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数，每个子问题都只会被计算一次

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251204213151494.jpg)

递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间

- 子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(0), f(1), f(2) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)
- 解决一个子问题的时间，同上，没有什么循环，时间为 O(1)
- 所以，本算法的时间复杂度是 O(n)，比起指数级复杂度的暴力算法，已经非常高效了

#### 自顶向下 V.S. 自底向上

动态规划解法确实有两种表现形式：

1. 带备忘录的递归解法，或称为「自顶向下」的解法，一个递归函数带一个 memo 备忘录
1. DP table 的迭代解法，或称为「自底向上」的解法，用 for 循环去迭代 dp 数组进行求解

这两者的本质是一样的，可以互相转化。迭代解法中的那个 dp 数组，就是递归解法中的 memo 数组

- 啥叫「自顶向下」？递归树从上向下生长，从一个规模较大的原问题 f(5)，向下逐渐分解规模，直到 f(0) 和 f(1) 这两个 base case，然后逐层返回答案
- 啥叫「自底向上」？直接从最底下、最简单、问题规模最小、已知结果的 f(0) 和 f(1)（base case）开始往上推出 f(2), f(3)... 最后推出我们想要的 f(5)

其实「自底向上」和「自顶向下」本质是一样的，只是视角不同而已
