# 哈希表

哈希表和我们常说的 Map（键值映射）是不是同一个东西？不是

这一点用 Java 来讲解就很清楚，Map 是一个 Java 接口，仅仅声明了若干个方法，并没有给出方法的具体实现；Map 接口本身只定义了键值映射的一系列操作，HashMap 这种数据结构根据自身特点实现了这些操作。还有其他数据结构也实现了这个接口，比如 TreeMap、LinkedHashMap 等等

其他编程语言可能没有 Java 这么清晰的接口定义，所以很容易让读者把哈希表和 Map 键值对混为一谈，听到键值对操作，就认为其增删查改的复杂度一定是O(1)。这是不对的，具体要看这个底层的数据结构是如何实现键值操作的

哈希表的底层实现就是一个数组（我们不妨称之为 table）。它先把这个 key 通过一个哈希函数（我们不妨称之为 hash）转化成数组里面的索引，然后增删查改操作和数组基本相同

## 哈希函数

哈希表中，不可能出现两个相同的 key，而 value 是可以重复的

哈希函数的作用是把任意长度的输入（key）转化成固定长度的输出（索引）。如果你设计的这个哈希函数复杂度是O(N)，那么哈希表的增删查改性能就会退化成O(N)，所以说这个函数的性能很关键。这个函数还要保证的一点是，输入相同的 key，输出也必须要相同，这样才能保证哈希表的正确性

## 哈希冲突

哈希冲突不可能避免，只能在算法层面妥善处理出现哈希冲突的情况。哈希冲突是一定会出现的，因为这个 hash 函数相当于是把一个无穷大的空间映射到了一个有限的索引空间，所以必然会有不同的 key 映射到同一个索引上

两种常见的解决方法，一种是拉链法，另一种是线性探查法（也经常被叫做开放寻址法）。名字听起来高大上，说白了就是纵向延伸和横向延伸两种思路

## 扩容和负载因子

为什么会频繁出现哈希冲突呢？两个原因：

1. 哈希函数设计的不好，导致 key 的哈希值分布不均匀，很多 key 映射到了同一个索引上。（开发编程语言标准库的大佬们已经帮你设计好了哈希函数，你只要调用就行了）
1. 哈希表里面已经装了太多的 key-value 对了，这种情况下即使哈希函数再完美，也没办法避免哈希冲突。（我们可以控制的，即避免哈希表装太满）

负载因子是一个哈希表装满的程度的度量。一般来说，负载因子越大，说明哈希表里面存储的 key-value 对越多，哈希冲突的概率就越大，哈希表的操作性能就越差

负载因子 = size / table.length（size 是哈希表里面的 key-value 对的数量，table.length 是哈希表底层数组的容量）

用拉链法实现的哈希表，负载因子可以无限大，因为链表可以无限延伸；用线性探查法实现的哈希表，负载因子不会超过 1。像 Java 的 HashMap，允许我们创建哈希表时自定义负载因子，不设置的话默认是 0.75，这个值是经验值，一般保持默认就行了

当哈希表内元素达到负载因子时，哈希表会扩容。和动态数组的实现是类似的，就是把哈希表底层 table 数组的容量扩大，把数据搬移到新的大数组中。size 不变，table.length 增加，负载因子就减小了

## 遍历顺序

哈希表中键的遍历顺序是无序的，不能依赖哈希表的遍历顺序来编写程序

哈希表的遍历本质上就是遍历那个底层 table 数组。由于 hash 函数要把你的 key 进行映射，所以 key 在底层 table 数组中的分布是随机的，不像数组/链表结构那样有个明确的元素顺序。哈希表自动扩缩容后，同一个 key 存储在 table 的索引可能发生变化，所以遍历结果的顺序就和之前不一样了

在 for 循环中增/删哈希表的 key，是很容易出现问题的，原因和上面相同，还是扩缩容导致的哈希值变化

只有那些不可变类型，才能作为哈希表的 key，这一点很重要。因为哈希表的主要操作都依赖于哈希函数计算出来的索引，如果 key 的哈希值会变化，会导致键值对意外丢失，产生严重的 bug

## 哈希集合原理

哈希集合的主要使用场景是「去重」，因为它的特性是：不会出现重复元素，可以在O(1) 的时间增删元素，可以在O(1) 的时间判断一个元素是否存在
