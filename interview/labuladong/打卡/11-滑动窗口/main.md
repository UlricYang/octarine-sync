# 滑动窗口

滑动窗口可以归为快慢双指针，一快一慢两个指针前后相随，中间的部分就是窗口。滑动窗口算法技巧主要用来解决子数组问题，比如让你寻找符合某个条件的最长/最短子数组

## 算法框架

### 基本思路

```c
// 索引区间 [left, right) 是窗口
int left = 0, right = 0;

while (right < nums.size()) {
    // 增大窗口
    window.addLast(nums[right]);
    right++;

    while (window needs shrink) {
        // 缩小窗口
        window.removeFirst(nums[left]);
        left++;
    }
}
```

基于滑动窗口算法框架写出的代码，时间复杂度是O(N)，比嵌套 for 循环的暴力解法效率高

为啥滑动窗口能在O(N) 的时间穷举子数组？
这个问题本身就是错误的，滑动窗口并不能穷举出所有子串。要想穷举出所有子串，必须用那个嵌套 for 循环
然而对于某些题目，并不需要穷举所有子串，就能找到题目想要的答案。滑动窗口就是这种场景下的一套算法模板，帮你对穷举过程进行剪枝优化，避免冗余计算。所以在算法的本质 中我把滑动窗口算法归为「如何聪明地穷举」一类

### 细节模版

```go
// 滑动窗口算法伪码框架
func slidingWindow(s string) {
    // 用合适的数据结构记录窗口中的数据，根据具体场景变通
    // 比如说，我想记录窗口中元素出现的次数，就用 map
    // 如果我想记录窗口中的元素和，就可以只用一个 int
    var window = ...

    left, right := 0, 0
    for right < len(s) {
        // c 是将移入窗口的字符
        c := rune(s[right])
        window[c]++
        // 增大窗口
        right++
        // 进行窗口内数据的一系列更新
        ...

        // * debug 输出的位置 *
        // 注意在最终的解法代码中不要 print
        // 因为 IO 操作很耗时，可能导致超时
        fmt.Println("window: [",left,", ",right,")")
        // *

        // 判断左侧窗口是否要收缩
        for left < right && window needs shrink {
            // d 是将移出窗口的字符
            d := rune(s[left])
            window[d]--
            // 缩小窗口
            left++
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

框架中两处 ... 表示的更新窗口数据的地方，在具体的题目中，你需要做的就是往这里面填代码逻辑
而且这两个 ... 处的操作分别是扩大和缩小窗口的更新操作，等会你会发现它们操作是完全对称的

基于这个框架，遇到子串/子数组相关的题目，你只需要回答以下三个问题（只要能回答这三个问题，就说明可以使用滑动窗口技巧解题）：

1. 什么时候应该移动 right 扩大窗口？窗口加入字符时，应该更新哪些数据？
1. 什么时候窗口应该暂停扩大，开始移动 left 缩小窗口？从窗口移出字符时，应该更新哪些数据？
1. 什么时候应该更新结果？

常见的场景：

- 最小覆盖子串
- 字符串排列
- 找所有字母的异位词
- 最长无重复子串
