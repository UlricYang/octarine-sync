# LeetCode 107 - äºŒå‰æ ‘çš„å±‚åºéå† II

## 1. é¢˜ç›®æè¿°

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼ è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ã€‚ï¼ˆå³æŒ‰ä»å¶å­èŠ‚ç‚¹æ‰€åœ¨å±‚åˆ°æ ¹èŠ‚ç‚¹æ‰€åœ¨çš„å±‚ï¼Œé€å±‚ä»å·¦å‘å³éå†ï¼‰

### ç¤ºä¾‹ 1

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[15,7],[9,20],[3]]
```

### ç¤ºä¾‹ 2

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
```

### ç¤ºä¾‹ 3

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

### çº¦æŸæ¡ä»¶

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-1000 <= Node.val <= 1000`

## 2. è§£æ³•åˆ†æï¼šBFS + ç»“æœåè½¬

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ ç»“æœåè½¬ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. å¤ç”¨å±‚åºéå†é€»è¾‘ - ç›´æ¥åŸºäºLeetCode 102çš„è§£æ³•
1. å®ç°ç®€å•é«˜æ•ˆ - ä»…éœ€åœ¨æœ€ååè½¬ç»“æœ
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - O(n)æ—¶é—´è®¿é—®æ‰€æœ‰èŠ‚ç‚¹
1. ç©ºé—´å¤æ‚åº¦å¯æ§ - O(n)ç©ºé—´å­˜å‚¨ç»“æœ

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆBFS+åè½¬æ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å±‚åºéå†çš„åŸºç¡€ï¼šè‡ªåº•å‘ä¸Šå±‚åºéå†æ˜¯æ­£å¸¸å±‚åºéå†çš„é€†åº
1. å¤ç”¨æ€§å¼ºï¼šç›´æ¥ä½¿ç”¨102é¢˜çš„BFSå®ç°
1. å®ç°ç®€å•ï¼šåªéœ€åœ¨æœ€ååè½¬ç»“æœæ•°ç»„
1. æ€§èƒ½ä¼˜å¼‚ï¼šåè½¬æ“ä½œO(n)æ—¶é—´ï¼Œä¸å½±å“æ•´ä½“å¤æ‚åº¦
1. å¯è¯»æ€§é«˜ï¼šä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•             | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                   |
| ---------------- | -------- | ---------- | ---------- | -------- | ---------------------- |
| BFS+åè½¬ï¼ˆæœ¬è§£ï¼‰ | âœ…       | O(n)       | O(n)       | ä½       | å¤ç”¨æ€§å¼ºï¼Œå®ç°ç®€å•     |
| DFS+å±‚æ•°è®°å½•     | âœ…       | O(n)       | O(n)       | ä¸­       | éœ€è¦é¢å¤–è®°å½•å±‚æ•°       |
| BFS+åŒç«¯é˜Ÿåˆ—     | âœ…       | O(n)       | O(n)       | ä¸­       | ç›´æ¥æ’å…¥å¤´éƒ¨ï¼Œå®ç°å¤æ‚ |
| é€’å½’+åè½¬        | âœ…       | O(n)       | O(n)       | ä¸­       | é€’å½’æ ˆæ·±åº¦å¯èƒ½è¿‡å¤§     |

> BFS+åè½¬æ˜¯æœ€ç›´æ¥ã€æœ€æ˜“äºç†è§£çš„è§£å†³æ–¹æ¡ˆ

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. æ ‘ç»“æ„ï¼šé€‚ç”¨äºä»»ä½•äºŒå‰æ ‘
1. ç©ºæ ‘å¤„ç†ï¼šéœ€ç‰¹æ®Šå¤„ç†rootä¸ºnullçš„æƒ…å†µ
1. èŠ‚ç‚¹å€¼èŒƒå›´ï¼šé¢˜ç›®çº¦æŸå†…æ— å½±å“
1. è‡ªåº•å‘ä¸Šè¦æ±‚ï¼šå¿…é¡»åè½¬ç»“æœæˆ–ä½¿ç”¨åŒç«¯é˜Ÿåˆ—

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. å¤ç”¨æ€§ï¼šç›´æ¥å¤ç”¨102é¢˜çš„BFSå®ç°
1. æ€§èƒ½ï¼šåè½¬æ“ä½œæ—¶é—´å¤æ‚åº¦ä½
1. å¯è¯»æ€§ï¼šä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç»´æŠ¤
1. æ‰©å±•æ€§ï¼šå¯è½»æ¾æ‰©å±•åˆ°å…¶ä»–å˜ä½“

### æ€»ç»“

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ ç»“æœåè½¬æ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€å®ç°ç®€æ´æ€§å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶å±•ç¤ºä¸åŒè¯­è¨€åœ¨åè½¬æ“ä½œå’Œé˜Ÿåˆ—å®ç°ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrderBottom(root *TreeNode) [][]int {
    // å¤„ç†ç©ºæ ‘æƒ…å†µ
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}          // å­˜å‚¨æ­£å¸¸å±‚åºéå†ç»“æœ
    queue := []*TreeNode{root}   // é˜Ÿåˆ—åˆå§‹åŒ–ï¼Œå­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹

    // æ­£å¸¸å±‚åºéå†
    for len(queue) > 0 {
        levelSize := len(queue)  // å½“å‰å±‚èŠ‚ç‚¹æ•°
        currentLevel := []int{}  // å­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹å€¼

        // éå†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < levelSize; i++ {
            node := queue[0]     // å–é˜Ÿé¦–èŠ‚ç‚¹
            queue = queue[1:]    // å‡ºé˜Ÿ
            currentLevel = append(currentLevel, node.Val) // è®°å½•èŠ‚ç‚¹å€¼

            // å°†å­èŠ‚ç‚¹å…¥é˜Ÿ
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        // å°†å½“å‰å±‚ç»“æœåŠ å…¥ç»“æœé›†
        result = append(result, currentLevel)
    }

    // åè½¬ç»“æœï¼Œå®ç°è‡ªåº•å‘ä¸Š
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }

    return result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if root == nil` - ç©ºæ ‘ç›´æ¥è¿”å›ç©ºç»“æœ
1. æ­£å¸¸å±‚åºéå†ï¼šä¸102é¢˜å®Œå…¨ä¸€è‡´çš„BFSå®ç°
1. ç»“æœå­˜å‚¨ï¼š`result` - å­˜å‚¨æ­£å¸¸å±‚åºéå†ç»“æœ
1. åè½¬æ“ä½œï¼šåŒæŒ‡é’ˆäº¤æ¢é¦–å°¾å…ƒç´ 
   - `i`ä»å¤´å¼€å§‹ï¼Œ`j`ä»å°¾å¼€å§‹
   - äº¤æ¢`result[i]`å’Œ`result[j]`
   - ç›´åˆ°`i >= j`ç»“æŸ
1. æ—¶é—´å¤æ‚åº¦ï¼šO(n)éå† + O(n)åè½¬ = O(n)
1. ç©ºé—´å¤æ‚åº¦ï¼šO(n)å­˜å‚¨ç»“æœ

è®¾è®¡åŠ¨æœºï¼š

- å¤ç”¨102é¢˜çš„æˆç†Ÿå®ç°
- åè½¬æ“ä½œç®€å•é«˜æ•ˆ
- ä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç†è§£

### B. Go ğŸ¹ å®ç°ï¼ˆåŒç«¯é˜Ÿåˆ—ç‰ˆï¼‰

```go
func levelOrderBottom(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            currentLevel = append(currentLevel, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        // ä½¿ç”¨åŒç«¯é˜Ÿåˆ—æ•ˆæœï¼šåœ¨å¤´éƒ¨æ’å…¥å½“å‰å±‚
        result = append([][]int{currentLevel}, result...)
    }

    return result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. åŒç«¯é˜Ÿåˆ—æ•ˆæœï¼šé€šè¿‡`append([][]int{currentLevel}, result...)`å®ç°å¤´éƒ¨æ’å…¥
1. ä¼˜ç‚¹ï¼šé¿å…äº†é¢å¤–çš„åè½¬æ“ä½œ
1. ç¼ºç‚¹ï¼šæ¯æ¬¡å¤´éƒ¨æ’å…¥éœ€è¦å¤åˆ¶æ•´ä¸ªåˆ‡ç‰‡ï¼Œæ—¶é—´å¤æ‚åº¦O(nÂ²)
1. é€‚ç”¨åœºæ™¯ï¼šå½“ç»“æœé›†è¾ƒå°æ—¶å¯ç”¨ï¼Œå¤§è§„æ¨¡æ•°æ®æ—¶ä¸æ¨è

### C. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            level_size = len(queue)
            current_level = []

            for _ in range(level_size):
                node = queue.popleft()
                current_level.append(node.val)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(current_level)

        # åè½¬ç»“æœ
        return result[::-1]
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if not root` - Pythoné£æ ¼çš„ç©ºæ£€æŸ¥
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`deque` - é«˜æ•ˆå‡ºé˜Ÿå…¥é˜Ÿ
1. åè½¬æ“ä½œï¼š`result[::-1]` - Pythonåˆ‡ç‰‡åè½¬
1. Pythonç‰¹æ€§ï¼š
   - åˆ‡ç‰‡æ“ä½œç®€æ´é«˜æ•ˆ
   - åˆ—è¡¨åè½¬æ—¶é—´å¤æ‚åº¦O(n)
   - ä»£ç ç®€æ´æ˜“è¯»

### D. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.right = (right===undefined ? null : right)
 *         this.left = (left===undefined ? null : left)
 *     }
 * }
 */

function levelOrderBottom(root: TreeNode | null): number[][] {
    if (!root) {
        return [];
    }

    const result: number[][] = [];
    const queue: TreeNode[] = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel: number[] = [];

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift()!;
            currentLevel.push(node.val);

            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }

        result.push(currentLevel);
    }

    // åè½¬ç»“æœ
    return result.reverse();
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if (!root)` - TypeScripté£æ ¼çš„ç©ºæ£€æŸ¥
1. ç±»å‹å®šä¹‰ï¼š`number[][]` - æ˜ç¡®ç»“æœç±»å‹
1. åè½¬æ“ä½œï¼š`result.reverse()` - æ•°ç»„åŸåœ°åè½¬
1. TypeScriptç‰¹æ€§ï¼š
   - ç±»å‹æ³¨è§£å¢å¼ºä»£ç å®‰å…¨æ€§
   - éç©ºæ–­è¨€ç¡®ä¿ç±»å‹æ­£ç¡®
   - æ•°ç»„æ“ä½œä¸JavaScriptä¸€è‡´

æ³¨æ„ï¼šTypeScriptçš„`shift()`æ“ä½œæ˜¯O(n)æ—¶é—´ï¼Œåœ¨å¤§è§„æ¨¡æ•°æ®æ—¶æ€§èƒ½è¾ƒå·®

### E. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::VecDeque;

impl Solution {
    pub fn level_order_bottom(root: Option<Box<TreeNode>>) -> Vec<Vec<i32>> {
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        // å¤„ç†æ ¹èŠ‚ç‚¹
        if let Some(node) = root {
            queue.push_back(node);
        }

        while !queue.is_empty() {
            let level_size = queue.len();
            let mut current_level = Vec::with_capacity(level_size);

            for _ in 0..level_size {
                if let Some(node) = queue.pop_front() {
                    current_level.push(node.val);

                    // å­èŠ‚ç‚¹å…¥é˜Ÿ
                    if let Some(left) = node.left {
                        queue.push_back(left);
                    }
                    if let Some(right) = node.right {
                        queue.push_back(right);
                    }
                }
            }

            result.push(current_level);
        }

        // åè½¬ç»“æœ
        result.reverse();
        result
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if let Some(node) = root` - Rustçš„Optionæ¨¡å¼åŒ¹é…
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`VecDeque` - é«˜æ•ˆåŒç«¯é˜Ÿåˆ—
1. å†…å­˜é¢„åˆ†é…ï¼š`Vec::with_capacity(level_size)` - æé«˜æ€§èƒ½
1. åè½¬æ“ä½œï¼š`result.reverse()` - åŸåœ°åè½¬
1. Rustç‰¹æ€§ï¼š
   - æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨
   - æ¨¡å¼åŒ¹é…ç¡®ä¿ä»£ç å®‰å…¨
   - é«˜æ•ˆçš„å†…å­˜ç®¡ç†

### F. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€         | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | åè½¬å®ç°   | ç‰¹ç‚¹                    |
| ------------ | ---------- | ---------- | ---------- | ----------------------- |
| Go(åŸºç¡€)     | O(n)       | O(n)       | åŒæŒ‡é’ˆäº¤æ¢ | ç®€å•é«˜æ•ˆï¼Œé¢è¯•é¦–é€‰      |
| Go(åŒç«¯é˜Ÿåˆ—) | O(nÂ²)      | O(n)       | å¤´éƒ¨æ’å…¥   | é¿å…åè½¬ï¼Œä½†æ€§èƒ½å·®      |
| Python       | O(n)       | O(n)       | åˆ‡ç‰‡åè½¬   | ç®€æ´é«˜æ•ˆ                |
| TypeScript   | O(n)       | O(n)       | reverse()  | ç±»å‹å®‰å…¨ï¼Œshift()æ€§èƒ½å·® |
| Rust         | O(n)       | O(n)       | reverse()  | å†…å­˜å®‰å…¨ï¼Œæ€§èƒ½æœ€ä¼˜      |

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```text
å‡½æ•° levelOrderBottom(root):
    å¦‚æœ root ä¸ºç©º:
        è¿”å› ç©ºåˆ—è¡¨

    result = ç©ºåˆ—è¡¨
    queue = é˜Ÿåˆ—([root])

    å½“ queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = ç©ºåˆ—è¡¨

        å¯¹äº i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ
            currentLevel æ·»åŠ  node.val

            å¦‚æœ node.left ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.left
            å¦‚æœ node.right ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.right

        result æ·»åŠ  currentLevel

    åè½¬ result
    è¿”å› result
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: levelOrderBottom(root)] --> B{root ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› ç©ºåˆ—è¡¨]
    B -- å¦ --> D[åˆå§‹åŒ– result å’Œ queue]
    D --> E[queue å…¥é˜Ÿ root]
    E --> F{queue ä¸ºç©º?}
    F -- æ˜¯ --> G[åè½¬ result]
    F -- å¦ --> H[levelSize = queue é•¿åº¦]
    H --> I[åˆå§‹åŒ– currentLevel]
    I --> J[i = 0]
    J --> K{i < levelSize?}
    K -- æ˜¯ --> L[node = queue å‡ºé˜Ÿ]
    L --> M[currentLevel æ·»åŠ  node.val]
    M --> N{node.left éç©º?}
    N -- æ˜¯ --> O[queue å…¥é˜Ÿ node.left]
    N -- å¦ --> P{node.right éç©º?}
    P -- æ˜¯ --> Q[queue å…¥é˜Ÿ node.right]
    P -- å¦ --> R[i = i + 1]
    R --> K
    K -- å¦ --> S[result æ·»åŠ  currentLevel]
    S --> F
    G --> T[è¿”å› result]
```

### çŠ¶æ€è½¬ç§»å›¾ï¼ˆç¤ºä¾‹ï¼‰

```mermaid
graph LR
    subgraph "æ‰§è¡Œè¿‡ç¨‹: root = [3,9,20,null,null,15,7]"
        direction TB
        S1["æ­£å¸¸å±‚åºéå†"] --> S1a["result = [[3],[9,20],[15,7]]"]
        S1a --> S2["åè½¬ç»“æœ"]
        S2 --> S2a["result = [[15,7],[9,20],[3]]"]
        S2a --> S3["è¿”å›ç»“æœ"]
    end

    %% æ ·å¼è®¾ç½®
    style S1 fill:#e6f3ff,stroke:#333
    style S2 fill:#e6f3ff,stroke:#333
    style S3 fill:#6f9,stroke:#333
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: root = [3,9,20,null,null,15,7]

#### æ­£å¸¸å±‚åºéå†è¿‡ç¨‹

| å±‚æ•° | queueçŠ¶æ€ | å¤„ç†èŠ‚ç‚¹ | currentLevel | å­èŠ‚ç‚¹å…¥é˜Ÿ | è¯´æ˜                    |
| ---- | --------- | -------- | ------------ | ---------- | ----------------------- |
| 1    | [3]       | 3        | [3]          | 9,20       | æ ¹èŠ‚ç‚¹3ï¼Œå…¥é˜Ÿå­èŠ‚ç‚¹9,20 |
| 2    | [9,20]    | 9        | [9]          | -          | 9æ— å­èŠ‚ç‚¹               |
| 2    | [20]      | 20       | [9,20]       | 15,7       | 20å…¥é˜Ÿå­èŠ‚ç‚¹15,7        |
| 3    | [15,7]    | 15       | [15]         | -          | 15æ— å­èŠ‚ç‚¹              |
| 3    | [7]       | 7        | [15,7]       | -          | 7æ— å­èŠ‚ç‚¹               |

æ­£å¸¸å±‚åºç»“æœï¼š`[[3],[9,20],[15,7]]`

#### åè½¬è¿‡ç¨‹

1. åŸå§‹ç»“æœï¼š`[[3],[9,20],[15,7]]`
1. åè½¬åï¼š`[[15,7],[9,20],[3]]`

#### æœ€ç»ˆç»“æœ

```text
[
    [15,7],
    [9,20],
    [3]
]
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrderBottom(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            currentLevel = append(currentLevel, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, currentLevel)
    }

    // åè½¬ç»“æœ
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }

    return result
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®å±‚åºæ•°ç»„æ„å»ºäºŒå‰æ ‘
func buildTree(nums []interface{}) *TreeNode {
    if len(nums) == 0 || nums[0] == nil {
        return nil
    }

    root := &TreeNode{Val: nums[0].(int)}
    queue := []*TreeNode{root}
    i := 1

    for len(queue) > 0 && i < len(nums) {
        node := queue[0]
        queue = queue[1:]

        if i < len(nums) && nums[i] != nil {
            node.Left = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Left)
        }
        i++

        if i < len(nums) && nums[i] != nil {
            node.Right = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Right)
        }
        i++
    }

    return root
}

func main() {
    // Test Case 1
    nums1 := []interface{}{3, 9, 20, nil, nil, 15, 7}
    tree1 := buildTree(nums1)
    fmt.Printf("Test Case 1: %v\n", levelOrderBottom(tree1)) // [[15,7],[9,20],[3]]

    // Test Case 2
    nums2 := []interface{}{1}
    tree2 := buildTree(nums2)
    fmt.Printf("Test Case 2: %v\n", levelOrderBottom(tree2)) // [[1]]

    // Test Case 3
    nums3 := []interface{}{}
    tree3 := buildTree(nums3)
    fmt.Printf("Test Case 3: %v\n", levelOrderBottom(tree3)) // []
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

æœ¬ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦

- å±‚åºéå†ï¼šO(n) - æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡
- åè½¬æ“ä½œï¼šO(n) - åè½¬ç»“æœæ•°ç»„
- æ€»æ—¶é—´ï¼šO(n) + O(n) = O(n)

#### B. ç©ºé—´å¤æ‚åº¦

- ç»“æœå­˜å‚¨ï¼šO(n) - å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹å€¼
- é˜Ÿåˆ—å­˜å‚¨ï¼šO(n) - æœ€åæƒ…å†µä¸‹å­˜å‚¨æœ€åä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹
- æ€»ç©ºé—´ï¼šO(n) + O(n) = O(n)

#### C. æœ€å¥½/å¹³å‡/æœ€åæƒ…å†µåˆ†æ

| æƒ…å†µ           | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                            |
| -------------- | ---------- | ---------- | ------------------------------- |
| æœ€å¥½ï¼ˆå¹³è¡¡æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸ºn/2               |
| å¹³å‡           | O(n)       | O(n)       | å…¸å‹äºŒå‰æ ‘                      |
| æœ€åï¼ˆé€€åŒ–æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸º1ï¼ˆæ¯å±‚ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ |

#### D. å¸¸æ•°å› å­åˆ†æ

- å±‚åºéå†å¼€é”€ï¼šé˜Ÿåˆ—æ“ä½œçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- åè½¬æ“ä½œå¼€é”€ï¼šæ•°ç»„å…ƒç´ äº¤æ¢
- è¯­è¨€ç‰¹æ€§å½±å“ï¼š
  - Goåˆ‡ç‰‡æ“ä½œé«˜æ•ˆ
  - Pythonåˆ‡ç‰‡åè½¬é«˜æ•ˆ
  - TypeScriptæ•°ç»„åè½¬é«˜æ•ˆ
  - Rust Vecåè½¬é«˜æ•ˆ

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆï¼šåè½¬æ“ä½œçš„é¢å¤–æ—¶é—´å’Œç©ºé—´
- ä¼˜åŒ–æ–¹å‘ï¼š
  - ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ç›´æ¥åœ¨å¤´éƒ¨æ’å…¥ï¼ˆå°è§„æ¨¡æ•°æ®ï¼‰
  - é¢„åˆ†é…å†…å­˜ç©ºé—´ï¼ˆå¦‚Rustå®ç°ï¼‰
  - ä½¿ç”¨é“¾è¡¨å­˜å‚¨ç»“æœï¼Œé¿å…åè½¬

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"å±‚çº§éå†å˜ä½“"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. å¤ç”¨å±‚åºéå†é€»è¾‘
1. ç»“æœåå¤„ç†æŠ€å·§
1. åè½¬æ“ä½œçš„åº”ç”¨
1. å¯æ‰©å±•åˆ°å¤šç§å±‚çº§ç»“æ„

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- å±‚åºéå†çš„é€†åºï¼šè‡ªåº•å‘ä¸Šå±‚åºéå† = æ­£å¸¸å±‚åºéå†çš„é€†åº
- ç»“æœåå¤„ç†ï¼šé€šè¿‡åè½¬æˆ–åŒç«¯é˜Ÿåˆ—å®ç°é€†åº
- å¤ç”¨æ€§ï¼šç›´æ¥åŸºäº102é¢˜çš„å®ç°
- æ‰©å±•æ€§ï¼šå¯åº”ç”¨äºå…¶ä»–éœ€è¦é€†åºçš„åœºæ™¯

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®                   | æ ¸å¿ƒæ€æƒ³               | åŒ¹é…æ¨¡å¼ |
| ---- | ---------------------- | ---------------------- | -------- |
| 107  | æœ¬é¢˜                   | è‡ªåº•å‘ä¸Šå±‚åºéå†       | æ ¸å¿ƒæ¨¡å¼ |
| 102  | äºŒå‰æ ‘çš„å±‚åºéå†       | æ­£å¸¸å±‚åºéå†           | åŸºç¡€æ¨¡å¼ |
| 429  | Nå‰æ ‘çš„å±‚åºéå†        | Nå‰æ ‘å±‚åºéå†          | æ¨¡å¼æ‰©å±• |
| 103  | äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå† | äº¤æ›¿æ–¹å‘å±‚åºéå†       | æ¨¡å¼å˜ä½“ |
| 199  | äºŒå‰æ ‘çš„å³è§†å›¾         | å±‚åºéå†å–æ¯å±‚æœ€åä¸€ä¸ª | æ¨¡å¼åº”ç”¨ |

#### C. æ¨¡å¼æ³›åŒ–

- é€†åºå¤„ç†ï¼šä»»ä½•éœ€è¦é€†åºçš„å±‚çº§éå†
- å¤šå‰æ ‘ï¼šNå‰æ ‘çš„è‡ªåº•å‘ä¸Šéå†
- å›¾éå†ï¼šå›¾çš„å±‚çº§é€†åºéå†
- ç»„ç»‡ç»“æ„ï¼šè‡ªåº•å‘ä¸Šå±•ç¤ºå…¬å¸ç»“æ„
- æ–‡ä»¶ç³»ç»Ÿï¼šè‡ªåº•å‘ä¸Šå±•ç¤ºç›®å½•ç»“æ„

#### D. å·¥ä¸šåº”ç”¨

- ç»„ç»‡ç»“æ„å›¾ï¼šè‡ªåº•å‘ä¸Šå±•ç¤ºå‘˜å·¥-ç»ç†å…³ç³»
- æ–‡ä»¶ç³»ç»Ÿï¼šè‡ªåº•å‘ä¸Šå±•ç¤ºç›®å½•æ ‘
- ç½‘ç»œè·¯ç”±ï¼šæŒ‰è·³æ•°é€†åºå±•ç¤ºè·¯ç”±è·¯å¾„
- æ¸¸æˆAIï¼šæŒ‰è·ç¦»é€†åºæœç´¢ç›®æ ‡
- æ•°æ®åº“ç´¢å¼•ï¼šBæ ‘çš„é€†åºå±‚çº§éå†

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆé€‰æ‹©åè½¬è€Œä¸æ˜¯ç›´æ¥é€†åºæ’å…¥ï¼Ÿ
   - åè½¬æ“ä½œç®€å•ï¼Œæ—¶é—´å¤æ‚åº¦ä½
   - ç›´æ¥é€†åºæ’å…¥éœ€è¦O(nÂ²)æ—¶é—´ï¼ˆæ¯æ¬¡å¤´éƒ¨æ’å…¥ï¼‰
   - åè½¬æ“ä½œæ›´ç¬¦åˆå·¥ç¨‹å®è·µ

1. æœ‰æ²¡æœ‰O(1)ç©ºé—´çš„è§£æ³•ï¼Ÿ
   - ç†è®ºä¸Šå¯ä»¥ä½¿ç”¨DFS+å±‚æ•°è®°å½•ï¼Œä½†éœ€è¦é¢å¤–ç©ºé—´å­˜å‚¨å±‚æ•°
   - æ— æ³•å®ç°çœŸæ­£çš„O(1)ç©ºé—´è§£æ³•ï¼Œå› ä¸ºç»“æœæœ¬èº«éœ€è¦O(n)ç©ºé—´

1. åè½¬æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ
   - æ•°ç»„åè½¬ï¼šO(n)æ—¶é—´ï¼ŒO(1)é¢å¤–ç©ºé—´ï¼ˆåŸåœ°äº¤æ¢ï¼‰
   - é“¾è¡¨åè½¬ï¼šO(n)æ—¶é—´ï¼ŒO(1)é¢å¤–ç©ºé—´
   - åŒç«¯é˜Ÿåˆ—å¤´éƒ¨æ’å…¥ï¼šO(nÂ²)æ—¶é—´ï¼ŒO(n)ç©ºé—´

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿï¼š

1. å¯¹å±‚åºéå†å’Œé€†åºå¤„ç†çš„ç†è§£
1. å¤æ‚åº¦åˆ†æä¸ä¼˜åŒ–èƒ½åŠ›
1. ä»åŸºç¡€åˆ°å˜ä½“çš„æ‰©å±•èƒ½åŠ›
1. ä¸åŒå®ç°æ–¹å¼çš„æƒè¡¡

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆé€‰æ‹©BFS+åè½¬è€Œä¸æ˜¯ç›´æ¥é€†åºæ’å…¥ï¼Ÿ

â†’ æ ‡å‡†: BFS+åè½¬å®ç°ç®€å•ï¼Œæ—¶é—´å¤æ‚åº¦ä½
â†’ åŠ åˆ†: ç›´æ¥é€†åºæ’å…¥éœ€è¦O(nÂ²)æ—¶é—´ï¼Œä¸é€‚åˆå¤§è§„æ¨¡æ•°æ®

#### Q2: å¦‚ä½•å¤„ç†ç©ºæ ‘çš„æƒ…å†µï¼Ÿ

â†’ æ ‡å‡†: åœ¨å‡½æ•°å¼€å§‹æ—¶æ£€æŸ¥rootæ˜¯å¦ä¸ºnull
â†’ åŠ åˆ†: æä¾›å…·ä½“ä»£ç å®ç°ï¼Œå±•ç¤ºè¾¹ç•Œå¤„ç†

#### Q3: åè½¬æ“ä½œçš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘ï¼Ÿ

â†’ æ ‡å‡†: O(n)æ—¶é—´ï¼Œnä¸ºç»“æœæ•°ç»„é•¿åº¦
â†’ åŠ åˆ†: è¯´æ˜åè½¬æ“ä½œä¸å½±å“æ•´ä½“O(n)å¤æ‚åº¦

#### Q4: è¿™ä¸ªç®—æ³•å’Œ102é¢˜æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

â†’ æ ‡å‡†: 102é¢˜æ˜¯æ­£å¸¸å±‚åºéå†ï¼Œæœ¬é¢˜æ˜¯è‡ªåº•å‘ä¸Šå±‚åºéå†
â†’ åŠ åˆ†: æœ¬é¢˜åœ¨102é¢˜åŸºç¡€ä¸Šå¢åŠ äº†åè½¬æ“ä½œ

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°O(1)ç©ºé—´çš„è‡ªåº•å‘ä¸Šå±‚åºéå†ï¼Ÿ

â†’ æ ‡å‡†: ç†è®ºä¸Šæ— æ³•å®ç°ï¼Œå› ä¸ºç»“æœæœ¬èº«éœ€è¦O(n)ç©ºé—´
â†’ åŠ åˆ†: å¯ä»¥ä½¿ç”¨DFS+å±‚æ•°è®°å½•ï¼Œä½†éœ€è¦é¢å¤–ç©ºé—´å­˜å‚¨å±‚æ•°

```go
// DFSå®ç°ï¼ˆéO(1)ç©ºé—´ï¼‰
func levelOrderBottomDFS(root *TreeNode) [][]int {
    result := [][]int{}
    var dfs func(*TreeNode, int)
    dfs = func(node *TreeNode, level int) {
        if node == nil {
            return
        }

        // ç¡®ä¿resultæœ‰è¶³å¤Ÿçš„å±‚
        if level >= len(result) {
            result = append([][]int{{}}, result...)
        }

        // åœ¨å¯¹åº”å±‚æ·»åŠ èŠ‚ç‚¹å€¼
        result[len(result)-1-level] = append(result[len(result)-1-level], node.Val)

        // é€’å½’å¤„ç†å­èŠ‚ç‚¹
        dfs(node.Left, level+1)
        dfs(node.Right, level+1)
    }

    dfs(root, 0)
    return result
}
```

#### Q2: å¦‚ä½•å®ç°Nå‰æ ‘çš„è‡ªåº•å‘ä¸Šå±‚åºéå†ï¼Ÿ

â†’ æ ‡å‡†: å¤ç”¨Nå‰æ ‘å±‚åºéå†é€»è¾‘ï¼Œæœ€ååè½¬ç»“æœ
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// Nå‰æ ‘èŠ‚ç‚¹å®šä¹‰
type Node struct {
    Val int
    Children []*Node
}

func levelOrderBottomN(root *Node) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*Node{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            currentLevel = append(currentLevel, node.Val)

            // éå†æ‰€æœ‰å­èŠ‚ç‚¹
            for _, child := range node.Children {
                queue = append(queue, child)
            }
        }

        result = append(result, currentLevel)
    }

    // åè½¬ç»“æœ
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }

    return result
}
```

#### Q3: å¦‚ä½•ä¼˜åŒ–TypeScriptçš„å®ç°ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–åçš„ä»£ç 

```typescript
// ä¼˜åŒ–ç‰ˆï¼šä½¿ç”¨ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
function levelOrderBottomOptimized(root: TreeNode | null): number[][] {
  if (!root) return [];

  const result: number[][] = [];
  let currentLevelNodes: TreeNode[] = [root];

  while (currentLevelNodes.length > 0) {
    const currentLevel: number[] = [];
    const nextLevelNodes: TreeNode[] = [];

    for (const node of currentLevelNodes) {
      currentLevel.push(node.val);
      if (node.left) nextLevelNodes.push(node.left);
      if (node.right) nextLevelNodes.push(node.right);
    }

    // åœ¨å¤´éƒ¨æ’å…¥å½“å‰å±‚
    result.unshift(currentLevel);
    currentLevelNodes = nextLevelNodes;
  }

  return result;
}
```

#### Q4: å¦‚ä½•å®ç°äºŒå‰æ ‘çš„å·¦è§†å›¾ï¼Ÿ

â†’ æ ‡å‡†: å±‚åºéå†å–æ¯å±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
func leftSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            // å½“å‰å±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            if i == 0 {
                result = append(result, node.Val)
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }

    return result
}
```

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®ï¼š

1. å¤ç”¨å±‚åºéå†é€»è¾‘
1. ç»“æœåè½¬æŠ€å·§
1. è‡ªåº•å‘ä¸Šçš„å®ç°æ–¹å¼
1. å¤šç§å®ç°æ–¹æ¡ˆçš„æƒè¡¡

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹       | å£è¯€                       |
| ------------ | -------------------------- |
| è‡ªåº•å‘ä¸Šæ ¸å¿ƒ | æ­£å¸¸å±‚åºéå† + ç»“æœåè½¬    |
| åè½¬å®ç°     | åŒæŒ‡é’ˆäº¤æ¢é¦–å°¾å…ƒç´          |
| å¤ç”¨æ€§       | ç›´æ¥åŸºäº102é¢˜çš„å®ç°        |
| ç©ºæ ‘å¤„ç†     | å…ˆæ£€æŸ¥rootä¸ºç©º             |
| æ—¶é—´å¤æ‚åº¦   | O(n)éå† + O(n)åè½¬ = O(n) |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹     | è§¦å‘åœºæ™¯             | åº”å¯¹æªæ–½                   |
| ------------ | -------------------- | -------------------------- |
| å¿˜è®°åè½¬     | ç›´æ¥è¿”å›æ­£å¸¸å±‚åºç»“æœ | ç¡®ä¿æœ€åæœ‰åè½¬æ“ä½œ         |
| åè½¬æ—¶æœºé”™è¯¯ | åœ¨éå†è¿‡ç¨‹ä¸­åè½¬     | åœ¨éå†å®Œæˆååè½¬           |
| ç©ºæ ‘æœªå¤„ç†   | rootä¸ºnullæ—¶å´©æºƒ     | å‡½æ•°å¼€å§‹æ£€æŸ¥rootä¸ºç©º       |
| é˜Ÿåˆ—æ“ä½œé”™è¯¯ | åˆ‡ç‰‡è¶Šç•Œæˆ–å†…å­˜æ³„æ¼   | ç¡®ä¿å‡ºé˜Ÿå…¥é˜Ÿæ“ä½œæ­£ç¡®       |
| ç»“æœä¿å­˜æ—¶æœº | ä¿å­˜ä¸å®Œæ•´çš„å±‚       | æ¯å±‚ç»“æŸæ—¶ä¿å­˜currentLevel |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯              | åº”ç”¨åœºæ™¯            |
| ------------------- | ------------------- |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ | æè¿°ç®—æ³•é€‰æ‹©        |
| ç»“æœåè½¬            | è¯´æ˜è‡ªåº•å‘ä¸Šå®ç°    |
| å¤ç”¨æ€§              | å¼ºè°ƒåŸºäº102é¢˜çš„å®ç° |
| æ—¶é—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ          |
| ç©ºé—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ          |
| å±‚åºéå†å˜ä½“        | å‘½åç®—æ³•èŒƒå¼        |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: å±‚çº§éå†å˜ä½“ï¼ˆè‡ªåº•å‘ä¸Šï¼‰
â”œâ”€â”€ å¿…è¦æ¡ä»¶: æ­£å¸¸å±‚åºéå† + ç»“æœåå¤„ç†
â”œâ”€â”€ æœ¬è´¨: å±‚åºéå†çš„é€†åº
â”œâ”€â”€ æ–¹æ³•: BFS + åè½¬
â”‚   â”œâ”€â”€ æ­£å¸¸å±‚åºéå†: ä¸102é¢˜ä¸€è‡´
â”‚   â”œâ”€â”€ ç»“æœå­˜å‚¨: ä¿å­˜æ¯å±‚ç»“æœ
â”‚   â””â”€â”€ ç»“æœåè½¬: åŒæŒ‡é’ˆäº¤æ¢æˆ–reverse()
â”œâ”€â”€ ä¼˜åŒ–: åŒç«¯é˜Ÿåˆ—å¤´éƒ¨æ’å…¥ï¼ˆå°è§„æ¨¡æ•°æ®ï¼‰
â”œâ”€â”€ å˜ä½“: DFS+å±‚æ•°è®°å½•ã€Nå‰æ ‘
â””â”€â”€ åº”ç”¨: ç»„ç»‡ç»“æ„ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œè·¯ç”±
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆï¼ˆBFS+åè½¬ï¼‰
å‡½æ•° levelOrderBottom(root):
    if root ä¸ºç©º: return []
    result = []
    queue = [root]

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = []

        for i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ
            currentLevel æ·»åŠ  node.val
            if node.left éç©º: queue å…¥é˜Ÿ node.left
            if node.right éç©º: queue å…¥é˜Ÿ node.right

        result æ·»åŠ  currentLevel

    åè½¬ result
    return result

// ä¼˜åŒ–ç‰ˆï¼ˆåŒç«¯é˜Ÿåˆ—å¤´éƒ¨æ’å…¥ï¼‰
å‡½æ•° levelOrderBottomOptimized(root):
    if root ä¸ºç©º: return []
    result = []
    queue = [root]

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = []

        for i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ
            currentLevel æ·»åŠ  node.val
            if node.left éç©º: queue å…¥é˜Ÿ node.left
            if node.right éç©º: queue å…¥é˜Ÿ node.right

        result åœ¨å¤´éƒ¨æ’å…¥ currentLevel

    return result
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³è‡ªåº•å‘ä¸Šå±‚åºéå†ç›¸å…³é—®é¢˜ï¼Œå¹¶å±•ç°å¯¹æ ‘ç»“æ„éå†ç®—æ³•çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
