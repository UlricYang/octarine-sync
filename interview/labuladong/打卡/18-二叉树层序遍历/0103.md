# LeetCode 103 - äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

## 1. é¢˜ç›®æè¿°

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ é”¯é½¿å½¢å±‚åºéå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰

### ç¤ºä¾‹ 1

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[20,9],[15,7]]
```

### ç¤ºä¾‹ 2

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
```

### ç¤ºä¾‹ 3

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

### çº¦æŸæ¡ä»¶

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-100 <= Node.val <= 100`

## 2. è§£æ³•åˆ†æï¼šBFS + å±‚æ–¹å‘æ§åˆ¶

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ å±‚æ–¹å‘æ§åˆ¶ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. è‡ªç„¶åŒ¹é…å±‚åºéå† - BFSå¤©ç„¶æŒ‰å±‚è®¿é—®èŠ‚ç‚¹
1. æ–¹å‘æ§åˆ¶ç®€å• - é€šè¿‡æ ‡å¿—ä½æ§åˆ¶æ¯å±‚æ–¹å‘
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - O(n)æ—¶é—´è®¿é—®æ‰€æœ‰èŠ‚ç‚¹
1. ç©ºé—´å¤æ‚åº¦å¯æ§ - O(n)ç©ºé—´å­˜å‚¨ç»“æœ
1. å®ç°æ¸…æ™°ç›´è§‚ - ä»£ç é€»è¾‘æ˜“äºç†è§£

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆBFS+æ–¹å‘æ§åˆ¶æ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å±‚åºéå†çš„åŸºç¡€ï¼šé”¯é½¿å½¢å±‚åºéå†æ˜¯æ­£å¸¸å±‚åºéå†çš„å˜ä½“
1. BFSçš„ç‰¹æ€§ï¼šæŒ‰å±‚è®¿é—®èŠ‚ç‚¹ï¼Œä¸é¢˜ç›®è¦æ±‚å®Œå…¨åŒ¹é…
1. æ–¹å‘æ§åˆ¶ï¼šé€šè¿‡å¸ƒå°”æ ‡å¿—ä½æ§åˆ¶æ¯å±‚æ–¹å‘
1. å¤ç”¨æ€§å¼ºï¼šåŸºäº102é¢˜çš„BFSå®ç°
1. æ€§èƒ½ä¼˜å¼‚ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡ï¼Œæ— é‡å¤è®¡ç®—

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•                 | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                   |
| -------------------- | -------- | ---------- | ---------- | -------- | ---------------------- |
| BFS+æ–¹å‘æ§åˆ¶ï¼ˆæœ¬è§£ï¼‰ | âœ…       | O(n)       | O(n)       | ä½       | é¢è¯•é¦–é€‰ï¼Œå®ç°ç®€å•     |
| DFS+å±‚æ•°è®°å½•         | âœ…       | O(n)       | O(n)       | ä¸­       | éœ€è¦é¢å¤–è®°å½•å±‚æ•°å’Œæ–¹å‘ |
| åŒæ ˆæ³•               | âœ…       | O(n)       | O(n)       | ä¸­       | ä½¿ç”¨ä¸¤ä¸ªæ ˆäº¤æ›¿å­˜å‚¨     |
| é€’å½’+åè½¬            | âœ…       | O(n)       | O(n)       | ä¸­       | é€’å½’æ ˆæ·±åº¦å¯èƒ½è¿‡å¤§     |

> BFS+æ–¹å‘æ§åˆ¶æ˜¯æœ€ç›´æ¥ã€æœ€æ˜“äºç†è§£çš„è§£å†³æ–¹æ¡ˆ

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. æ ‘ç»“æ„ï¼šé€‚ç”¨äºä»»ä½•äºŒå‰æ ‘
1. ç©ºæ ‘å¤„ç†ï¼šéœ€ç‰¹æ®Šå¤„ç†rootä¸ºnullçš„æƒ…å†µ
1. èŠ‚ç‚¹å€¼èŒƒå›´ï¼šé¢˜ç›®çº¦æŸå†…æ— å½±å“
1. æ–¹å‘äº¤æ›¿ï¼šå¿…é¡»æŒ‰å±‚äº¤æ›¿æ–¹å‘

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. å¤ç”¨æ€§ï¼šåŸºäº102é¢˜çš„BFSå®ç°
1. æ€§èƒ½ï¼šæ¯å±‚å¤„ç†å®Œæ¯•åå†³å®šæ–¹å‘
1. å¯è¯»æ€§ï¼šä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç»´æŠ¤
1. æ‰©å±•æ€§ï¼šå¯è½»æ¾æ‰©å±•åˆ°å…¶ä»–å˜ä½“

### æ€»ç»“

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ å±‚æ–¹å‘æ§åˆ¶æ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ€ç»´æ¸…æ™°åº¦å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶å±•ç¤ºä¸åŒè¯­è¨€åœ¨æ–¹å‘æ§åˆ¶å’Œé˜Ÿåˆ—æ“ä½œä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func zigzagLevelOrder(root *TreeNode) [][]int {
    // å¤„ç†ç©ºæ ‘æƒ…å†µ
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}          // å­˜å‚¨æœ€ç»ˆç»“æœ
    queue := []*TreeNode{root}   // é˜Ÿåˆ—åˆå§‹åŒ–ï¼Œå­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹
    leftToRight := true          // æ–¹å‘æ ‡å¿—ï¼štrueè¡¨ç¤ºä»å·¦åˆ°å³ï¼Œfalseè¡¨ç¤ºä»å³åˆ°å·¦

    for len(queue) > 0 {
        levelSize := len(queue)  // å½“å‰å±‚èŠ‚ç‚¹æ•°
        currentLevel := make([]int, levelSize) // é¢„åˆ†é…ç©ºé—´ï¼Œæé«˜æ€§èƒ½

        // éå†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < levelSize; i++ {
            node := queue[0]     // å–é˜Ÿé¦–èŠ‚ç‚¹
            queue = queue[1:]    // å‡ºé˜Ÿ

            // æ ¹æ®æ–¹å‘å†³å®šèŠ‚ç‚¹å€¼çš„å­˜å‚¨ä½ç½®
            if leftToRight {
                currentLevel[i] = node.Val // ä»å·¦åˆ°å³ï¼šæ­£åºå­˜å‚¨
            } else {
                currentLevel[levelSize-1-i] = node.Val // ä»å³åˆ°å·¦ï¼šé€†åºå­˜å‚¨
            }

            // å°†å­èŠ‚ç‚¹å…¥é˜Ÿï¼ˆå…ˆå·¦åå³ï¼Œä¿æŒå…¥é˜Ÿé¡ºåºï¼‰
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        // å°†å½“å‰å±‚ç»“æœåŠ å…¥æœ€ç»ˆç»“æœ
        result = append(result, currentLevel)
        // åˆ‡æ¢æ–¹å‘
        leftToRight = !leftToRight
    }

    return result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if root == nil` - ç©ºæ ‘ç›´æ¥è¿”å›ç©ºç»“æœ
1. ç»“æœå­˜å‚¨ï¼š`result` - äºŒç»´åˆ‡ç‰‡å­˜å‚¨æ¯å±‚ç»“æœ
1. é˜Ÿåˆ—åˆå§‹åŒ–ï¼š`queue` - å­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹ï¼Œåˆå§‹åŒ…å«æ ¹èŠ‚ç‚¹
1. æ–¹å‘æ ‡å¿—ï¼š`leftToRight` - æ§åˆ¶å½“å‰å±‚çš„éå†æ–¹å‘
1. å±‚çº§å¾ªç¯ï¼š`for len(queue) > 0` - é˜Ÿåˆ—éç©ºæ—¶ç»§ç»­éå†
1. å±‚å¤§å°è®°å½•ï¼š`levelSize` - å½“å‰å±‚èŠ‚ç‚¹æ•°ï¼Œç”¨äºæ§åˆ¶å†…å±‚å¾ªç¯æ¬¡æ•°
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `node := queue[0]` - å–é˜Ÿé¦–èŠ‚ç‚¹
   - `queue = queue[1:]` - å‡ºé˜Ÿæ“ä½œ
   - æ ¹æ®`leftToRight`å†³å®šå­˜å‚¨ä½ç½®
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šå°†éç©ºå·¦ã€å³å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ï¼ˆä¿æŒå…¥é˜Ÿé¡ºåºï¼‰
1. æ–¹å‘åˆ‡æ¢ï¼š`leftToRight = !leftToRight` - æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢æ–¹å‘

è®¾è®¡åŠ¨æœºï¼š

- ä½¿ç”¨åˆ‡ç‰‡æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œç®€å•ç›´æ¥
- é¢„åˆ†é…`currentLevel`ç©ºé—´ï¼Œæé«˜æ€§èƒ½
- é€šè¿‡ç´¢å¼•æ§åˆ¶å­˜å‚¨ä½ç½®ï¼Œå®ç°æ–¹å‘åˆ‡æ¢
- ä¿æŒå­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºï¼Œç¡®ä¿ä¸‹ä¸€å±‚å¤„ç†æ­£ç¡®

### B. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])
        left_to_right = True  # æ–¹å‘æ ‡å¿—

        while queue:
            level_size = len(queue)
            current_level = [0] * level_size  # é¢„åˆ†é…ç©ºé—´

            for i in range(level_size):
                node = queue.popleft()

                # æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
                if left_to_right:
                    current_level[i] = node.val
                else:
                    current_level[level_size - 1 - i] = node.val

                # å­èŠ‚ç‚¹å…¥é˜Ÿï¼ˆå…ˆå·¦åå³ï¼‰
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(current_level)
            left_to_right = not left_to_right  # åˆ‡æ¢æ–¹å‘

        return result
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if not root` - Pythoné£æ ¼çš„ç©ºæ£€æŸ¥
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`deque` - åŒç«¯é˜Ÿåˆ—ï¼Œé«˜æ•ˆå‡ºé˜Ÿå…¥é˜Ÿ
1. æ–¹å‘æ ‡å¿—ï¼š`left_to_right` - æ§åˆ¶å½“å‰å±‚æ–¹å‘
1. é¢„åˆ†é…ç©ºé—´ï¼š`[0] * level_size` - æé«˜æ€§èƒ½
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `node = queue.popleft()` - é«˜æ•ˆå‡ºé˜Ÿ
   - æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šéç©ºå­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨
1. æ–¹å‘åˆ‡æ¢ï¼š`left_to_right = not left_to_right` - æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢

Pythonç‰¹æ€§ï¼š

- ä½¿ç”¨`deque`æé«˜å‡ºé˜Ÿæ•ˆç‡
- åˆ—è¡¨é¢„åˆ†é…ç©ºé—´
- ä»£ç ç®€æ´æ˜“è¯»

### C. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function zigzagLevelOrder(root: TreeNode | null): number[][] {
    if (!root) {
        return [];
    }

    const result: number[][] = [];
    const queue: TreeNode[] = [root];
    let leftToRight = true;  // æ–¹å‘æ ‡å¿—

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel: number[] = new Array(levelSize);  // é¢„åˆ†é…ç©ºé—´

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift()!;

            // æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
            if (leftToRight) {
                currentLevel[i] = node.val;
            } else {
                currentLevel[levelSize - 1 - i] = node.val;
            }

            // å­èŠ‚ç‚¹å…¥é˜Ÿï¼ˆå…ˆå·¦åå³ï¼‰
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }

        result.push(currentLevel);
        leftToRight = !leftToRight;  // åˆ‡æ¢æ–¹å‘
    }

    return result;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if (!root)` - TypeScripté£æ ¼çš„ç©ºæ£€æŸ¥
1. ç±»å‹å®šä¹‰ï¼š`number[][]` - æ˜ç¡®ç»“æœç±»å‹
1. æ–¹å‘æ ‡å¿—ï¼š`leftToRight` - æ§åˆ¶å½“å‰å±‚æ–¹å‘
1. é¢„åˆ†é…ç©ºé—´ï¼š`new Array(levelSize)` - æé«˜æ€§èƒ½
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `node = queue.shift()!` - å‡ºé˜Ÿæ“ä½œ
   - æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šéç©ºå­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨
1. æ–¹å‘åˆ‡æ¢ï¼š`leftToRight = !leftToRight` - æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢

TypeScriptç‰¹æ€§ï¼š

- ç±»å‹æ³¨è§£å¢å¼ºä»£ç å®‰å…¨æ€§
- éç©ºæ–­è¨€ç¡®ä¿ç±»å‹æ­£ç¡®
- æ•°ç»„é¢„åˆ†é…ç©ºé—´

æ³¨æ„ï¼šTypeScriptçš„`shift()`æ“ä½œæ˜¯O(n)æ—¶é—´ï¼Œåœ¨å¤§è§„æ¨¡æ•°æ®æ—¶æ€§èƒ½è¾ƒå·®

### D. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::VecDeque;

impl Solution {
    pub fn zigzag_level_order(root: Option<Box<TreeNode>>) -> Vec<Vec<i32>> {
        let mut result = Vec::new();
        let mut queue = VecDeque::new();
        let mut left_to_right = true;  // æ–¹å‘æ ‡å¿—

        // å¤„ç†æ ¹èŠ‚ç‚¹
        if let Some(node) = root {
            queue.push_back(node);
        }

        while !queue.is_empty() {
            let level_size = queue.len();
            let mut current_level = vec![0; level_size];  // é¢„åˆ†é…ç©ºé—´

            for i in 0..level_size {
                if let Some(node) = queue.pop_front() {
                    // æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
                    if left_to_right {
                        current_level[i] = node.val;
                    } else {
                        current_level[level_size - 1 - i] = node.val;
                    }

                    // å­èŠ‚ç‚¹å…¥é˜Ÿï¼ˆå…ˆå·¦åå³ï¼‰
                    if let Some(left) = node.left {
                        queue.push_back(left);
                    }
                    if let Some(right) = node.right {
                        queue.push_back(right);
                    }
                }
            }

            result.push(current_level);
            left_to_right = !left_to_right;  // åˆ‡æ¢æ–¹å‘
        }

        result
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if let Some(node) = root` - Rustçš„Optionæ¨¡å¼åŒ¹é…
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`VecDeque` - é«˜æ•ˆåŒç«¯é˜Ÿåˆ—
1. æ–¹å‘æ ‡å¿—ï¼š`left_to_right` - æ§åˆ¶å½“å‰å±‚æ–¹å‘
1. é¢„åˆ†é…ç©ºé—´ï¼š`vec![0; level_size]` - æé«˜æ€§èƒ½
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `queue.pop_front()` - é«˜æ•ˆå‡ºé˜Ÿ
   - æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šä½¿ç”¨`if let`æ¨¡å¼åŒ¹é…å¤„ç†å­èŠ‚ç‚¹
1. æ–¹å‘åˆ‡æ¢ï¼š`left_to_right = !left_to_right` - æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢

Rustç‰¹æ€§ï¼š

- æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨
- æ¨¡å¼åŒ¹é…ç¡®ä¿ä»£ç å®‰å…¨
- é«˜æ•ˆçš„å†…å­˜ç®¡ç†
- é¢„åˆ†é…ç©ºé—´æé«˜æ€§èƒ½

### E. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é˜Ÿåˆ—å®ç° | æ–¹å‘æ§åˆ¶ | ç‰¹ç‚¹                  |
| ---------- | ---------- | ---------- | -------- | -------- | --------------------- |
| Go         | O(n)       | O(n)       | åˆ‡ç‰‡     | ç´¢å¼•æ§åˆ¶ | ç®€å•é«˜æ•ˆï¼Œé¢è¯•é¦–é€‰    |
| Python     | O(n)       | O(n)       | deque    | ç´¢å¼•æ§åˆ¶ | ç®€æ´é«˜æ•ˆï¼Œä»£ç ç®€æ´    |
| TypeScript | O(nÂ²)      | O(n)       | æ•°ç»„     | ç´¢å¼•æ§åˆ¶ | shift()æ€§èƒ½å·®ï¼Œå¯ä¼˜åŒ– |
| Rust       | O(n)       | O(n)       | VecDeque | ç´¢å¼•æ§åˆ¶ | å†…å­˜å®‰å…¨ï¼Œæ€§èƒ½æœ€ä¼˜    |

æ³¨æ„ï¼šTypeScriptçš„æ•°ç»„shift()æ“ä½œæ˜¯O(n)æ—¶é—´ï¼Œåœ¨å¤§è§„æ¨¡æ•°æ®æ—¶æ€§èƒ½è¾ƒå·®ï¼Œå»ºè®®ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿å®ç°

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```text
å‡½æ•° zigzagLevelOrder(root):
    å¦‚æœ root ä¸ºç©º:
        è¿”å› ç©ºåˆ—è¡¨

    result = ç©ºåˆ—è¡¨
    queue = é˜Ÿåˆ—([root])
    leftToRight = true  // æ–¹å‘æ ‡å¿—

    å½“ queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = é•¿åº¦ä¸º levelSize çš„åˆ—è¡¨

        å¯¹äº i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ

            å¦‚æœ leftToRight ä¸ºçœŸ:
                currentLevel[i] = node.val
            å¦åˆ™:
                currentLevel[levelSize-1-i] = node.val

            å¦‚æœ node.left ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.left
            å¦‚æœ node.right ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.right

        result æ·»åŠ  currentLevel
        leftToRight = é leftToRight  // åˆ‡æ¢æ–¹å‘

    è¿”å› result
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: zigzagLevelOrder(root)] --> B{root ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› ç©ºåˆ—è¡¨]
    B -- å¦ --> D[åˆå§‹åŒ– result, queue, leftToRight]
    D --> E[queue å…¥é˜Ÿ root]
    E --> F{queue ä¸ºç©º?}
    F -- æ˜¯ --> G[è¿”å› result]
    F -- å¦ --> H[levelSize = queue é•¿åº¦]
    H --> I[åˆå§‹åŒ– currentLevel]
    I --> J[i = 0]
    J --> K{i < levelSize?}
    K -- æ˜¯ --> L[node = queue å‡ºé˜Ÿ]
    L --> M{leftToRight?}
    M -- æ˜¯ --> N[currentLevel[i] = node.val]
    M -- å¦ --> O[currentLevel[levelSize-1-i] = node.val]
    N --> P{node.left éç©º?}
    O --> P
    P -- æ˜¯ --> Q[queue å…¥é˜Ÿ node.left]
    P -- å¦ --> R{node.right éç©º?}
    Q --> R
    R -- æ˜¯ --> S[queue å…¥é˜Ÿ node.right]
    R -- å¦ --> T[i = i + 1]
    S --> T
    T --> K
    K -- å¦ --> U[result æ·»åŠ  currentLevel]
    U --> V[åˆ‡æ¢ leftToRight]
    V --> F
```

### çŠ¶æ€è½¬ç§»å›¾ï¼ˆç¤ºä¾‹ï¼‰

```mermaid
graph LR
    subgraph "æ‰§è¡Œè¿‡ç¨‹: root = [3,9,20,null,null,15,7]"
        direction TB
        S1["ç¬¬1å±‚: queue=[3], leftToRight=true"] --> S1a["å¤„ç†èŠ‚ç‚¹3"]
        S1a --> S1b["currentLevel=[3]"]
        S1b --> S1c["å…¥é˜Ÿ9,20"]
        S1c --> S1d["queue=[9,20], leftToRight=false"]

        S1d --> S2["ç¬¬2å±‚: queue=[9,20], leftToRight=false"]
        S2 --> S2a["å¤„ç†èŠ‚ç‚¹9"]
        S2a --> S2b["currentLevel[1]=9"]
        S2b --> S2c["9æ— å­èŠ‚ç‚¹"]
        S2c --> S2d["å¤„ç†èŠ‚ç‚¹20"]
        S2d --> S2e["currentLevel[0]=20"]
        S2e --> S2f["å…¥é˜Ÿ15,7"]
        S2f --> S2g["queue=[15,7], leftToRight=true"]

        S2g --> S3["ç¬¬3å±‚: queue=[15,7], leftToRight=true"]
        S3 --> S3a["å¤„ç†èŠ‚ç‚¹15"]
        S3a --> S3b["currentLevel[0]=15"]
        S3b --> S3c["15æ— å­èŠ‚ç‚¹"]
        S3c --> S3d["å¤„ç†èŠ‚ç‚¹7"]
        S3d --> S3e["currentLevel[1]=7"]
        S3e --> S3f["7æ— å­èŠ‚ç‚¹"]
        S3f --> S3g["queue=[], leftToRight=false"]

        S3g --> S4["ç»“æŸ: result=[[3],[20,9],[15,7]]"]
    end

    %% æ ·å¼è®¾ç½®
    style S1 fill:#e6f3ff,stroke:#333
    style S2 fill:#e6f3ff,stroke:#333
    style S3 fill:#e6f3ff,stroke:#333
    style S4 fill:#6f9,stroke:#333
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: root = [3,9,20,null,null,15,7]

#### è¯¦ç»†æ‰§è¡Œæ­¥éª¤

| å±‚æ•° | queueçŠ¶æ€ | leftToRight | å¤„ç†èŠ‚ç‚¹ | currentLevel | å­èŠ‚ç‚¹å…¥é˜Ÿ | è¯´æ˜                    |
| ---- | --------- | ----------- | -------- | ------------ | ---------- | ----------------------- |
| 1    | [3]       | true        | 3        | [3]          | 9,20       | æ ¹èŠ‚ç‚¹3ï¼Œå…¥é˜Ÿå­èŠ‚ç‚¹9,20 |
| 2    | [9,20]    | false       | 9        | [0,9]        | -          | 9å­˜å‚¨åœ¨ç´¢å¼•1ï¼ˆé€†åºï¼‰    |
| 2    | [20]      | false       | 20       | [20,9]       | 15,7       | 20å­˜å‚¨åœ¨ç´¢å¼•0ï¼ˆé€†åºï¼‰   |
| 3    | [15,7]    | true        | 15       | [15,0]       | -          | 15å­˜å‚¨åœ¨ç´¢å¼•0ï¼ˆæ­£åºï¼‰   |
| 3    | [7]       | true        | 7        | [15,7]       | -          | 7å­˜å‚¨åœ¨ç´¢å¼•1ï¼ˆæ­£åºï¼‰    |

#### æœ€ç»ˆç»“æœ

```text
[
    [3],
    [20,9],
    [15,7]
]
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func zigzagLevelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}
    leftToRight := true

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := make([]int, levelSize)

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            if leftToRight {
                currentLevel[i] = node.Val
            } else {
                currentLevel[levelSize-1-i] = node.Val
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, currentLevel)
        leftToRight = !leftToRight
    }

    return result
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®å±‚åºæ•°ç»„æ„å»ºäºŒå‰æ ‘
func buildTree(nums []interface{}) *TreeNode {
    if len(nums) == 0 || nums[0] == nil {
        return nil
    }

    root := &TreeNode{Val: nums[0].(int)}
    queue := []*TreeNode{root}
    i := 1

    for len(queue) > 0 && i < len(nums) {
        node := queue[0]
        queue = queue[1:]

        if i < len(nums) && nums[i] != nil {
            node.Left = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Left)
        }
        i++

        if i < len(nums) && nums[i] != nil {
            node.Right = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Right)
        }
        i++
    }

    return root
}

func main() {
    // Test Case 1
    nums1 := []interface{}{3, 9, 20, nil, nil, 15, 7}
    tree1 := buildTree(nums1)
    fmt.Printf("Test Case 1: %v\n", zigzagLevelOrder(tree1)) // [[3],[20,9],[15,7]]

    // Test Case 2
    nums2 := []interface{}{1}
    tree2 := buildTree(nums2)
    fmt.Printf("Test Case 2: %v\n", zigzagLevelOrder(tree2)) // [[1]]

    // Test Case 3
    nums3 := []interface{}{}
    tree3 := buildTree(nums3)
    fmt.Printf("Test Case 3: %v\n", zigzagLevelOrder(tree3)) // []
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

æœ¬ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦

- æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ï¼šO(n)
- é˜Ÿåˆ—æ“ä½œï¼šæ¯ä¸ªèŠ‚ç‚¹å…¥é˜Ÿå‡ºé˜Ÿå„ä¸€æ¬¡ï¼ŒO(1)æ“ä½œ Ã— n = O(n)
- å±‚çº§å¤„ç†ï¼šå¤–å±‚å¾ªç¯æ¬¡æ•°ç­‰äºæ ‘çš„é«˜åº¦hï¼Œå†…å±‚å¾ªç¯æ€»æ¬¡æ•°ä¸ºn
- æ–¹å‘æ§åˆ¶ï¼šæ¯å±‚O(1)æ—¶é—´åˆ‡æ¢æ–¹å‘
- æ€»æ—¶é—´ï¼šO(n) + O(n) + O(h) = O(n)

#### B. ç©ºé—´å¤æ‚åº¦

- ç»“æœå­˜å‚¨ï¼šO(n) - å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹å€¼
- é˜Ÿåˆ—å­˜å‚¨ï¼šæœ€åæƒ…å†µä¸‹å­˜å‚¨æœ€åä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹ï¼ŒO(n/2) â‰ˆ O(n)
- æ–¹å‘æ ‡å¿—ï¼šO(1) - å•ä¸ªå¸ƒå°”å˜é‡
- æ€»ç©ºé—´ï¼šO(n) + O(n) + O(1) = O(n)

#### C. æœ€å¥½/å¹³å‡/æœ€åæƒ…å†µåˆ†æ

| æƒ…å†µ           | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                            |
| -------------- | ---------- | ---------- | ------------------------------- |
| æœ€å¥½ï¼ˆå¹³è¡¡æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸ºn/2               |
| å¹³å‡           | O(n)       | O(n)       | å…¸å‹äºŒå‰æ ‘                      |
| æœ€åï¼ˆé€€åŒ–æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸º1ï¼ˆæ¯å±‚ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ |

#### D. å¸¸æ•°å› å­åˆ†æ

- é˜Ÿåˆ—æ“ä½œå¼€é”€ï¼šå…¥é˜Ÿå‡ºé˜Ÿçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- ç»“æœå­˜å‚¨å¼€é”€ï¼šäºŒç»´æ•°ç»„çš„å†…å­˜åˆ†é…
- æ–¹å‘æ§åˆ¶å¼€é”€ï¼šå¸ƒå°”æ ‡å¿—åˆ‡æ¢
- è¯­è¨€ç‰¹æ€§å½±å“ï¼š
  - Goåˆ‡ç‰‡æ“ä½œé«˜æ•ˆ
  - Python dequeé«˜æ•ˆ
  - TypeScriptæ•°ç»„shift()ä½æ•ˆï¼ˆå¯ä¼˜åŒ–ï¼‰
  - Rust VecDequeé«˜æ•ˆä¸”å®‰å…¨

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆï¼šé˜Ÿåˆ—æ“ä½œçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- ä¼˜åŒ–æ–¹å‘ï¼š
  - ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—äº¤æ›¿å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚
  - é¢„åˆ†é…å†…å­˜ç©ºé—´ï¼ˆå¦‚Goå’ŒRustå®ç°ï¼‰
  - TypeScriptä¸­ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"å±‚çº§éå†å˜ä½“"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. å¤ç”¨å±‚åºéå†é€»è¾‘
1. å±‚æ–¹å‘æ§åˆ¶æŠ€å·§
1. ç´¢å¼•æ“ä½œçš„åº”ç”¨
1. å¯æ‰©å±•åˆ°å¤šç§å±‚çº§ç»“æ„

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- å±‚åºéå†çš„å˜ä½“ï¼šé”¯é½¿å½¢å±‚åºéå† = æ­£å¸¸å±‚åºéå† + æ–¹å‘æ§åˆ¶
- æ–¹å‘æ§åˆ¶ï¼šé€šè¿‡å¸ƒå°”æ ‡å¿—ä½æ§åˆ¶æ¯å±‚æ–¹å‘
- ç´¢å¼•æ“ä½œï¼šé€šè¿‡ç´¢å¼•æ§åˆ¶èŠ‚ç‚¹å€¼çš„å­˜å‚¨ä½ç½®
- å¤ç”¨æ€§ï¼šç›´æ¥åŸºäº102é¢˜çš„BFSå®ç°
- æ‰©å±•æ€§ï¼šå¯åº”ç”¨äºå…¶ä»–éœ€è¦æ–¹å‘æ§åˆ¶çš„åœºæ™¯

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®                | æ ¸å¿ƒæ€æƒ³               | åŒ¹é…æ¨¡å¼ |
| ---- | ------------------- | ---------------------- | -------- |
| 103  | æœ¬é¢˜                | é”¯é½¿å½¢å±‚åºéå†         | æ ¸å¿ƒæ¨¡å¼ |
| 102  | äºŒå‰æ ‘çš„å±‚åºéå†    | æ­£å¸¸å±‚åºéå†           | åŸºç¡€æ¨¡å¼ |
| 107  | äºŒå‰æ ‘çš„å±‚åºéå† II | è‡ªåº•å‘ä¸Šå±‚åºéå†       | æ¨¡å¼å˜ä½“ |
| 429  | Nå‰æ ‘çš„å±‚åºéå†     | Nå‰æ ‘å±‚åºéå†          | æ¨¡å¼æ‰©å±• |
| 199  | äºŒå‰æ ‘çš„å³è§†å›¾      | å±‚åºéå†å–æ¯å±‚æœ€åä¸€ä¸ª | æ¨¡å¼åº”ç”¨ |
| 637  | äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼    | å±‚åºéå†è®¡ç®—å¹³å‡å€¼     | æ¨¡å¼åº”ç”¨ |

#### C. æ¨¡å¼æ³›åŒ–

- æ–¹å‘æ§åˆ¶ï¼šä»»ä½•éœ€è¦æŒ‰å±‚æ§åˆ¶æ–¹å‘çš„éå†
- å¤šå‰æ ‘ï¼šNå‰æ ‘çš„é”¯é½¿å½¢éå†
- å›¾éå†ï¼šå›¾çš„é”¯é½¿å½¢å±‚çº§éå†
- ç»„ç»‡ç»“æ„ï¼šäº¤æ›¿æ–¹å‘å±•ç¤ºå…¬å¸ç»“æ„
- æ–‡ä»¶ç³»ç»Ÿï¼šäº¤æ›¿æ–¹å‘å±•ç¤ºç›®å½•æ ‘

#### D. å·¥ä¸šåº”ç”¨

- ç»„ç»‡ç»“æ„å›¾ï¼šäº¤æ›¿æ–¹å‘å±•ç¤ºå‘˜å·¥-ç»ç†å…³ç³»
- æ–‡ä»¶ç³»ç»Ÿï¼šäº¤æ›¿æ–¹å‘å±•ç¤ºç›®å½•ç»“æ„
- ç½‘ç»œè·¯ç”±ï¼šæŒ‰è·³æ•°äº¤æ›¿æ–¹å‘å±•ç¤ºè·¯ç”±è·¯å¾„
- æ¸¸æˆAIï¼šæŒ‰è·ç¦»äº¤æ›¿æ–¹å‘æœç´¢ç›®æ ‡
- æ•°æ®åº“ç´¢å¼•ï¼šBæ ‘çš„é”¯é½¿å½¢å±‚çº§éå†

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆé€‰æ‹©ç´¢å¼•æ§åˆ¶è€Œä¸æ˜¯åè½¬ï¼Ÿ
   - ç´¢å¼•æ§åˆ¶åœ¨éå†è¿‡ç¨‹ä¸­å®Œæˆæ–¹å‘æ§åˆ¶
   - åè½¬éœ€è¦é¢å¤–çš„O(n)æ—¶é—´å’Œç©ºé—´
   - ç´¢å¼•æ§åˆ¶æ›´ç¬¦åˆå®æ—¶å¤„ç†çš„è¦æ±‚

1. ä¸ºä»€ä¹ˆå¿…é¡»ä¿æŒå­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºï¼Ÿ
   - å­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºå†³å®šäº†ä¸‹ä¸€å±‚çš„å¤„ç†é¡ºåº
   - å¿…é¡»ä¿æŒå…ˆå·¦åå³çš„å…¥é˜Ÿé¡ºåº
   - å¦åˆ™ä¼šå¯¼è‡´æ–¹å‘æ§åˆ¶é€»è¾‘é”™è¯¯

1. æ–¹å‘æ ‡å¿—çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ
   - æ§åˆ¶å½“å‰å±‚çš„éå†æ–¹å‘
   - å†³å®šèŠ‚ç‚¹å€¼çš„å­˜å‚¨ä½ç½®
   - æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢æ–¹å‘

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿï¼š

1. å¯¹BFSå’Œæ–¹å‘æ§åˆ¶çš„ç†è§£
1. å¤æ‚åº¦åˆ†æä¸ä¼˜åŒ–èƒ½åŠ›
1. ä»åŸºç¡€åˆ°å˜ä½“çš„æ‰©å±•èƒ½åŠ›
1. ä¸åŒå®ç°æ–¹å¼çš„æƒè¡¡

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆé€‰æ‹©BFSè€Œä¸æ˜¯DFSï¼Ÿ

â†’ æ ‡å‡†: BFSå¤©ç„¶æŒ‰å±‚è®¿é—®ï¼Œä¸å±‚åºéå†å®Œå…¨åŒ¹é…
â†’ åŠ åˆ†: DFSéœ€è¦é¢å¤–è®°å½•å±‚æ•°å’Œæ–¹å‘ï¼Œå®ç°å¤æ‚

#### Q2: å¦‚ä½•å¤„ç†ç©ºæ ‘çš„æƒ…å†µï¼Ÿ

â†’ æ ‡å‡†: åœ¨å‡½æ•°å¼€å§‹æ—¶æ£€æŸ¥rootæ˜¯å¦ä¸ºnull
â†’ åŠ åˆ†: æä¾›å…·ä½“ä»£ç å®ç°ï¼Œå±•ç¤ºè¾¹ç•Œå¤„ç†

#### Q3: æ–¹å‘æ ‡å¿—çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

â†’ æ ‡å‡†: æ§åˆ¶å½“å‰å±‚çš„éå†æ–¹å‘
â†’ åŠ åˆ†: è¯´æ˜æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢æ–¹å‘ï¼Œå†³å®šèŠ‚ç‚¹å€¼çš„å­˜å‚¨ä½ç½®

#### Q4: ä¸ºä»€ä¹ˆå¿…é¡»ä¿æŒå­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºï¼Ÿ

â†’ æ ‡å‡†: å­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºå†³å®šäº†ä¸‹ä¸€å±‚çš„å¤„ç†é¡ºåº
â†’ åŠ åˆ†: è¯´æ˜å¿…é¡»ä¿æŒå…ˆå·¦åå³çš„å…¥é˜Ÿé¡ºåºï¼Œå¦åˆ™æ–¹å‘æ§åˆ¶é€»è¾‘é”™è¯¯

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°åŒæ ˆæ³•çš„é”¯é½¿å½¢å±‚åºéå†ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨ä¸¤ä¸ªæ ˆäº¤æ›¿å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚èŠ‚ç‚¹
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// åŒæ ˆæ³•å®ç°
func zigzagLevelOrderTwoStacks(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    currentStack := []*TreeNode{root}
    nextStack := []*TreeNode{}
    leftToRight := true

    for len(currentStack) > 0 {
        levelSize := len(currentStack)
        currentLevel := make([]int, levelSize)

        for i := 0; i < levelSize; i++ {
            node := currentStack[len(currentStack)-1]
            currentStack = currentStack[:len(currentStack)-1]

            if leftToRight {
                currentLevel[i] = node.Val
            } else {
                currentLevel[levelSize-1-i] = node.Val
            }

            // æ ¹æ®æ–¹å‘å†³å®šå­èŠ‚ç‚¹å…¥æ ˆé¡ºåº
            if leftToRight {
                if node.Left != nil {
                    nextStack = append(nextStack, node.Left)
                }
                if node.Right != nil {
                    nextStack = append(nextStack, node.Right)
                }
            } else {
                if node.Right != nil {
                    nextStack = append(nextStack, node.Right)
                }
                if node.Left != nil {
                    nextStack = append(nextStack, node.Left)
                }
            }
        }

        result = append(result, currentLevel)
        currentStack, nextStack = nextStack, currentStack
        nextStack = nextStack[:0]  // æ¸…ç©ºnextStack
        leftToRight = !leftToRight
    }

    return result
}
```

#### Q2: å¦‚ä½•å®ç°Nå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†ï¼Ÿ

â†’ æ ‡å‡†: å¤ç”¨Nå‰æ ‘å±‚åºéå†é€»è¾‘ï¼Œå¢åŠ æ–¹å‘æ§åˆ¶
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// Nå‰æ ‘èŠ‚ç‚¹å®šä¹‰
type Node struct {
    Val int
    Children []*Node
}

func zigzagLevelOrderN(root *Node) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*Node{root}
    leftToRight := true

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := make([]int, levelSize)

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            if leftToRight {
                currentLevel[i] = node.Val
            } else {
                currentLevel[levelSize-1-i] = node.Val
            }

            // éå†æ‰€æœ‰å­èŠ‚ç‚¹
            for _, child := range node.Children {
                queue = append(queue, child)
            }
        }

        result = append(result, currentLevel)
        leftToRight = !leftToRight
    }

    return result
}
```

#### Q3: å¦‚ä½•ä¼˜åŒ–TypeScriptçš„å®ç°ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–åçš„ä»£ç 

```typescript
// ä¼˜åŒ–ç‰ˆï¼šä½¿ç”¨ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
function zigzagLevelOrderOptimized(root: TreeNode | null): number[][] {
  if (!root) return [];

  const result: number[][] = [];
  let currentLevelNodes: TreeNode[] = [root];
  let leftToRight = true;

  while (currentLevelNodes.length > 0) {
    const currentLevel: number[] = [];
    const nextLevelNodes: TreeNode[] = [];

    for (const node of currentLevelNodes) {
      currentLevel.push(node.val);
      if (node.left) nextLevelNodes.push(node.left);
      if (node.right) nextLevelNodes.push(node.right);
    }

    // æ ¹æ®æ–¹å‘å†³å®šæ˜¯å¦åè½¬å½“å‰å±‚
    if (!leftToRight) {
      currentLevel.reverse();
    }

    result.push(currentLevel);
    currentLevelNodes = nextLevelNodes;
    leftToRight = !leftToRight;
  }

  return result;
}
```

#### Q4: å¦‚ä½•å®ç°äºŒå‰æ ‘çš„èºæ—‹å½¢éå†ï¼Ÿ

â†’ æ ‡å‡†: é”¯é½¿å½¢å±‚åºéå†çš„å˜ä½“ï¼Œå¢åŠ æ—‹è½¬è§’åº¦æ§åˆ¶
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°æ€è·¯

```go
// èºæ—‹å½¢éå†ï¼ˆ0Â°, 90Â°, 180Â°, 270Â°äº¤æ›¿ï¼‰
func spiralOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}
    directions := []int{0, 1, 2, 3} // 0:å·¦â†’å³, 1:ä¸Šâ†’ä¸‹, 2:å³â†’å·¦, 3:ä¸‹â†’ä¸Š
    dirIndex := 0

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := make([]int, levelSize)

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            switch directions[dirIndex % 4] {
            case 0: // å·¦â†’å³
                currentLevel[i] = node.Val
            case 1: // ä¸Šâ†’ä¸‹ï¼ˆéœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œé€šå¸¸éœ€è¦çŸ©é˜µè¡¨ç¤ºï¼‰
                // æ­¤å¤„ç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æ•°æ®ç»“æ„
                currentLevel[i] = node.Val
            case 2: // å³â†’å·¦
                currentLevel[levelSize-1-i] = node.Val
            case 3: // ä¸‹â†’ä¸Šï¼ˆéœ€è¦ç‰¹æ®Šå¤„ç†ï¼‰
                currentLevel[levelSize-1-i] = node.Val
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, currentLevel)
        dirIndex++
    }

    return result
}
```

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®ï¼š

1. BFSä¸æ–¹å‘æ§åˆ¶çš„ç»“åˆ
1. ç´¢å¼•æ“ä½œçš„åº”ç”¨
1. å±‚åºéå†çš„å˜ä½“
1. å¤šè¯­è¨€å®ç°çš„å·®å¼‚

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹         | å£è¯€                           |
| -------------- | ------------------------------ |
| é”¯é½¿å½¢éå†æ ¸å¿ƒ | æ­£å¸¸å±‚åºéå† + æ–¹å‘æ§åˆ¶        |
| æ–¹å‘æ§åˆ¶       | å¸ƒå°”æ ‡å¿— + ç´¢å¼•æ“ä½œ            |
| å­èŠ‚ç‚¹å…¥é˜Ÿ     | ä¿æŒå…ˆå·¦åå³çš„é¡ºåº             |
| ç©ºæ ‘å¤„ç†       | å…ˆæ£€æŸ¥rootä¸ºç©º                 |
| æ—¶é—´å¤æ‚åº¦     | O(n)éå† + O(1)æ–¹å‘æ§åˆ¶ = O(n) |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹           | è§¦å‘åœºæ™¯           | åº”å¯¹æªæ–½                      |
| ------------------ | ------------------ | ----------------------------- |
| å¿˜è®°åˆ‡æ¢æ–¹å‘       | æ‰€æœ‰å±‚åŒä¸€æ–¹å‘     | æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢leftToRight     |
| å­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºé”™è¯¯ | æ–¹å‘æ§åˆ¶é€»è¾‘é”™è¯¯   | ä¿æŒå…ˆå·¦åå³çš„å…¥é˜Ÿé¡ºåº        |
| ç©ºæ ‘æœªå¤„ç†         | rootä¸ºnullæ—¶å´©æºƒ   | å‡½æ•°å¼€å§‹æ£€æŸ¥rootä¸ºç©º          |
| ç´¢å¼•è®¡ç®—é”™è¯¯       | é€†åºå­˜å‚¨ä½ç½®é”™è¯¯   | ä½¿ç”¨levelSize-1-iè®¡ç®—é€†åºä½ç½® |
| é˜Ÿåˆ—æ“ä½œé”™è¯¯       | åˆ‡ç‰‡è¶Šç•Œæˆ–å†…å­˜æ³„æ¼ | ç¡®ä¿å‡ºé˜Ÿå…¥é˜Ÿæ“ä½œæ­£ç¡®          |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯              | åº”ç”¨åœºæ™¯           |
| ------------------- | ------------------ |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ | æè¿°ç®—æ³•é€‰æ‹©       |
| æ–¹å‘æ§åˆ¶            | è¯´æ˜é”¯é½¿å½¢å®ç°     |
| ç´¢å¼•æ“ä½œ            | è§£é‡ŠèŠ‚ç‚¹å€¼å­˜å‚¨ä½ç½® |
| å±‚åºéå†å˜ä½“        | å‘½åç®—æ³•èŒƒå¼       |
| æ—¶é—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ         |
| ç©ºé—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ         |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: å±‚çº§éå†å˜ä½“ï¼ˆé”¯é½¿å½¢ï¼‰
â”œâ”€â”€ å¿…è¦æ¡ä»¶: BFS + æ–¹å‘æ§åˆ¶
â”œâ”€â”€ æœ¬è´¨: å±‚åºéå† + æ–¹å‘äº¤æ›¿
â”œâ”€â”€ æ–¹æ³•: BFS + å¸ƒå°”æ ‡å¿—
â”‚   â”œâ”€â”€ é˜Ÿåˆ—åˆå§‹åŒ–: [root]
â”‚   â”œâ”€â”€ å¤–å±‚å¾ªç¯: é˜Ÿåˆ—éç©º
â”‚   â”œâ”€â”€ å†…å±‚å¾ªç¯: å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
â”‚   â”œâ”€â”€ æ–¹å‘æ§åˆ¶: leftToRightæ ‡å¿—
â”‚   â”œâ”€â”€ ç´¢å¼•æ“ä½œ: æ ¹æ®æ–¹å‘å†³å®šå­˜å‚¨ä½ç½®
â”‚   â””â”€â”€ æ–¹å‘åˆ‡æ¢: æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢
â”œâ”€â”€ ä¼˜åŒ–: åŒæ ˆæ³•ã€é¢„åˆ†é…ç©ºé—´
â”œâ”€â”€ å˜ä½“: Nå‰æ ‘ã€èºæ—‹å½¢éå†
â””â”€â”€ åº”ç”¨: ç»„ç»‡ç»“æ„ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œè·¯ç”±
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆï¼ˆBFS+æ–¹å‘æ§åˆ¶ï¼‰
å‡½æ•° zigzagLevelOrder(root):
    if root ä¸ºç©º: return []
    result = []
    queue = [root]
    leftToRight = true

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = é•¿åº¦ä¸º levelSize çš„åˆ—è¡¨

        for i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ

            if leftToRight:
                currentLevel[i] = node.val
            else:
                currentLevel[levelSize-1-i] = node.val

            if node.left éç©º: queue å…¥é˜Ÿ node.left
            if node.right éç©º: queue å…¥é˜Ÿ node.right

        result æ·»åŠ  currentLevel
        leftToRight = é leftToRight

    return result

// ä¼˜åŒ–ç‰ˆï¼ˆåŒæ ˆæ³•ï¼‰
å‡½æ•° zigzagLevelOrderTwoStacks(root):
    if root ä¸ºç©º: return []
    result = []
    currentStack = [root]
    nextStack = []
    leftToRight = true

    while currentStack ä¸ä¸ºç©º:
        levelSize = currentStack é•¿åº¦
        currentLevel = é•¿åº¦ä¸º levelSize çš„åˆ—è¡¨

        for i ä» 0 åˆ° levelSize-1:
            node = currentStack å‡ºæ ˆ

            if leftToRight:
                currentLevel[i] = node.val
            else:
                currentLevel[levelSize-1-i] = node.val

            if leftToRight:
                if node.left éç©º: nextStack å…¥æ ˆ node.left
                if node.right éç©º: nextStack å…¥æ ˆ node.right
            else:
                if node.right éç©º: nextStack å…¥æ ˆ node.right
                if node.left éç©º: nextStack å…¥æ ˆ node.left

        result æ·»åŠ  currentLevel
        currentStack, nextStack = nextStack, currentStack
        æ¸…ç©º nextStack
        leftToRight = é leftToRight

    return result
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³é”¯é½¿å½¢å±‚åºéå†ç›¸å…³é—®é¢˜ï¼Œå¹¶å±•ç°å¯¹æ ‘ç»“æ„éå†ç®—æ³•çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
