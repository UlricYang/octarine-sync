# LeetCode 662 - äºŒå‰æ ‘æœ€å¤§å®½åº¦

## 1. é¢˜ç›®æè¿°

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¿”å›æ ‘çš„ æœ€å¤§å®½åº¦

æ ‘çš„ æœ€å¤§å®½åº¦ æ˜¯æ‰€æœ‰å±‚ä¸­æœ€å¤§çš„ å®½åº¦

æ¯ä¸€å±‚çš„ å®½åº¦ è¢«å®šä¹‰ä¸ºè¯¥å±‚æœ€å·¦å’Œæœ€å³çš„éç©ºèŠ‚ç‚¹ï¼ˆå³ï¼Œä¸¤ä¸ªç«¯ç‚¹ï¼‰ä¹‹é—´çš„é•¿åº¦ã€‚å°†è¿™ä¸ªäºŒå‰æ ‘è§†ä½œä¸æ»¡äºŒå‰æ ‘ç»“æ„ç›¸åŒï¼Œä¸¤ç«¯ç‚¹é—´çš„é•¿åº¦ä»¥èŠ‚ç‚¹ä¹‹é—´çš„è¾¹æ•°è¡¨ç¤º

ä¾‹å¦‚ï¼Œåœ¨ä¸‹é¢çš„æ ‘ä¸­ï¼Œç¬¬ 0 å±‚çš„å®½åº¦æ˜¯ 1ï¼Œç¬¬ 1 å±‚çš„å®½åº¦æ˜¯ 2ï¼Œç¬¬ 2 å±‚çš„å®½åº¦æ˜¯ 2

```
        1
       / \
      3   2
     /     \
    5       9
```

ç¬¬ 0 å±‚çš„å®½åº¦æ˜¯ 1ï¼ˆåªæœ‰èŠ‚ç‚¹ 1ï¼‰ï¼Œç¬¬ 1 å±‚çš„å®½åº¦æ˜¯ 2ï¼ˆèŠ‚ç‚¹ 3 å’Œ 2 ä¹‹é—´æœ‰ 1 æ¡è¾¹ï¼‰ï¼Œç¬¬ 2 å±‚çš„å®½åº¦ä¹Ÿæ˜¯ 2ï¼ˆèŠ‚ç‚¹ 5 å’Œ 9 ä¹‹é—´æœ‰ 1 æ¡è¾¹ï¼ŒèŠ‚ç‚¹ 3 å’Œ 2 ä¹‹é—´çš„è¾¹ä¸è®¡ç®—åœ¨å†…ï¼‰

æ ‘çš„èŠ‚ç‚¹æ•°åœ¨èŒƒå›´ `[1, 3000]` å†…

### ç¤ºä¾‹ 1

```
è¾“å…¥ï¼šroot = [1,3,2,5,3,null,9]
è¾“å‡ºï¼š4
è§£é‡Šï¼šæœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 3 å±‚ï¼Œå®½åº¦ä¸º 4 (5,3,null,9)
```

### ç¤ºä¾‹ 2

```
è¾“å…¥ï¼šroot = [1,3,2,5,null,null,9,6,null,7]
è¾“å‡ºï¼š7
è§£é‡Šï¼šæœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 4 å±‚ï¼Œå®½åº¦ä¸º 7 (6,null,null,null,null,null,7)
```

### ç¤ºä¾‹ 3

```
è¾“å…¥ï¼šroot = [1,3,2,5]
è¾“å‡ºï¼š2
è§£é‡Šï¼šæœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 2 å±‚ï¼Œå®½åº¦ä¸º 2 (3,2)
```

### çº¦æŸæ¡ä»¶

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ `[1, 3000]`
- `-100 <= Node.val <= 100`

## 2. è§£æ³•åˆ†æï¼šBFS + ä½ç½®ç¼–å·

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ ä½ç½®ç¼–å·ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. è‡ªç„¶åŒ¹é…å±‚åºéå† - BFSå¤©ç„¶æŒ‰å±‚è®¿é—®èŠ‚ç‚¹
1. ä½ç½®ç¼–å·æŠ€å·§ - é€šè¿‡æ»¡äºŒå‰æ ‘æ€§è´¨è®¡ç®—å®½åº¦
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - O(n)æ—¶é—´è®¿é—®æ‰€æœ‰èŠ‚ç‚¹
1. ç©ºé—´å¤æ‚åº¦å¯æ§ - O(n)ç©ºé—´å­˜å‚¨é˜Ÿåˆ—
1. å®ç°æ¸…æ™°ç›´è§‚ - ä»£ç é€»è¾‘æ˜“äºç†è§£

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆBFS+ä½ç½®ç¼–å·æ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å±‚åºéå†çš„åŸºç¡€ï¼šæœ€å¤§å®½åº¦éœ€è¦æŒ‰å±‚è®¡ç®—
1. BFSçš„ç‰¹æ€§ï¼šæŒ‰å±‚è®¿é—®èŠ‚ç‚¹ï¼Œä¸é¢˜ç›®è¦æ±‚å®Œå…¨åŒ¹é…
1. ä½ç½®ç¼–å·ï¼šåˆ©ç”¨æ»¡äºŒå‰æ ‘æ€§è´¨ï¼Œé€šè¿‡ç¼–å·è®¡ç®—å®½åº¦
1. å¤ç”¨æ€§å¼ºï¼šåŸºäº102é¢˜çš„BFSå®ç°
1. æ€§èƒ½ä¼˜å¼‚ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡ï¼Œæ— é‡å¤è®¡ç®—

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•                 | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                       |
| -------------------- | -------- | ---------- | ---------- | -------- | -------------------------- |
| BFS+ä½ç½®ç¼–å·ï¼ˆæœ¬è§£ï¼‰ | âœ…       | O(n)       | O(n)       | ä¸­       | é¢è¯•é¦–é€‰ï¼Œé€»è¾‘æ¸…æ™°         |
| DFS+ä½ç½®ç¼–å·         | âœ…       | O(n)       | O(h)       | ä¸­       | ç©ºé—´å¤æ‚åº¦æ›´ä¼˜ï¼Œä½†å®ç°å¤æ‚ |
| BFS+åæ ‡æ³•           | âœ…       | O(n)       | O(n)       | ä¸­       | éœ€è¦é¢å¤–å­˜å‚¨åæ ‡           |
| é€’å½’+å±‚æ•°è®°å½•        | âŒ       | -          | -          | é«˜       | éš¾ä»¥è®¡ç®—å®½åº¦               |

> BFS+ä½ç½®ç¼–å·æ˜¯æœ€ç›´æ¥ã€æœ€æ˜“äºç†è§£çš„è§£å†³æ–¹æ¡ˆ

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. æ ‘ç»“æ„ï¼šé€‚ç”¨äºä»»ä½•äºŒå‰æ ‘
1. ç©ºæ ‘å¤„ç†ï¼šé¢˜ç›®ä¿è¯è‡³å°‘ä¸€ä¸ªèŠ‚ç‚¹
1. èŠ‚ç‚¹å€¼èŒƒå›´ï¼šé¢˜ç›®çº¦æŸå†…æ— å½±å“
1. å®½åº¦å®šä¹‰ï¼šåŸºäºæ»¡äºŒå‰æ ‘çš„ä½ç½®ç¼–å·

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. å¤ç”¨æ€§ï¼šåŸºäº102é¢˜çš„BFSå®ç°
1. æ€§èƒ½ï¼šæ¯å±‚å¤„ç†å®Œæ¯•åè®¡ç®—å®½åº¦
1. å¯è¯»æ€§ï¼šä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç»´æŠ¤
1. æ‰©å±•æ€§ï¼šå¯è½»æ¾æ‰©å±•åˆ°å…¶ä»–å®½åº¦è®¡ç®—åœºæ™¯

### æ€»ç»“

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ ä½ç½®ç¼–å·æ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ€ç»´æ¸…æ™°åº¦å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶å±•ç¤ºä¸åŒè¯­è¨€åœ¨é˜Ÿåˆ—æ“ä½œå’Œä½ç½®è®¡ç®—ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func widthOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

    maxWidth := 0
    // é˜Ÿåˆ—å­˜å‚¨èŠ‚ç‚¹åŠå…¶ä½ç½®ç¼–å·
    queue := []struct {
        node *TreeNode
        pos  int
    }{{root, 0}}  // æ ¹èŠ‚ç‚¹ä½ç½®ç¼–å·ä¸º0

    for len(queue) > 0 {
        levelSize := len(queue)
        // å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
        leftPos := queue[0].pos
        // å½“å‰å±‚æœ€å³èŠ‚ç‚¹çš„ä½ç½®
        rightPos := queue[levelSize-1].pos
        // è®¡ç®—å½“å‰å±‚å®½åº¦
        currentWidth := rightPos - leftPos + 1
        if currentWidth > maxWidth {
            maxWidth = currentWidth
        }

        // å¤„ç†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < levelSize; i++ {
            nodeWithPos := queue[0]
            queue = queue[1:]

            // è®¡ç®—å­èŠ‚ç‚¹çš„ä½ç½®ç¼–å·
            if nodeWithPos.node.Left != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Left, 2 * nodeWithPos.pos})
            }
            if nodeWithPos.node.Right != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Right, 2*nodeWithPos.pos + 1})
            }
        }
    }

    return maxWidth
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. åˆå§‹åŒ–æ£€æŸ¥ï¼š`if root == nil` - è™½ç„¶é¢˜ç›®ä¿è¯è‡³å°‘ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½†ä¿æŒè‰¯å¥½ä¹ æƒ¯
1. æœ€å¤§å®½åº¦å­˜å‚¨ï¼š`maxWidth` - è®°å½•å…¨å±€æœ€å¤§å®½åº¦
1. é˜Ÿåˆ—åˆå§‹åŒ–ï¼šå­˜å‚¨èŠ‚ç‚¹åŠå…¶ä½ç½®ç¼–å·ï¼Œæ ¹èŠ‚ç‚¹ç¼–å·ä¸º0
1. å±‚çº§å¾ªç¯ï¼š`for len(queue) > 0` - é˜Ÿåˆ—éç©ºæ—¶ç»§ç»­éå†
1. å±‚å®½åº¦è®¡ç®—ï¼š
   - `leftPos` - å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹ä½ç½®
   - `rightPos` - å½“å‰å±‚æœ€å³èŠ‚ç‚¹ä½ç½®
   - `currentWidth = rightPos - leftPos + 1` - è®¡ç®—å½“å‰å±‚å®½åº¦
1. æ›´æ–°æœ€å¤§å®½åº¦ï¼š`if currentWidth > maxWidth`
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å·¦å­èŠ‚ç‚¹ç¼–å·ï¼š`2 * pos`
   - å³å­èŠ‚ç‚¹ç¼–å·ï¼š`2 * pos + 1`
   - ç¬¦åˆæ»¡äºŒå‰æ ‘çš„ä½ç½®ç¼–å·è§„åˆ™

è®¾è®¡åŠ¨æœºï¼š

- ä½¿ç”¨ç»“æ„ä½“å­˜å‚¨èŠ‚ç‚¹å’Œä½ç½®ï¼Œæ¸…æ™°æ˜äº†
- åˆ©ç”¨æ»¡äºŒå‰æ ‘æ€§è´¨è®¡ç®—ä½ç½®ç¼–å·
- æ¯å±‚å¼€å§‹æ—¶è®¡ç®—å®½åº¦ï¼Œç¡®ä¿åŠæ—¶æ›´æ–°æœ€å¤§å€¼
- ä¿æŒBFSçš„å±‚åºéå†ç‰¹æ€§

### B. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        max_width = 0
        # é˜Ÿåˆ—å­˜å‚¨èŠ‚ç‚¹åŠå…¶ä½ç½®ç¼–å·
        queue = deque([(root, 0)])  # (node, position)

        while queue:
            level_size = len(queue)
            # å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
            left_pos = queue[0][1]
            # å½“å‰å±‚æœ€å³èŠ‚ç‚¹çš„ä½ç½®
            right_pos = queue[-1][1]
            # è®¡ç®—å½“å‰å±‚å®½åº¦
            current_width = right_pos - left_pos + 1
            max_width = max(max_width, current_width)

            # å¤„ç†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
            for _ in range(level_size):
                node, pos = queue.popleft()

                if node.left:
                    queue.append((node.left, 2 * pos))
                if node.right:
                    queue.append((node.right, 2 * pos + 1))

        return max_width
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if not root` - Pythoné£æ ¼çš„ç©ºæ£€æŸ¥
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`deque` - é«˜æ•ˆå‡ºé˜Ÿå…¥é˜Ÿ
1. å…ƒç»„å­˜å‚¨ï¼š`(node, pos)` - å­˜å‚¨èŠ‚ç‚¹å’Œä½ç½®ç¼–å·
1. å±‚å®½åº¦è®¡ç®—ï¼š
   - `left_pos = queue[0][1]` - æœ€å·¦èŠ‚ç‚¹ä½ç½®
   - `right_pos = queue[-1][1]` - æœ€å³èŠ‚ç‚¹ä½ç½®
   - `current_width = right_pos - left_pos + 1`
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å·¦å­èŠ‚ç‚¹ï¼š`2 * pos`
   - å³å­èŠ‚ç‚¹ï¼š`2 * pos + 1`

Pythonç‰¹æ€§ï¼š

- ä½¿ç”¨`deque`æé«˜å‡ºé˜Ÿæ•ˆç‡
- å…ƒç»„å­˜å‚¨èŠ‚ç‚¹å’Œä½ç½®ï¼Œç®€æ´é«˜æ•ˆ
- ä»£ç ç®€æ´æ˜“è¯»

### C. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function widthOfBinaryTree(root: TreeNode | null): number {
    if (!root) {
        return 0;
    }

    let maxWidth = 0;
    // é˜Ÿåˆ—å­˜å‚¨èŠ‚ç‚¹åŠå…¶ä½ç½®ç¼–å·
    const queue: Array<[TreeNode, number]> = [[root, 0]];

    while (queue.length > 0) {
        const levelSize = queue.length;
        // å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
        const leftPos = queue[0][1];
        // å½“å‰å±‚æœ€å³èŠ‚ç‚¹çš„ä½ç½®
        const rightPos = queue[levelSize - 1][1];
        // è®¡ç®—å½“å‰å±‚å®½åº¦
        const currentWidth = rightPos - leftPos + 1;
        maxWidth = Math.max(maxWidth, currentWidth);

        // å¤„ç†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
        for (let i = 0; i < levelSize; i++) {
            const [node, pos] = queue.shift()!;

            if (node.left) {
                queue.push([node.left, 2 * pos]);
            }
            if (node.right) {
                queue.push([node.right, 2 * pos + 1]);
            }
        }
    }

    return maxWidth;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if (!root)` - TypeScripté£æ ¼çš„ç©ºæ£€æŸ¥
1. ç±»å‹å®šä¹‰ï¼š`Array<[TreeNode, number]>` - æ˜ç¡®é˜Ÿåˆ—å…ƒç´ ç±»å‹
1. æ•°ç»„å­˜å‚¨ï¼š`[node, pos]` - å­˜å‚¨èŠ‚ç‚¹å’Œä½ç½®ç¼–å·
1. å±‚å®½åº¦è®¡ç®—ï¼š
   - `leftPos = queue[0][1]` - æœ€å·¦èŠ‚ç‚¹ä½ç½®
   - `rightPos = queue[levelSize - 1][1]` - æœ€å³èŠ‚ç‚¹ä½ç½®
   - `currentWidth = rightPos - leftPos + 1`
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å·¦å­èŠ‚ç‚¹ï¼š`2 * pos`
   - å³å­èŠ‚ç‚¹ï¼š`2 * pos + 1`

TypeScriptç‰¹æ€§ï¼š

- ç±»å‹æ³¨è§£å¢å¼ºä»£ç å®‰å…¨æ€§
- éç©ºæ–­è¨€ç¡®ä¿ç±»å‹æ­£ç¡®
- æ•°ç»„æ“ä½œä¸JavaScriptä¸€è‡´

æ³¨æ„ï¼šTypeScriptçš„`shift()`æ“ä½œæ˜¯O(n)æ—¶é—´ï¼Œåœ¨å¤§è§„æ¨¡æ•°æ®æ—¶æ€§èƒ½è¾ƒå·®

### D. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::VecDeque;

impl Solution {
    pub fn width_of_binary_tree(root: Option<Box<TreeNode>>) -> i32 {
        let mut max_width = 0;
        let mut queue = VecDeque::new();

        // å¤„ç†æ ¹èŠ‚ç‚¹
        if let Some(node) = root {
            queue.push_back((node, 0));
        }

        while !queue.is_empty() {
            let level_size = queue.len();
            // å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
            let left_pos = queue.front().unwrap().1;
            // å½“å‰å±‚æœ€å³èŠ‚ç‚¹çš„ä½ç½®
            let right_pos = queue.back().unwrap().1;
            // è®¡ç®—å½“å‰å±‚å®½åº¦
            let current_width = right_pos - left_pos + 1;
            max_width = max_width.max(current_width);

            // å¤„ç†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
            for _ in 0..level_size {
                if let Some((node, pos)) = queue.pop_front() {
                    if let Some(left) = node.left {
                        queue.push_back((left, 2 * pos));
                    }
                    if let Some(right) = node.right {
                        queue.push_back((right, 2 * pos + 1));
                    }
                }
            }
        }

        max_width
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. åˆå§‹åŒ–ï¼š`max_width` - è®°å½•æœ€å¤§å®½åº¦
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`VecDeque` - é«˜æ•ˆåŒç«¯é˜Ÿåˆ—
1. å…ƒç»„å­˜å‚¨ï¼š`(node, pos)` - å­˜å‚¨èŠ‚ç‚¹å’Œä½ç½®ç¼–å·
1. å±‚å®½åº¦è®¡ç®—ï¼š
   - `left_pos = queue.front().unwrap().1` - æœ€å·¦èŠ‚ç‚¹ä½ç½®
   - `right_pos = queue.back().unwrap().1` - æœ€å³èŠ‚ç‚¹ä½ç½®
   - `current_width = right_pos - left_pos + 1`
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å·¦å­èŠ‚ç‚¹ï¼š`2 * pos`
   - å³å­èŠ‚ç‚¹ï¼š`2 * pos + 1`
1. æ¨¡å¼åŒ¹é…ï¼šä½¿ç”¨`if let`å’Œ`Some`å¤„ç†Optionç±»å‹

Rustç‰¹æ€§ï¼š

- æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨
- æ¨¡å¼åŒ¹é…ç¡®ä¿ä»£ç å®‰å…¨
- é«˜æ•ˆçš„å†…å­˜ç®¡ç†
- ç±»å‹å®‰å…¨ä¿è¯

### E. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é˜Ÿåˆ—å®ç° | ä½ç½®è®¡ç®— | ç‰¹ç‚¹                  |
| ---------- | ---------- | ---------- | -------- | -------- | --------------------- |
| Go         | O(n)       | O(n)       | åˆ‡ç‰‡     | ç»“æ„ä½“   | ç®€å•é«˜æ•ˆï¼Œé¢è¯•é¦–é€‰    |
| Python     | O(n)       | O(n)       | deque    | å…ƒç»„     | ç®€æ´é«˜æ•ˆï¼Œä»£ç ç®€æ´    |
| TypeScript | O(nÂ²)      | O(n)       | æ•°ç»„     | å…ƒç»„     | shift()æ€§èƒ½å·®ï¼Œå¯ä¼˜åŒ– |
| Rust       | O(n)       | O(n)       | VecDeque | å…ƒç»„     | å†…å­˜å®‰å…¨ï¼Œæ€§èƒ½æœ€ä¼˜    |

æ³¨æ„ï¼šTypeScriptçš„æ•°ç»„shift()æ“ä½œæ˜¯O(n)æ—¶é—´ï¼Œåœ¨å¤§è§„æ¨¡æ•°æ®æ—¶æ€§èƒ½è¾ƒå·®ï¼Œå»ºè®®ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```text
å‡½æ•° widthOfBinaryTree(root):
    å¦‚æœ root ä¸ºç©º:
        è¿”å› 0

    maxWidth = 0
    queue = é˜Ÿåˆ—([(root, 0)])  // (èŠ‚ç‚¹, ä½ç½®ç¼–å·)

    å½“ queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        leftPos = queue[0].ä½ç½®
        rightPos = queue[levelSize-1].ä½ç½®
        currentWidth = rightPos - leftPos + 1
        maxWidth = max(maxWidth, currentWidth)

        å¯¹äº i ä» 0 åˆ° levelSize-1:
            (node, pos) = queue å‡ºé˜Ÿ

            å¦‚æœ node.left ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ (node.left, 2 * pos)
            å¦‚æœ node.right ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ (node.right, 2 * pos + 1)

    è¿”å› maxWidth
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: widthOfBinaryTree(root)] --> B{root ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› 0]
    B -- å¦ --> D[åˆå§‹åŒ– maxWidth å’Œ queue]
    D --> E[queue å…¥é˜Ÿ (root, 0)]
    E --> F{queue ä¸ºç©º?}
    F -- æ˜¯ --> G[è¿”å› maxWidth]
    F -- å¦ --> H[levelSize = queue é•¿åº¦]
    H --> I[leftPos = queue[0].ä½ç½®]
    I --> J[rightPos = queue[levelSize-1].ä½ç½®]
    J --> K[currentWidth = rightPos - leftPos + 1]
    K --> L[maxWidth = max(maxWidth, currentWidth)]
    L --> M[i = 0]
    M --> N{i < levelSize?}
    N -- æ˜¯ --> O[(node, pos) = queue å‡ºé˜Ÿ]
    O --> P{node.left éç©º?}
    P -- æ˜¯ --> Q[queue å…¥é˜Ÿ (node.left, 2*pos)]
    P -- å¦ --> R{node.right éç©º?}
    Q --> R
    R -- æ˜¯ --> S[queue å…¥é˜Ÿ (node.right, 2*pos+1)]
    R -- å¦ --> T[i = i + 1]
    S --> T
    T --> N
    N -- å¦ --> F
```

### çŠ¶æ€è½¬ç§»å›¾ï¼ˆç¤ºä¾‹ï¼‰

```mermaid
graph LR
    subgraph "æ‰§è¡Œè¿‡ç¨‹: root = [1,3,2,5,3,null,9]"
        direction TB
        S1["ç¬¬0å±‚: queue=[(1,0)]"] --> S1a["leftPos=0, rightPos=0"]
        S1a --> S1b["currentWidth=1, maxWidth=1"]
        S1b --> S1c["å¤„ç†èŠ‚ç‚¹1, å…¥é˜Ÿ(3,0), (2,1)"]
        S1c --> S1d["queue=[(3,0),(2,1)]"]

        S1d --> S2["ç¬¬1å±‚: queue=[(3,0),(2,1)]"]
        S2 --> S2a["leftPos=0, rightPos=1"]
        S2a --> S2b["currentWidth=2, maxWidth=2"]
        S2b --> S2c["å¤„ç†èŠ‚ç‚¹3, å…¥é˜Ÿ(5,0)"]
        S2c --> S2d["å¤„ç†èŠ‚ç‚¹2, å…¥é˜Ÿ(9,3)"]
        S2d --> S2e["queue=[(5,0),(9,3)]"]

        S2e --> S3["ç¬¬2å±‚: queue=[(5,0),(9,3)]"]
        S3 --> S3a["leftPos=0, rightPos=3"]
        S3a --> S3b["currentWidth=4, maxWidth=4"]
        S3b --> S3c["å¤„ç†èŠ‚ç‚¹5, æ— å­èŠ‚ç‚¹"]
        S3c --> S3d["å¤„ç†èŠ‚ç‚¹9, æ— å­èŠ‚ç‚¹"]
        S3d --> S3e["queue=[]"]

        S3e --> S4["ç»“æŸ: maxWidth=4"]
    end

    %% æ ·å¼è®¾ç½®
    style S1 fill:#e6f3ff,stroke:#333
    style S2 fill:#e6f3ff,stroke:#333
    style S3 fill:#e6f3ff,stroke:#333
    style S4 fill:#6f9,stroke:#333
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: root = [1,3,2,5,3,null,9]

#### è¯¦ç»†æ‰§è¡Œæ­¥éª¤

| å±‚æ•° | queueçŠ¶æ€                    | leftPos | rightPos | currentWidth | maxWidth | è¯´æ˜                   |
| ---- | ---------------------------- | ------- | -------- | ------------ | -------- | ---------------------- |
| 0    | [(1,0)]                      | 0       | 0        | 1            | 1        | æ ¹èŠ‚ç‚¹1ï¼Œä½ç½®0         |
| 1    | [(3,0),(2,1)]                | 0       | 1        | 2            | 2        | èŠ‚ç‚¹3ä½ç½®0ï¼ŒèŠ‚ç‚¹2ä½ç½®1 |
| 2    | [(5,0),(3,1),(null,2),(9,3)] | 0       | 3        | 4            | 4        | èŠ‚ç‚¹5ä½ç½®0ï¼ŒèŠ‚ç‚¹9ä½ç½®3 |
| 3    | []                           | -       | -        | -            | 4        | é˜Ÿåˆ—ä¸ºç©ºï¼Œç»“æŸ         |

æ³¨æ„ï¼šåœ¨å®é™…å®ç°ä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šå°†nullèŠ‚ç‚¹å…¥é˜Ÿï¼Œå› æ­¤ç¬¬2å±‚queueçŠ¶æ€ä¸º[(5,0),(9,3)]

#### ä½ç½®ç¼–å·ç¤ºæ„å›¾

```
        1(0)
       /     \
    3(0)     2(1)
   /         \
5(0)         9(3)
```

- ç¬¬0å±‚ï¼š1(0) â†’ å®½åº¦ = 0 - 0 + 1 = 1
- ç¬¬1å±‚ï¼š3(0), 2(1) â†’ å®½åº¦ = 1 - 0 + 1 = 2
- ç¬¬2å±‚ï¼š5(0), 9(3) â†’ å®½åº¦ = 3 - 0 + 1 = 4

#### æœ€ç»ˆç»“æœ

```text
4
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func widthOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

    maxWidth := 0
    queue := []struct {
        node *TreeNode
        pos  int
    }{{root, 0}}

    for len(queue) > 0 {
        levelSize := len(queue)
        leftPos := queue[0].pos
        rightPos := queue[levelSize-1].pos
        currentWidth := rightPos - leftPos + 1
        if currentWidth > maxWidth {
            maxWidth = currentWidth
        }

        for i := 0; i < levelSize; i++ {
            nodeWithPos := queue[0]
            queue = queue[1:]

            if nodeWithPos.node.Left != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Left, 2 * nodeWithPos.pos})
            }
            if nodeWithPos.node.Right != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Right, 2*nodeWithPos.pos + 1})
            }
        }
    }

    return maxWidth
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®å±‚åºæ•°ç»„æ„å»ºäºŒå‰æ ‘
func buildTree(nums []interface{}) *TreeNode {
    if len(nums) == 0 || nums[0] == nil {
        return nil
    }

    root := &TreeNode{Val: nums[0].(int)}
    queue := []*TreeNode{root}
    i := 1

    for len(queue) > 0 && i < len(nums) {
        node := queue[0]
        queue = queue[1:]

        if i < len(nums) && nums[i] != nil {
            node.Left = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Left)
        }
        i++

        if i < len(nums) && nums[i] != nil {
            node.Right = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Right)
        }
        i++
    }

    return root
}

func main() {
    // Test Case 1
    nums1 := []interface{}{1, 3, 2, 5, 3, nil, 9}
    tree1 := buildTree(nums1)
    fmt.Printf("Test Case 1: %d\n", widthOfBinaryTree(tree1)) // 4

    // Test Case 2
    nums2 := []interface{}{1, 3, 2, 5, nil, nil, 9, 6, nil, 7}
    tree2 := buildTree(nums2)
    fmt.Printf("Test Case 2: %d\n", widthOfBinaryTree(tree2)) // 7

    // Test Case 3
    nums3 := []interface{}{1, 3, 2, 5}
    tree3 := buildTree(nums3)
    fmt.Printf("Test Case 3: %d\n", widthOfBinaryTree(tree3)) // 2
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

æœ¬ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦

- æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ï¼šO(n)
- é˜Ÿåˆ—æ“ä½œï¼šæ¯ä¸ªèŠ‚ç‚¹å…¥é˜Ÿå‡ºé˜Ÿå„ä¸€æ¬¡ï¼ŒO(1)æ“ä½œ Ã— n = O(n)
- å±‚çº§å¤„ç†ï¼šå¤–å±‚å¾ªç¯æ¬¡æ•°ç­‰äºæ ‘çš„é«˜åº¦hï¼Œå†…å±‚å¾ªç¯æ€»æ¬¡æ•°ä¸ºn
- å®½åº¦è®¡ç®—ï¼šæ¯å±‚O(1)æ—¶é—´è®¡ç®—å®½åº¦
- æ€»æ—¶é—´ï¼šO(n) + O(n) + O(h) = O(n)

#### B. ç©ºé—´å¤æ‚åº¦

- é˜Ÿåˆ—å­˜å‚¨ï¼šæœ€åæƒ…å†µä¸‹å­˜å‚¨æœ€åä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹ï¼ŒO(n/2) â‰ˆ O(n)
- å…¶ä»–å˜é‡ï¼šO(1) - å•ä¸ªæ•´æ•°å˜é‡
- æ€»ç©ºé—´ï¼šO(n) + O(1) = O(n)

#### C. æœ€å¥½/å¹³å‡/æœ€åæƒ…å†µåˆ†æ

| æƒ…å†µ           | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                            |
| -------------- | ---------- | ---------- | ------------------------------- |
| æœ€å¥½ï¼ˆå¹³è¡¡æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸ºn/2               |
| å¹³å‡           | O(n)       | O(n)       | å…¸å‹äºŒå‰æ ‘                      |
| æœ€åï¼ˆé€€åŒ–æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸º1ï¼ˆæ¯å±‚ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ |

#### D. å¸¸æ•°å› å­åˆ†æ

- é˜Ÿåˆ—æ“ä½œå¼€é”€ï¼šå…¥é˜Ÿå‡ºé˜Ÿçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- ä½ç½®è®¡ç®—å¼€é”€ï¼šç®€å•çš„ä¹˜æ³•å’ŒåŠ æ³•æ“ä½œ
- è¯­è¨€ç‰¹æ€§å½±å“ï¼š
  - Goåˆ‡ç‰‡æ“ä½œé«˜æ•ˆ
  - Python dequeé«˜æ•ˆ
  - TypeScriptæ•°ç»„shift()ä½æ•ˆï¼ˆå¯ä¼˜åŒ–ï¼‰
  - Rust VecDequeé«˜æ•ˆä¸”å®‰å…¨

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆï¼šé˜Ÿåˆ—æ“ä½œçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- ä¼˜åŒ–æ–¹å‘ï¼š
  - ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—äº¤æ›¿å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚
  - é¢„åˆ†é…å†…å­˜ç©ºé—´ï¼ˆå¦‚Rustå®ç°ï¼‰
  - TypeScriptä¸­ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“
  - ä½ç½®ç¼–å·ä½¿ç”¨æ›´å¤§çš„æ•°æ®ç±»å‹ï¼ˆå¦‚uint64ï¼‰é˜²æ­¢æº¢å‡º

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"å±‚çº§å®½åº¦è®¡ç®—"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. BFSä¸ä½ç½®ç¼–å·çš„ç»“åˆ
1. æ»¡äºŒå‰æ ‘æ€§è´¨çš„åº”ç”¨
1. å®½åº¦è®¡ç®—æŠ€å·§
1. å¯æ‰©å±•åˆ°å¤šç§å±‚çº§ç»“æ„

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- å±‚åºéå†çš„å˜ä½“ï¼šæœ€å¤§å®½åº¦è®¡ç®— = å±‚åºéå† + ä½ç½®ç¼–å·
- ä½ç½®ç¼–å·ï¼šåˆ©ç”¨æ»¡äºŒå‰æ ‘æ€§è´¨ï¼Œé€šè¿‡ç¼–å·è®¡ç®—å®½åº¦
- å®½åº¦è®¡ç®—ï¼šæ¯å±‚æœ€å³ä½ç½® - æœ€å·¦ä½ç½® + 1
- å¤ç”¨æ€§ï¼šç›´æ¥åŸºäº102é¢˜çš„BFSå®ç°
- æ‰©å±•æ€§ï¼šå¯åº”ç”¨äºå…¶ä»–å®½åº¦è®¡ç®—åœºæ™¯

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®                   | æ ¸å¿ƒæ€æƒ³               | åŒ¹é…æ¨¡å¼ |
| ---- | ---------------------- | ---------------------- | -------- |
| 662  | æœ¬é¢˜                   | äºŒå‰æ ‘æœ€å¤§å®½åº¦         | æ ¸å¿ƒæ¨¡å¼ |
| 102  | äºŒå‰æ ‘çš„å±‚åºéå†       | æ­£å¸¸å±‚åºéå†           | åŸºç¡€æ¨¡å¼ |
| 103  | äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå† | å±‚åºéå†å˜ä½“           | æ¨¡å¼å˜ä½“ |
| 107  | äºŒå‰æ ‘çš„å±‚åºéå† II    | è‡ªåº•å‘ä¸Šå±‚åºéå†       | æ¨¡å¼å˜ä½“ |
| 199  | äºŒå‰æ ‘çš„å³è§†å›¾         | å±‚åºéå†å–æ¯å±‚æœ€åä¸€ä¸ª | æ¨¡å¼åº”ç”¨ |
| 637  | äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼       | å±‚åºéå†è®¡ç®—å¹³å‡å€¼     | æ¨¡å¼åº”ç”¨ |

#### C. æ¨¡å¼æ³›åŒ–

- Nå‰æ ‘å®½åº¦ï¼šNå‰æ ‘çš„æœ€å¤§å®½åº¦è®¡ç®—
- å›¾å®½åº¦ï¼šå›¾çš„å±‚çº§æœ€å¤§å®½åº¦è®¡ç®—
- ç»„ç»‡ç»“æ„ï¼šå…¬å¸ç»„ç»‡ç»“æ„çš„æœ€å¤§å®½åº¦
- æ–‡ä»¶ç³»ç»Ÿï¼šç›®å½•æ ‘çš„æœ€å¤§å®½åº¦
- ç½‘ç»œæ‹“æ‰‘ï¼šç½‘ç»œèŠ‚ç‚¹çš„æœ€å¤§å±‚çº§å®½åº¦

#### D. å·¥ä¸šåº”ç”¨

- ç»„ç»‡ç»“æ„åˆ†æï¼šè®¡ç®—å…¬å¸å„å±‚çº§çš„æœ€å¤§å®½åº¦
- æ–‡ä»¶ç³»ç»Ÿä¼˜åŒ–ï¼šåˆ†æç›®å½•æ ‘çš„å®½åº¦åˆ†å¸ƒ
- ç½‘ç»œæ‹“æ‰‘è®¾è®¡ï¼šè®¡ç®—ç½‘ç»œèŠ‚ç‚¹çš„å±‚çº§å®½åº¦
- æ¸¸æˆåœºæ™¯è®¾è®¡ï¼šè®¡ç®—åœºæ™¯æ ‘çš„æœ€å¤§å®½åº¦
- æ•°æ®åº“ç´¢å¼•ï¼šåˆ†æBæ ‘çš„å®½åº¦ç‰¹æ€§

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆé€‰æ‹©ä½ç½®ç¼–å·è€Œä¸æ˜¯åæ ‡æ³•ï¼Ÿ
   - ä½ç½®ç¼–å·åˆ©ç”¨æ»¡äºŒå‰æ ‘æ€§è´¨ï¼Œè®¡ç®—ç®€å•
   - åæ ‡æ³•éœ€è¦é¢å¤–å­˜å‚¨åæ ‡ä¿¡æ¯ï¼Œç©ºé—´å¤æ‚åº¦é«˜
   - ä½ç½®ç¼–å·å¯ä»¥ç›´æ¥è®¡ç®—å®½åº¦ï¼Œæ— éœ€é¢å¤–å¤„ç†

1. ä¸ºä»€ä¹ˆå¿…é¡»ä¿æŒå­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºï¼Ÿ
   - å­èŠ‚ç‚¹å…¥é˜Ÿé¡ºåºå†³å®šäº†ä½ç½®ç¼–å·çš„æ­£ç¡®æ€§
   - å¿…é¡»ä¿æŒå…ˆå·¦åå³çš„å…¥é˜Ÿé¡ºåº
   - å¦åˆ™ä¼šå¯¼è‡´ä½ç½®ç¼–å·é”™è¯¯ï¼Œå®½åº¦è®¡ç®—ä¸å‡†ç¡®

1. ä½ç½®ç¼–å·çš„æ•°å­¦åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ
   - å¯¹äºæ»¡äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹içš„å·¦å­èŠ‚ç‚¹ç¼–å·ä¸º2iï¼Œå³å­èŠ‚ç‚¹ç¼–å·ä¸º2i+1
   - è¿™ä¸ªæ€§è´¨å¯ä»¥æ¨å¹¿åˆ°ä»»ä½•äºŒå‰æ ‘
   - é€šè¿‡è¿™ä¸ªæ€§è´¨å¯ä»¥è®¡ç®—èŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿï¼š

1. å¯¹BFSå’Œä½ç½®ç¼–å·çš„ç†è§£
1. å¤æ‚åº¦åˆ†æä¸ä¼˜åŒ–èƒ½åŠ›
1. ä»åŸºç¡€åˆ°å˜ä½“çš„æ‰©å±•èƒ½åŠ›
1. ä¸åŒå®ç°æ–¹å¼çš„æƒè¡¡

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆé€‰æ‹©BFSè€Œä¸æ˜¯DFSï¼Ÿ

â†’ æ ‡å‡†: BFSå¤©ç„¶æŒ‰å±‚è®¿é—®ï¼Œä¸å®½åº¦è®¡ç®—å®Œå…¨åŒ¹é…
â†’ åŠ åˆ†: DFSéœ€è¦é¢å¤–è®°å½•å±‚æ•°å’Œä½ç½®ï¼Œå®ç°å¤æ‚

#### Q2: ä½ç½®ç¼–å·çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ

â†’ æ ‡å‡†: åˆ©ç”¨æ»¡äºŒå‰æ ‘æ€§è´¨ï¼Œå·¦å­èŠ‚ç‚¹=2iï¼Œå³å­èŠ‚ç‚¹=2i+1
â†’ åŠ åˆ†: è¯´æ˜è¿™ä¸ªæ€§è´¨å¯ä»¥æ¨å¹¿åˆ°ä»»ä½•äºŒå‰æ ‘ï¼Œç”¨äºè®¡ç®—èŠ‚ç‚¹é—´è·ç¦»

#### Q3: å¦‚ä½•å¤„ç†ä½ç½®ç¼–å·æº¢å‡ºçš„é—®é¢˜ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨æ›´å¤§çš„æ•°æ®ç±»å‹ï¼ˆå¦‚uint64ï¼‰
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°ï¼Œæˆ–ä½¿ç”¨ä½ç½®å·®å€¼æ³•

```go
// ä½ç½®å·®å€¼æ³•ï¼šé¿å…æº¢å‡º
func widthOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

    maxWidth := 0
    queue := []struct {
        node *TreeNode
        pos  int
    }{{root, 0}}

    for len(queue) > 0 {
        levelSize := len(queue)
        // å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
        leftPos := queue[0].pos
        // é‡æ–°ç¼–å·ï¼Œé¿å…æº¢å‡º
        for i := 0; i < levelSize; i++ {
            queue[i].pos -= leftPos
        }

        rightPos := queue[levelSize-1].pos
        currentWidth := rightPos + 1
        if currentWidth > maxWidth {
            maxWidth = currentWidth
        }

        for i := 0; i < levelSize; i++ {
            nodeWithPos := queue[0]
            queue = queue[1:]

            if nodeWithPos.node.Left != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Left, 2 * nodeWithPos.pos})
            }
            if nodeWithPos.node.Right != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Right, 2*nodeWithPos.pos + 1})
            }
        }
    }

    return maxWidth
}
```

#### Q4: è¿™ä¸ªç®—æ³•å’Œ102é¢˜æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

â†’ æ ‡å‡†: 102é¢˜æ˜¯æ­£å¸¸å±‚åºéå†ï¼Œæœ¬é¢˜è®¡ç®—æ¯å±‚æœ€å¤§å®½åº¦
â†’ åŠ åˆ†: æœ¬é¢˜åœ¨102é¢˜åŸºç¡€ä¸Šå¢åŠ äº†ä½ç½®ç¼–å·å’Œå®½åº¦è®¡ç®—

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°DFSç‰ˆæœ¬çš„æœ€å¤§å®½åº¦è®¡ç®—ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨DFSéå†ï¼Œè®°å½•æ¯å±‚æœ€å·¦å’Œæœ€å³ä½ç½®
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// DFSå®ç°
func widthOfBinaryTreeDFS(root *TreeNode) int {
    if root == nil {
        return 0
    }

    maxWidth := 0
    // è®°å½•æ¯å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
    leftPositions := make(map[int]int)

    var dfs func(*TreeNode, int, int)
    dfs = func(node *TreeNode, level, pos int) {
        if node == nil {
            return
        }

        // è®°å½•å½“å‰å±‚æœ€å·¦èŠ‚ç‚¹çš„ä½ç½®
        if _, exists := leftPositions[level]; !exists {
            leftPositions[level] = pos
        }

        // è®¡ç®—å½“å‰å±‚å®½åº¦
        currentWidth := pos - leftPositions[level] + 1
        if currentWidth > maxWidth {
            maxWidth = currentWidth
        }

        // é€’å½’å¤„ç†å­èŠ‚ç‚¹
        dfs(node.Left, level+1, 2*pos)
        dfs(node.Right, level+1, 2*pos+1)
    }

    dfs(root, 0, 0)
    return maxWidth
}
```

#### Q2: å¦‚ä½•å®ç°Nå‰æ ‘çš„æœ€å¤§å®½åº¦è®¡ç®—ï¼Ÿ

â†’ æ ‡å‡†: å¤ç”¨Nå‰æ ‘å±‚åºéå†é€»è¾‘ï¼Œå¢åŠ ä½ç½®ç¼–å·
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// Nå‰æ ‘èŠ‚ç‚¹å®šä¹‰
type Node struct {
    Val      int
    Children []*Node
}

func widthOfNAryTree(root *Node) int {
    if root == nil {
        return 0
    }

    maxWidth := 0
    queue := []struct {
        node *Node
        pos  int
    }{{root, 0}}

    for len(queue) > 0 {
        levelSize := len(queue)
        leftPos := queue[0].pos
        rightPos := queue[levelSize-1].pos
        currentWidth := rightPos - leftPos + 1
        if currentWidth > maxWidth {
            maxWidth = currentWidth
        }

        for i := 0; i < levelSize; i++ {
            nodeWithPos := queue[0]
            queue = queue[1:]

            // éå†æ‰€æœ‰å­èŠ‚ç‚¹
            for j, child := range nodeWithPos.node.Children {
                if child != nil {
                    // å­èŠ‚ç‚¹ä½ç½®ç¼–å·ï¼šçˆ¶èŠ‚ç‚¹ä½ç½® * å­èŠ‚ç‚¹æ•° + å­èŠ‚ç‚¹ç´¢å¼•
                    queue = append(queue, struct {
                        node *Node
                        pos  int
                    }{child, nodeWithPos.pos*len(nodeWithPos.node.Children) + j})
                }
            }
        }
    }

    return maxWidth
}
```

#### Q3: å¦‚ä½•ä¼˜åŒ–TypeScriptçš„å®ç°ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–åçš„ä»£ç 

```typescript
// ä¼˜åŒ–ç‰ˆï¼šä½¿ç”¨ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
function widthOfBinaryTreeOptimized(root: TreeNode | null): number {
  if (!root) return 0;

  let maxWidth = 0;
  let currentLevel: Array<[TreeNode, number]> = [[root, 0]];

  while (currentLevel.length > 0) {
    const leftPos = currentLevel[0][1];
    const rightPos = currentLevel[currentLevel.length - 1][1];
    const currentWidth = rightPos - leftPos + 1;
    maxWidth = Math.max(maxWidth, currentWidth);

    const nextLevel: Array<[TreeNode, number]> = [];
    for (const [node, pos] of currentLevel) {
      if (node.left) {
        nextLevel.push([node.left, 2 * pos]);
      }
      if (node.right) {
        nextLevel.push([node.right, 2 * pos + 1]);
      }
    }

    currentLevel = nextLevel;
  }

  return maxWidth;
}
```

#### Q4: å¦‚ä½•è®¡ç®—äºŒå‰æ ‘çš„æœ€å°å®½åº¦ï¼Ÿ

â†’ æ ‡å‡†: ä¿®æ”¹æœ€å¤§å®½åº¦ç®—æ³•ï¼Œè®¡ç®—æ¯å±‚æœ€å°å®½åº¦
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
func minWidthOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

    minWidth := math.MaxInt32
    queue := []struct {
        node *TreeNode
        pos  int
    }{{root, 0}}

    for len(queue) > 0 {
        levelSize := len(queue)
        leftPos := queue[0].pos
        rightPos := queue[levelSize-1].pos
        currentWidth := rightPos - leftPos + 1
        if currentWidth < minWidth {
            minWidth = currentWidth
        }

        for i := 0; i < levelSize; i++ {
            nodeWithPos := queue[0]
            queue = queue[1:]

            if nodeWithPos.node.Left != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Left, 2 * nodeWithPos.pos})
            }
            if nodeWithPos.node.Right != nil {
                queue = append(queue, struct {
                    node *TreeNode
                    pos  int
                }{nodeWithPos.node.Right, 2*nodeWithPos.pos + 1})
            }
        }
    }

    return minWidth
}
```

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®ï¼š

1. BFSä¸ä½ç½®ç¼–å·çš„ç»“åˆ
1. æ»¡äºŒå‰æ ‘æ€§è´¨çš„åº”ç”¨
1. å®½åº¦è®¡ç®—æŠ€å·§
1. å¤šè¯­è¨€å®ç°çš„å·®å¼‚

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹       | å£è¯€                       |
| ------------ | -------------------------- |
| æœ€å¤§å®½åº¦æ ¸å¿ƒ | å±‚åºéå† + ä½ç½®ç¼–å·        |
| ä½ç½®ç¼–å·è§„åˆ™ | å·¦å­=2i, å³å­=2i+1         |
| å®½åº¦è®¡ç®—å…¬å¼ | å³ä½ç½® - å·¦ä½ç½® + 1        |
| ç©ºæ ‘å¤„ç†     | é¢˜ç›®ä¿è¯è‡³å°‘ä¸€ä¸ªèŠ‚ç‚¹       |
| æ—¶é—´å¤æ‚åº¦   | O(n)éå† + O(1)è®¡ç®— = O(n) |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹     | è§¦å‘åœºæ™¯             | åº”å¯¹æªæ–½                     |
| ------------ | -------------------- | ---------------------------- |
| ä½ç½®ç¼–å·é”™è¯¯ | å­èŠ‚ç‚¹ä½ç½®è®¡ç®—é”™è¯¯   | ç¡®ä¿å·¦å­=2i, å³å­=2i+1       |
| å®½åº¦è®¡ç®—é”™è¯¯ | å¿˜è®°+1æˆ–ä½¿ç”¨é”™è¯¯å…¬å¼ | ä½¿ç”¨å³-å·¦+1å…¬å¼              |
| ç©ºæ ‘æœªå¤„ç†   | é¢˜ç›®ä¿è¯è‡³å°‘ä¸€ä¸ªèŠ‚ç‚¹ | ä¿æŒè‰¯å¥½ä¹ æƒ¯ï¼Œæ£€æŸ¥rootä¸ºç©º   |
| é˜Ÿåˆ—æ“ä½œé”™è¯¯ | åˆ‡ç‰‡è¶Šç•Œæˆ–å†…å­˜æ³„æ¼   | ç¡®ä¿å‡ºé˜Ÿå…¥é˜Ÿæ“ä½œæ­£ç¡®         |
| ä½ç½®æº¢å‡º     | å¤§æ ‘å¯¼è‡´ä½ç½®ç¼–å·æº¢å‡º | ä½¿ç”¨æ›´å¤§æ•°æ®ç±»å‹æˆ–ä½ç½®å·®å€¼æ³• |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯              | åº”ç”¨åœºæ™¯         |
| ------------------- | ---------------- |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ | æè¿°ç®—æ³•é€‰æ‹©     |
| ä½ç½®ç¼–å·            | è¯´æ˜å®½åº¦è®¡ç®—åŸç† |
| æ»¡äºŒå‰æ ‘æ€§è´¨        | è§£é‡Šä½ç½®ç¼–å·è§„åˆ™ |
| å±‚åºéå†å˜ä½“        | å‘½åç®—æ³•èŒƒå¼     |
| æ—¶é—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ       |
| ç©ºé—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ       |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: å±‚çº§å®½åº¦è®¡ç®—
â”œâ”€â”€ å¿…è¦æ¡ä»¶: BFS + ä½ç½®ç¼–å·
â”œâ”€â”€ æœ¬è´¨: å±‚åºéå† + æ»¡äºŒå‰æ ‘æ€§è´¨
â”œâ”€â”€ æ–¹æ³•: BFS + ä½ç½®ç¼–å·
â”‚   â”œâ”€â”€ é˜Ÿåˆ—åˆå§‹åŒ–: [(root, 0)]
â”‚   â”œâ”€â”€ å¤–å±‚å¾ªç¯: é˜Ÿåˆ—éç©º
â”‚   â”œâ”€â”€ å†…å±‚å¾ªç¯: å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
â”‚   â”œâ”€â”€ å®½åº¦è®¡ç®—: å³ä½ç½® - å·¦ä½ç½® + 1
â”‚   â”œâ”€â”€ ä½ç½®ç¼–å·: å·¦å­=2i, å³å­=2i+1
â”‚   â””â”€â”€ æœ€å¤§å€¼æ›´æ–°: æ¯å±‚ç»“æŸæ—¶æ›´æ–°
â”œâ”€â”€ ä¼˜åŒ–: ä½ç½®å·®å€¼æ³•ã€DFSå®ç°
â”œâ”€â”€ å˜ä½“: Nå‰æ ‘ã€æœ€å°å®½åº¦
â””â”€â”€ åº”ç”¨: ç»„ç»‡ç»“æ„ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œæ‹“æ‰‘
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆï¼ˆBFS+ä½ç½®ç¼–å·ï¼‰
å‡½æ•° widthOfBinaryTree(root):
    if root ä¸ºç©º: return 0
    maxWidth = 0
    queue = [(root, 0)]

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        leftPos = queue[0].ä½ç½®
        rightPos = queue[levelSize-1].ä½ç½®
        currentWidth = rightPos - leftPos + 1
        maxWidth = max(maxWidth, currentWidth)

        for i ä» 0 åˆ° levelSize-1:
            (node, pos) = queue å‡ºé˜Ÿ

            if node.left éç©º:
                queue å…¥é˜Ÿ (node.left, 2 * pos)
            if node.right éç©º:
                queue å…¥é˜Ÿ (node.right, 2 * pos + 1)

    return maxWidth

// ä¼˜åŒ–ç‰ˆï¼ˆä½ç½®å·®å€¼æ³•ï¼‰
å‡½æ•° widthOfBinaryTreeOptimized(root):
    if root ä¸ºç©º: return 0
    maxWidth = 0
    queue = [(root, 0)]

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        leftPos = queue[0].ä½ç½®
        // é‡æ–°ç¼–å·ï¼Œé¿å…æº¢å‡º
        for i ä» 0 åˆ° levelSize-1:
            queue[i].ä½ç½® -= leftPos

        rightPos = queue[levelSize-1].ä½ç½®
        currentWidth = rightPos + 1
        maxWidth = max(maxWidth, currentWidth)

        for i ä» 0 åˆ° levelSize-1:
            (node, pos) = queue å‡ºé˜Ÿ

            if node.left éç©º:
                queue å…¥é˜Ÿ (node.left, 2 * pos)
            if node.right éç©º:
                queue å…¥é˜Ÿ (node.right, 2 * pos + 1)

    return maxWidth
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³äºŒå‰æ ‘æœ€å¤§å®½åº¦ç›¸å…³é—®é¢˜ï¼Œå¹¶å±•ç°å¯¹æ ‘ç»“æ„éå†ç®—æ³•å’Œå®½åº¦è®¡ç®—æŠ€å·§çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
