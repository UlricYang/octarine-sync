# LeetCode 102 - äºŒå‰æ ‘çš„å±‚åºéå†

## 1. é¢˜ç›®æè¿°

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ å±‚åºéå†ã€‚ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰

### ç¤ºä¾‹ 1

```
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]
```

### ç¤ºä¾‹ 2

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[[1]]
```

### ç¤ºä¾‹ 3

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

### çº¦æŸæ¡ä»¶

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
- `-1000 <= Node.val <= 1000`

## 2. è§£æ³•åˆ†æï¼šå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. è‡ªç„¶åŒ¹é…å±‚åºéå† - BFSå¤©ç„¶æŒ‰å±‚è®¿é—®èŠ‚ç‚¹
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - O(n)æ—¶é—´è®¿é—®æ‰€æœ‰èŠ‚ç‚¹
1. ç©ºé—´å¤æ‚åº¦å¯æ§ - O(n)ç©ºé—´å­˜å‚¨ç»“æœ
1. å®ç°ç®€å•ç›´è§‚ - é˜Ÿåˆ—æ“ä½œæ¸…æ™°æ˜“æ‡‚

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆBFSæ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å±‚åºéå†çš„æœ¬è´¨ï¼šé€å±‚è®¿é—®ï¼Œæ¯å±‚ä»å·¦åˆ°å³
1. BFSçš„ç‰¹æ€§ï¼šæŒ‰è·ç¦»æ ¹èŠ‚ç‚¹çš„è·ç¦»ï¼ˆå±‚æ•°ï¼‰è®¿é—®èŠ‚ç‚¹
1. å®Œç¾åŒ¹é…ï¼šBFSçš„è®¿é—®é¡ºåºä¸å±‚åºéå†å®Œå…¨ä¸€è‡´
1. æ— å†—ä½™æ“ä½œï¼šæ¯ä¸ªèŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡ï¼Œæ— é‡å¤è®¡ç®—
1. æ‰©å±•æ€§å¼ºï¼šå¯è½»æ¾æ‰©å±•åˆ°Nå‰æ ‘ã€å›¾ç­‰ç»“æ„

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•            | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                   |
| --------------- | -------- | ---------- | ---------- | -------- | ---------------------- |
| BFSï¼ˆæœ¬è§£ï¼‰     | âœ…       | O(n)       | O(n)       | ä½       | é¢è¯•é¦–é€‰ï¼Œè‡ªç„¶åŒ¹é…     |
| DFSï¼ˆæ·±åº¦ä¼˜å…ˆï¼‰ | âœ…       | O(n)       | O(n)       | ä¸­       | éœ€è¦è®°å½•å±‚æ•°ï¼Œå®ç°å¤æ‚ |
| é€’å½’+å±‚æ•°è®°å½•   | âœ…       | O(n)       | O(n)       | ä¸­       | é€’å½’æ ˆæ·±åº¦å¯èƒ½è¿‡å¤§     |
| Morriséå†      | âŒ       | -          | -          | é«˜       | ä¸é€‚ç”¨äºå±‚åºéå†       |

> BFSæ˜¯å±‚åºéå†çš„å¤©ç„¶é€‰æ‹©ï¼Œå…¶ä»–æ–¹æ³•éƒ½æ˜¯"æ›²çº¿æ•‘å›½"

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. æ ‘ç»“æ„ï¼šé€‚ç”¨äºä»»ä½•æ ‘ï¼ˆäºŒå‰æ ‘ã€Nå‰æ ‘ï¼‰
1. ç©ºæ ‘å¤„ç†ï¼šéœ€ç‰¹æ®Šå¤„ç†rootä¸ºnullçš„æƒ…å†µ
1. èŠ‚ç‚¹å€¼èŒƒå›´ï¼šé¢˜ç›®çº¦æŸå†…æ— å½±å“
1. å±‚åºè¦æ±‚ï¼šå¿…é¡»æŒ‰å±‚è¿”å›ç»“æœ

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. é˜Ÿåˆ—é€‰æ‹©ï¼šä½¿ç”¨åŒç«¯é˜Ÿåˆ—ï¼ˆdequeï¼‰æé«˜æ•ˆç‡
1. ç©ºé—´ä¼˜åŒ–ï¼šå¯ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—äº¤æ›¿å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚
1. è¾¹ç•Œå¤„ç†ï¼šç©ºæ ‘ã€å•èŠ‚ç‚¹æ ‘éœ€ç‰¹æ®Šå¤„ç†
1. å¯è¯»æ€§ä¼˜å…ˆï¼šé¢è¯•ä¸­ä¼˜å…ˆæ¸…æ™°å®ç°

### æ€»ç»“

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰æ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ€ç»´æ¸…æ™°åº¦å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶æ´å¯Ÿä¸åŒè¯­è¨€åœ¨é˜Ÿåˆ—æ“ä½œã€å†…å­˜ç®¡ç†å’Œå¹¶å‘æ¨¡å‹ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    // å¤„ç†ç©ºæ ‘æƒ…å†µ
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}          // å­˜å‚¨æœ€ç»ˆç»“æœ
    queue := []*TreeNode{root}   // é˜Ÿåˆ—åˆå§‹åŒ–ï¼Œå­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹

    for len(queue) > 0 {
        levelSize := len(queue)  // å½“å‰å±‚èŠ‚ç‚¹æ•°
        currentLevel := []int{}  // å­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹å€¼

        // éå†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < levelSize; i++ {
            node := queue[0]     // å–é˜Ÿé¦–èŠ‚ç‚¹
            queue = queue[1:]    // å‡ºé˜Ÿ
            currentLevel = append(currentLevel, node.Val) // è®°å½•èŠ‚ç‚¹å€¼

            // å°†å­èŠ‚ç‚¹å…¥é˜Ÿ
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        // å°†å½“å‰å±‚ç»“æœåŠ å…¥æœ€ç»ˆç»“æœ
        result = append(result, currentLevel)
    }

    return result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. åˆå§‹åŒ–æ£€æŸ¥ï¼š`if root == nil` - ç©ºæ ‘ç›´æ¥è¿”å›ç©ºç»“æœ
1. ç»“æœå­˜å‚¨ï¼š`result` - äºŒç»´åˆ‡ç‰‡å­˜å‚¨æ¯å±‚ç»“æœ
1. é˜Ÿåˆ—åˆå§‹åŒ–ï¼š`queue` - å­˜å‚¨å½“å‰å±‚èŠ‚ç‚¹ï¼Œåˆå§‹åŒ…å«æ ¹èŠ‚ç‚¹
1. å±‚çº§å¾ªç¯ï¼š`for len(queue) > 0` - é˜Ÿåˆ—éç©ºæ—¶ç»§ç»­éå†
1. å±‚å¤§å°è®°å½•ï¼š`levelSize` - å½“å‰å±‚èŠ‚ç‚¹æ•°ï¼Œç”¨äºæ§åˆ¶å†…å±‚å¾ªç¯æ¬¡æ•°
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `node := queue[0]` - å–é˜Ÿé¦–èŠ‚ç‚¹
   - `queue = queue[1:]` - å‡ºé˜Ÿæ“ä½œï¼ˆåˆ‡ç‰‡é‡æ–°èµ‹å€¼ï¼‰
   - `currentLevel` - è®°å½•å½“å‰å±‚èŠ‚ç‚¹å€¼
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šå°†éç©ºå·¦ã€å³å­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
1. ç»“æœä¿å­˜ï¼š`result = append(result, currentLevel)` - ä¿å­˜å½“å‰å±‚ç»“æœ

è®¾è®¡åŠ¨æœºï¼š

- ä½¿ç”¨åˆ‡ç‰‡æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œç®€å•ç›´æ¥
- å¤–å±‚å¾ªç¯æ§åˆ¶å±‚æ•°ï¼Œå†…å±‚å¾ªç¯å¤„ç†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
- æ¯å±‚å¤„ç†å®Œæ¯•åä¿å­˜ç»“æœï¼Œç¡®ä¿å±‚åºè¾“å‡º

### B. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        result = []
        queue = deque([root])  # ä½¿ç”¨åŒç«¯é˜Ÿåˆ—æé«˜æ•ˆç‡

        while queue:
            level_size = len(queue)
            current_level = []

            for _ in range(level_size):
                node = queue.popleft()  # å‡ºé˜Ÿ
                current_level.append(node.val)

                # å­èŠ‚ç‚¹å…¥é˜Ÿ
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(current_level)

        return result
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if not root` - Pythoné£æ ¼çš„ç©ºæ£€æŸ¥
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`deque` - åŒç«¯é˜Ÿåˆ—ï¼Œpopleft()æ“ä½œO(1)æ—¶é—´
1. å±‚çº§å¾ªç¯ï¼š`while queue` - é˜Ÿåˆ—éç©ºæ—¶ç»§ç»­
1. å±‚å¤§å°è®°å½•ï¼š`level_size = len(queue)` - å½“å‰å±‚èŠ‚ç‚¹æ•°
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `node = queue.popleft()` - é«˜æ•ˆå‡ºé˜Ÿ
   - `current_level.append(node.val)` - è®°å½•èŠ‚ç‚¹å€¼
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šéç©ºå­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨
1. ç»“æœä¿å­˜ï¼š`result.append(current_level)` - ä¿å­˜å½“å‰å±‚ç»“æœ

Pythonç‰¹æ€§ï¼š

- ä½¿ç”¨`deque`æé«˜å‡ºé˜Ÿæ•ˆç‡
- ç±»å‹æç¤ºå¢å¼ºä»£ç å¯è¯»æ€§
- åˆ—è¡¨æ¨å¯¼å¼ç®€æ´é«˜æ•ˆ

### C. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function levelOrder(root: TreeNode | null): number[][] {
    if (!root) {
        return [];
    }

    const result: number[][] = [];
    const queue: TreeNode[] = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel: number[] = [];

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift()!;  // å‡ºé˜Ÿï¼Œéç©ºæ–­è¨€
            currentLevel.push(node.val);

            // å­èŠ‚ç‚¹å…¥é˜Ÿ
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }

        result.push(currentLevel);
    }

    return result;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if (!root)` - TypeScripté£æ ¼çš„ç©ºæ£€æŸ¥
1. ç±»å‹å®šä¹‰ï¼š`number[][]` - æ˜ç¡®ç»“æœç±»å‹
1. é˜Ÿåˆ—æ“ä½œï¼š`queue.shift()` - å‡ºé˜Ÿæ“ä½œï¼ŒO(n)æ—¶é—´ï¼ˆå¯ä¼˜åŒ–ï¼‰
1. éç©ºæ–­è¨€ï¼š`!` - å‘Šè¯‰ç¼–è¯‘å™¨nodeéç©º
1. å±‚çº§å¾ªç¯ï¼š`while (queue.length > 0)` - é˜Ÿåˆ—éç©ºæ—¶ç»§ç»­
1. å±‚å¤§å°è®°å½•ï¼š`levelSize = queue.length` - å½“å‰å±‚èŠ‚ç‚¹æ•°
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šéç©ºå­èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—å°¾éƒ¨

TypeScriptç‰¹æ€§ï¼š

- ç±»å‹æ³¨è§£å¢å¼ºä»£ç å®‰å…¨æ€§
- éç©ºæ–­è¨€ç¡®ä¿ç±»å‹æ­£ç¡®
- æ•°ç»„æ“ä½œä¸JavaScriptä¸€è‡´

ä¼˜åŒ–å»ºè®®ï¼š

- ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“ï¼ˆå¦‚`denque`ï¼‰æé«˜shift()æ•ˆç‡
- æˆ–ä½¿ç”¨ä¸¤ä¸ªæ•°ç»„äº¤æ›¿å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚

### D. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::VecDeque;

impl Solution {
    pub fn level_order(root: Option<Box<TreeNode>>) -> Vec<Vec<i32>> {
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        // å¤„ç†æ ¹èŠ‚ç‚¹
        if let Some(node) = root {
            queue.push_back(node);
        }

        while !queue.is_empty() {
            let level_size = queue.len();
            let mut current_level = Vec::with_capacity(level_size);

            for _ in 0..level_size {
                if let Some(node) = queue.pop_front() {
                    current_level.push(node.val);

                    // å­èŠ‚ç‚¹å…¥é˜Ÿ
                    if let Some(left) = node.left {
                        queue.push_back(left);
                    }
                    if let Some(right) = node.right {
                        queue.push_back(right);
                    }
                }
            }

            result.push(current_level);
        }

        result
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if let Some(node) = root` - Rustçš„Optionæ¨¡å¼åŒ¹é…
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`VecDeque` - åŒç«¯é˜Ÿåˆ—ï¼Œé«˜æ•ˆå‡ºé˜Ÿå…¥é˜Ÿ
1. ç»“æœåˆå§‹åŒ–ï¼š`Vec::new()` - åŠ¨æ€æ•°ç»„
1. å±‚å¤§å°é¢„åˆ†é…ï¼š`Vec::with_capacity(level_size)` - æé«˜å†…å­˜æ•ˆç‡
1. èŠ‚ç‚¹å¤„ç†ï¼š
   - `queue.pop_front()` - é«˜æ•ˆå‡ºé˜Ÿ
   - `current_level.push(node.val)` - è®°å½•èŠ‚ç‚¹å€¼
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼šä½¿ç”¨`if let`æ¨¡å¼åŒ¹é…å¤„ç†å­èŠ‚ç‚¹
1. æ‰€æœ‰æƒç®¡ç†ï¼šRustçš„æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨

Rustç‰¹æ€§ï¼š

- ä½¿ç”¨`Option`å’Œ`Box`å¤„ç†æ ‘èŠ‚ç‚¹
- `VecDeque`æä¾›é«˜æ•ˆé˜Ÿåˆ—æ“ä½œ
- æ¨¡å¼åŒ¹é…ç¡®ä¿å®‰å…¨æ€§
- å†…å­˜é¢„åˆ†é…æé«˜æ€§èƒ½

### E. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é˜Ÿåˆ—å®ç° | ç‰¹ç‚¹                    |
| ---------- | ---------- | ---------- | -------- | ----------------------- |
| Go         | O(n)       | O(n)       | åˆ‡ç‰‡     | ç®€å•ç›´æ¥ï¼Œæ€§èƒ½è‰¯å¥½      |
| Python     | O(n)       | O(n)       | deque    | é«˜æ•ˆå‡ºé˜Ÿï¼Œä»£ç ç®€æ´      |
| TypeScript | O(nÂ²)      | O(n)       | æ•°ç»„     | shift()æ“ä½œO(n)ï¼Œå¯ä¼˜åŒ– |
| Rust       | O(n)       | O(n)       | VecDeque | å†…å­˜å®‰å…¨ï¼Œæ€§èƒ½æœ€ä¼˜      |

æ³¨æ„ï¼šTypeScriptçš„æ•°ç»„shift()æ“ä½œæ˜¯O(n)æ—¶é—´ï¼Œåœ¨å¤§è§„æ¨¡æ•°æ®æ—¶æ€§èƒ½è¾ƒå·®ï¼Œå»ºè®®ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿å®ç°

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```text
å‡½æ•° levelOrder(root):
    å¦‚æœ root ä¸ºç©º:
        è¿”å› ç©ºåˆ—è¡¨

    result = ç©ºåˆ—è¡¨
    queue = é˜Ÿåˆ—([root])

    å½“ queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = ç©ºåˆ—è¡¨

        å¯¹äº i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ
            currentLevel æ·»åŠ  node.val

            å¦‚æœ node.left ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.left
            å¦‚æœ node.right ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.right

        result æ·»åŠ  currentLevel

    è¿”å› result
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: levelOrder(root)] --> B{root ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› ç©ºåˆ—è¡¨]
    B -- å¦ --> D[åˆå§‹åŒ– result å’Œ queue]
    D --> E[queue å…¥é˜Ÿ root]
    E --> F{queue ä¸ºç©º?}
    F -- æ˜¯ --> G[è¿”å› result]
    F -- å¦ --> H[levelSize = queue é•¿åº¦]
    H --> I[åˆå§‹åŒ– currentLevel]
    I --> J[i = 0]
    J --> K{i < levelSize?}
    K -- æ˜¯ --> L[node = queue å‡ºé˜Ÿ]
    L --> M[currentLevel æ·»åŠ  node.val]
    M --> N{node.left éç©º?}
    N -- æ˜¯ --> O[queue å…¥é˜Ÿ node.left]
    N -- å¦ --> P{node.right éç©º?}
    P -- æ˜¯ --> Q[queue å…¥é˜Ÿ node.right]
    P -- å¦ --> R[i = i + 1]
    R --> K
    K -- å¦ --> S[result æ·»åŠ  currentLevel]
    S --> F
```

### çŠ¶æ€è½¬ç§»å›¾ï¼ˆç¤ºä¾‹ï¼‰

```mermaid
graph LR
    subgraph "æ‰§è¡Œè¿‡ç¨‹: root = [3,9,20,null,null,15,7]"
        direction TB
        S1["ç¬¬1å±‚: queue=[3]"] --> S1a["å¤„ç†èŠ‚ç‚¹3"]
        S1a --> S1b["currentLevel=[3]"]
        S1b --> S1c["å…¥é˜Ÿ9,20"]
        S1c --> S1d["queue=[9,20]"]

        S1d --> S2["ç¬¬2å±‚: queue=[9,20]"]
        S2 --> S2a["å¤„ç†èŠ‚ç‚¹9"]
        S2a --> S2b["currentLevel=[9]"]
        S2b --> S2c["9æ— å­èŠ‚ç‚¹"]
        S2c --> S2d["å¤„ç†èŠ‚ç‚¹20"]
        S2d --> S2e["currentLevel=[9,20]"]
        S2e --> S2f["å…¥é˜Ÿ15,7"]
        S2f --> S2g["queue=[15,7]"]

        S2g --> S3["ç¬¬3å±‚: queue=[15,7]"]
        S3 --> S3a["å¤„ç†èŠ‚ç‚¹15"]
        S3a --> S3b["currentLevel=[15]"]
        S3b --> S3c["15æ— å­èŠ‚ç‚¹"]
        S3c --> S3d["å¤„ç†èŠ‚ç‚¹7"]
        S3d --> S3e["currentLevel=[15,7]"]
        S3e --> S3f["7æ— å­èŠ‚ç‚¹"]
        S3f --> S3g["queue=[]"]

        S3g --> S4["ç»“æŸ: result=[[3],[9,20],[15,7]]"]
    end

    %% æ ·å¼è®¾ç½®
    style S1 fill:#e6f3ff,stroke:#333
    style S2 fill:#e6f3ff,stroke:#333
    style S3 fill:#e6f3ff,stroke:#333
    style S4 fill:#6f9,stroke:#333
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: root = [3,9,20,null,null,15,7]

#### è¯¦ç»†æ‰§è¡Œæ­¥éª¤

| å±‚æ•° | queueçŠ¶æ€ | å¤„ç†èŠ‚ç‚¹ | currentLevel | å­èŠ‚ç‚¹å…¥é˜Ÿ | è¯´æ˜                    |
| ---- | --------- | -------- | ------------ | ---------- | ----------------------- |
| 1    | [3]       | 3        | [3]          | 9,20       | æ ¹èŠ‚ç‚¹3ï¼Œå…¥é˜Ÿå­èŠ‚ç‚¹9,20 |
| 2    | [9,20]    | 9        | [9]          | -          | 9æ— å­èŠ‚ç‚¹               |
| 2    | [20]      | 20       | [9,20]       | 15,7       | 20å…¥é˜Ÿå­èŠ‚ç‚¹15,7        |
| 3    | [15,7]    | 15       | [15]         | -          | 15æ— å­èŠ‚ç‚¹              |
| 3    | [7]       | 7        | [15,7]       | -          | 7æ— å­èŠ‚ç‚¹               |
| 4    | []        | -        | -            | -          | é˜Ÿåˆ—ä¸ºç©ºï¼Œç»“æŸ          |

#### æœ€ç»ˆç»“æœ

```text
[
    [3],
    [9,20],
    [15,7]
]
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            currentLevel = append(currentLevel, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, currentLevel)
    }

    return result
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®å±‚åºæ•°ç»„æ„å»ºäºŒå‰æ ‘
func buildTree(nums []interface{}) *TreeNode {
    if len(nums) == 0 || nums[0] == nil {
        return nil
    }

    root := &TreeNode{Val: nums[0].(int)}
    queue := []*TreeNode{root}
    i := 1

    for len(queue) > 0 && i < len(nums) {
        node := queue[0]
        queue = queue[1:]

        if i < len(nums) && nums[i] != nil {
            node.Left = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Left)
        }
        i++

        if i < len(nums) && nums[i] != nil {
            node.Right = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Right)
        }
        i++
    }

    return root
}

func main() {
    // Test Case 1
    nums1 := []interface{}{3, 9, 20, nil, nil, 15, 7}
    tree1 := buildTree(nums1)
    fmt.Printf("Test Case 1: %v\n", levelOrder(tree1)) // [[3],[9,20],[15,7]]

    // Test Case 2
    nums2 := []interface{}{1}
    tree2 := buildTree(nums2)
    fmt.Printf("Test Case 2: %v\n", levelOrder(tree2)) // [[1]]

    // Test Case 3
    nums3 := []interface{}{}
    tree3 := buildTree(nums3)
    fmt.Printf("Test Case 3: %v\n", levelOrder(tree3)) // []
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

æœ¬ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦

- æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ï¼šO(n)
- é˜Ÿåˆ—æ“ä½œï¼šæ¯ä¸ªèŠ‚ç‚¹å…¥é˜Ÿå‡ºé˜Ÿå„ä¸€æ¬¡ï¼ŒO(1)æ“ä½œ Ã— n = O(n)
- å±‚çº§å¤„ç†ï¼šå¤–å±‚å¾ªç¯æ¬¡æ•°ç­‰äºæ ‘çš„é«˜åº¦hï¼Œå†…å±‚å¾ªç¯æ€»æ¬¡æ•°ä¸ºn
- æ€»æ—¶é—´ï¼šO(n) + O(n) = O(n)

#### B. ç©ºé—´å¤æ‚åº¦

- ç»“æœå­˜å‚¨ï¼šO(n) - å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹å€¼
- é˜Ÿåˆ—å­˜å‚¨ï¼šæœ€åæƒ…å†µä¸‹å­˜å‚¨æœ€åä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹ï¼ŒO(n/2) â‰ˆ O(n)
- æ€»ç©ºé—´ï¼šO(n) + O(n) = O(n)

#### C. æœ€å¥½/å¹³å‡/æœ€åæƒ…å†µåˆ†æ

| æƒ…å†µ           | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                            |
| -------------- | ---------- | ---------- | ------------------------------- |
| æœ€å¥½ï¼ˆå¹³è¡¡æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸ºn/2               |
| å¹³å‡           | O(n)       | O(n)       | å…¸å‹äºŒå‰æ ‘                      |
| æœ€åï¼ˆé€€åŒ–æ ‘ï¼‰ | O(n)       | O(n)       | é˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸º1ï¼ˆæ¯å±‚ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ |

#### D. å¸¸æ•°å› å­åˆ†æ

- é˜Ÿåˆ—æ“ä½œå¼€é”€ï¼šå…¥é˜Ÿå‡ºé˜Ÿçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- ç»“æœå­˜å‚¨å¼€é”€ï¼šäºŒç»´æ•°ç»„çš„å†…å­˜åˆ†é…
- è¯­è¨€ç‰¹æ€§å½±å“ï¼š
  - Goåˆ‡ç‰‡æ“ä½œé«˜æ•ˆ
  - Python dequeé«˜æ•ˆ
  - TypeScriptæ•°ç»„shift()ä½æ•ˆï¼ˆå¯ä¼˜åŒ–ï¼‰
  - Rust VecDequeé«˜æ•ˆä¸”å®‰å…¨

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆï¼šé˜Ÿåˆ—æ“ä½œçš„å†…å­˜åˆ†é…å’Œæ‹·è´
- ä¼˜åŒ–æ–¹å‘ï¼š
  - ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—äº¤æ›¿å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚
  - é¢„åˆ†é…å†…å­˜ç©ºé—´ï¼ˆå¦‚Rustå®ç°ï¼‰
  - TypeScriptä¸­ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"å±‚çº§éå†"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. é˜Ÿåˆ—é©±åŠ¨çš„å±‚åºè®¿é—®
1. å±‚å¤§å°è®°å½•æŠ€å·§
1. å¹¿åº¦ä¼˜å…ˆçš„è‡ªç„¶åŒ¹é…
1. å¯æ‰©å±•åˆ°å¤šç§å±‚çº§ç»“æ„

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- å±‚çº§ç»“æ„çš„éå†ï¼šæŒ‰å±‚è®¿é—®ï¼Œæ¯å±‚ä»å·¦åˆ°å³
- é˜Ÿåˆ—çš„ä½œç”¨ï¼šç»´æŠ¤å½“å‰å±‚å’Œä¸‹ä¸€å±‚çš„èŠ‚ç‚¹
- å±‚å¤§å°è®°å½•ï¼šé€šè¿‡è®°å½•å½“å‰å±‚èŠ‚ç‚¹æ•°ï¼Œæ§åˆ¶å†…å±‚å¾ªç¯æ¬¡æ•°
- å¹¿åº¦ä¼˜å…ˆçš„å“²å­¦ï¼šå…ˆå¤„ç†å®Œå½“å‰å±‚ï¼Œå†è¿›å…¥ä¸‹ä¸€å±‚

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®                   | æ ¸å¿ƒæ€æƒ³               | åŒ¹é…æ¨¡å¼ |
| ---- | ---------------------- | ---------------------- | -------- |
| 102  | æœ¬é¢˜                   | äºŒå‰æ ‘å±‚åºéå†         | æ ¸å¿ƒæ¨¡å¼ |
| 107  | äºŒå‰æ ‘çš„å±‚åºéå† II    | è‡ªåº•å‘ä¸Šå±‚åºéå†       | æ¨¡å¼å˜ä½“ |
| 429  | Nå‰æ ‘çš„å±‚åºéå†        | Nå‰æ ‘å±‚åºéå†          | æ¨¡å¼æ‰©å±• |
| 103  | äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå† | äº¤æ›¿æ–¹å‘å±‚åºéå†       | æ¨¡å¼å˜ä½“ |
| 199  | äºŒå‰æ ‘çš„å³è§†å›¾         | å±‚åºéå†å–æ¯å±‚æœ€åä¸€ä¸ª | æ¨¡å¼åº”ç”¨ |
| 637  | äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼       | å±‚åºéå†è®¡ç®—å¹³å‡å€¼     | æ¨¡å¼åº”ç”¨ |

#### C. æ¨¡å¼æ³›åŒ–

- Nå‰æ ‘éå†ï¼šå°†å­èŠ‚ç‚¹å…¥é˜Ÿé€»è¾‘æ”¹ä¸ºéå†æ‰€æœ‰å­èŠ‚ç‚¹
- å›¾éå†ï¼šæ·»åŠ visitedé›†åˆé˜²æ­¢é‡å¤è®¿é—®
- å¤šå‰æ ‘éå†ï¼šé€‚ç”¨äºç»„ç»‡ç»“æ„ã€æ–‡ä»¶ç³»ç»Ÿç­‰
- æ‹“æ‰‘æ’åºï¼šåŸºäºå±‚åºéå†çš„å˜ä½“

#### D. å·¥ä¸šåº”ç”¨

- ç»„ç»‡ç»“æ„å›¾ï¼šæŒ‰å±‚çº§å±•ç¤ºå…¬å¸ç»“æ„
- æ–‡ä»¶ç³»ç»Ÿï¼šæŒ‰ç›®å½•å±‚çº§éå†æ–‡ä»¶
- ç½‘ç»œè·¯ç”±ï¼šæŒ‰è·³æ•°å±‚çº§ä¼ æ’­è·¯ç”±ä¿¡æ¯
- æ¸¸æˆAIï¼šæŒ‰è·ç¦»å±‚çº§æœç´¢ç›®æ ‡
- æ•°æ®åº“ç´¢å¼•ï¼šBæ ‘çš„å±‚çº§éå†

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆå¿…é¡»è®°å½•å±‚å¤§å°ï¼Ÿ
   - é˜Ÿåˆ—åœ¨éå†è¿‡ç¨‹ä¸­ä¼šåŠ¨æ€å˜åŒ–
   - éœ€è¦åœ¨éå†å¼€å§‹æ—¶è®°å½•å½“å‰å±‚èŠ‚ç‚¹æ•°
   - å¦åˆ™æ— æ³•åŒºåˆ†å½“å‰å±‚å’Œä¸‹ä¸€å±‚èŠ‚ç‚¹

1. ä¸ºä»€ä¹ˆä¸èƒ½ç”¨DFSï¼Ÿ
   - DFSæŒ‰æ·±åº¦è®¿é—®ï¼Œæ— æ³•è‡ªç„¶åŒ¹é…å±‚åº
   - éœ€è¦é¢å¤–è®°å½•èŠ‚ç‚¹å±‚æ•°ï¼Œå®ç°å¤æ‚
   - ç©ºé—´å¤æ‚åº¦ç›¸åŒï¼Œä½†å®ç°ä¸ç›´è§‚

1. é˜Ÿåˆ—çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ
   - ç»´æŠ¤"å½“å‰å±‚"å’Œ"ä¸‹ä¸€å±‚"çš„è¾¹ç•Œ
   - ç¡®ä¿æŒ‰å±‚åºè®¿é—®
   - å®ç°å¹¿åº¦ä¼˜å…ˆçš„æ ¸å¿ƒæ•°æ®ç»“æ„

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿï¼š

1. å¯¹BFSå’Œå±‚åºéå†å…³ç³»çš„ç†è§£
1. é˜Ÿåˆ—æ“ä½œçš„ç»†èŠ‚å’Œä¼˜åŒ–
1. ä»åŸºç¡€åˆ°å˜ä½“çš„æ‰©å±•èƒ½åŠ›
1. æ—¶é—´ç©ºé—´å¤æ‚åº¦çš„æ·±å…¥åˆ†æ

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆé€‰æ‹©BFSè€Œä¸æ˜¯DFSï¼Ÿ

â†’ æ ‡å‡†: BFSå¤©ç„¶æŒ‰å±‚è®¿é—®ï¼Œä¸å±‚åºéå†å®Œå…¨åŒ¹é…
â†’ åŠ åˆ†: DFSéœ€è¦é¢å¤–è®°å½•å±‚æ•°ï¼Œå®ç°å¤æ‚ä¸”ä¸ç›´è§‚

#### Q2: å¦‚ä½•å¤„ç†ç©ºæ ‘çš„æƒ…å†µï¼Ÿ

â†’ æ ‡å‡†: åœ¨å‡½æ•°å¼€å§‹æ—¶æ£€æŸ¥rootæ˜¯å¦ä¸ºnull
â†’ åŠ åˆ†: æä¾›å…·ä½“ä»£ç å®ç°ï¼Œå±•ç¤ºè¾¹ç•Œå¤„ç†

#### Q3: é˜Ÿåˆ—ä¸­å­˜å‚¨çš„æ˜¯ä»€ä¹ˆï¼Ÿ

â†’ æ ‡å‡†: å­˜å‚¨å½“å‰å±‚å’Œä¸‹ä¸€å±‚çš„èŠ‚ç‚¹æŒ‡é’ˆ
â†’ åŠ åˆ†: è¯´æ˜é˜Ÿåˆ—çš„ä½œç”¨æ˜¯ç»´æŠ¤å±‚çº§è¾¹ç•Œ

#### Q4: å¦‚ä½•è®°å½•å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ï¼Ÿ

â†’ æ ‡å‡†: åœ¨æ¯å±‚å¼€å§‹æ—¶è®°å½•queueçš„é•¿åº¦
â†’ åŠ åˆ†: è¯´æ˜è¿™æ˜¯æ§åˆ¶å†…å±‚å¾ªç¯æ¬¡æ•°çš„å…³é”®

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°è‡ªåº•å‘ä¸Šçš„å±‚åºéå†ï¼Ÿ

â†’ æ ‡å‡†: æ­£å¸¸å±‚åºéå†ååè½¬ç»“æœ
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°ï¼Œæˆ–ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ç›´æ¥æ’å…¥å¤´éƒ¨

```go
// è‡ªåº•å‘ä¸Šå±‚åºéå†
func levelOrderBottom(root *TreeNode) [][]int {
    result := levelOrder(root)  // æ­£å¸¸å±‚åºéå†
    // åè½¬ç»“æœ
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }
    return result
}
```

#### Q2: å¦‚ä½•å®ç°Nå‰æ ‘çš„å±‚åºéå†ï¼Ÿ

â†’ æ ‡å‡†: å°†å­èŠ‚ç‚¹å…¥é˜Ÿé€»è¾‘æ”¹ä¸ºéå†æ‰€æœ‰å­èŠ‚ç‚¹
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// Nå‰æ ‘èŠ‚ç‚¹å®šä¹‰
type Node struct {
    Val int
    Children []*Node
}

func levelOrderN(root *Node) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*Node{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := []int{}

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            currentLevel = append(currentLevel, node.Val)

            // éå†æ‰€æœ‰å­èŠ‚ç‚¹
            for _, child := range node.Children {
                queue = append(queue, child)
            }
        }

        result = append(result, currentLevel)
    }

    return result
}
```

#### Q3: å¦‚ä½•ä¼˜åŒ–TypeScriptçš„å®ç°ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–åçš„ä»£ç 

```typescript
// ä¼˜åŒ–ç‰ˆï¼šä½¿ç”¨ä¸¤ä¸ªæ•°ç»„äº¤æ›¿
function levelOrderOptimized(root: TreeNode | null): number[][] {
  if (!root) return [];

  const result: number[][] = [];
  let currentLevelNodes: TreeNode[] = [root];

  while (currentLevelNodes.length > 0) {
    const currentLevel: number[] = [];
    const nextLevelNodes: TreeNode[] = [];

    for (const node of currentLevelNodes) {
      currentLevel.push(node.val);
      if (node.left) nextLevelNodes.push(node.left);
      if (node.right) nextLevelNodes.push(node.right);
    }

    result.push(currentLevel);
    currentLevelNodes = nextLevelNodes;
  }

  return result;
}
```

#### Q4: å¦‚ä½•å®ç°äºŒå‰æ ‘çš„å³è§†å›¾ï¼Ÿ

â†’ æ ‡å‡†: å±‚åºéå†å–æ¯å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            // å½“å‰å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹
            if i == levelSize-1 {
                result = append(result, node.Val)
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }

    return result
}
```

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®ï¼š

1. BFSä¸å±‚åºéå†çš„å¤©ç„¶åŒ¹é…
1. é˜Ÿåˆ—é©±åŠ¨çš„å±‚çº§æ§åˆ¶
1. å±‚å¤§å°è®°å½•æŠ€å·§
1. å¤šè¯­è¨€å®ç°çš„å·®å¼‚

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹       | å£è¯€                         |
| ------------ | ---------------------------- |
| å±‚åºéå†æ ¸å¿ƒ | é˜Ÿåˆ—é©±åŠ¨ï¼Œå±‚å±‚æ¨è¿›           |
| å±‚å¤§å°è®°å½•   | æ¯å±‚å¼€å§‹è®°é•¿åº¦ï¼Œæ§åˆ¶å†…å±‚å¾ªç¯ |
| å­èŠ‚ç‚¹å¤„ç†   | å·¦å³å­èŠ‚ç‚¹ä¾æ¬¡å…¥é˜Ÿ           |
| ç©ºæ ‘å¤„ç†     | å…ˆæ£€æŸ¥rootä¸ºç©º               |
| ç»“æœä¿å­˜     | æ¯å±‚ç»“æŸä¿å­˜ç»“æœ             |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹       | è§¦å‘åœºæ™¯           | åº”å¯¹æªæ–½                   |
| -------------- | ------------------ | -------------------------- |
| å¿˜è®°è®°å½•å±‚å¤§å° | å†…å±‚å¾ªç¯æ— é™è¿›è¡Œ   | æ¯å±‚å¼€å§‹è®°å½•queueé•¿åº¦      |
| ç©ºæ ‘æœªå¤„ç†     | rootä¸ºnullæ—¶å´©æºƒ   | å‡½æ•°å¼€å§‹æ£€æŸ¥rootä¸ºç©º       |
| é˜Ÿåˆ—æ“ä½œé”™è¯¯   | åˆ‡ç‰‡è¶Šç•Œæˆ–å†…å­˜æ³„æ¼ | ç¡®ä¿å‡ºé˜Ÿå…¥é˜Ÿæ“ä½œæ­£ç¡®       |
| ç»“æœä¿å­˜æ—¶æœº   | ä¿å­˜ä¸å®Œæ•´çš„å±‚     | æ¯å±‚ç»“æŸæ—¶ä¿å­˜currentLevel |
| å­èŠ‚ç‚¹åˆ¤ç©º     | ç©ºæŒ‡é’ˆå¼‚å¸¸         | å…¥é˜Ÿå‰æ£€æŸ¥å­èŠ‚ç‚¹éç©º       |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯              | åº”ç”¨åœºæ™¯         |
| ------------------- | ---------------- |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ | æè¿°ç®—æ³•é€‰æ‹©     |
| é˜Ÿåˆ—é©±åŠ¨            | è§£é‡Šæ ¸å¿ƒæ•°æ®ç»“æ„ |
| å±‚å¤§å°è®°å½•          | è¯´æ˜å†…å±‚å¾ªç¯æ§åˆ¶ |
| å±‚åºéå†            | å‘½åç®—æ³•èŒƒå¼     |
| ç©ºé—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ       |
| æ—¶é—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ       |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: å±‚çº§éå†
â”œâ”€â”€ å¿…è¦æ¡ä»¶: é˜Ÿåˆ— + å±‚å¤§å°è®°å½•
â”œâ”€â”€ æœ¬è´¨: å¹¿åº¦ä¼˜å…ˆçš„å±‚çº§æ§åˆ¶
â”œâ”€â”€ æ–¹æ³•: BFS
â”‚   â”œâ”€â”€ é˜Ÿåˆ—åˆå§‹åŒ–: [root]
â”‚   â”œâ”€â”€ å¤–å±‚å¾ªç¯: é˜Ÿåˆ—éç©º
â”‚   â”œâ”€â”€ å†…å±‚å¾ªç¯: å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
â”‚   â””â”€â”€ å­èŠ‚ç‚¹å¤„ç†: å·¦å³å­èŠ‚ç‚¹å…¥é˜Ÿ
â”œâ”€â”€ ä¼˜åŒ–: åŒé˜Ÿåˆ—äº¤æ›¿
â”œâ”€â”€ å˜ä½“: è‡ªåº•å‘ä¸Šã€Nå‰æ ‘ã€é”¯é½¿å½¢
â””â”€â”€ åº”ç”¨: ç»„ç»‡ç»“æ„ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œè·¯ç”±
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆ
å‡½æ•° levelOrder(root):
    if root ä¸ºç©º: return []
    result = []
    queue = [root]

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        currentLevel = []

        for i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ
            currentLevel æ·»åŠ  node.val

            if node.left éç©º: queue å…¥é˜Ÿ node.left
            if node.right éç©º: queue å…¥é˜Ÿ node.right

        result æ·»åŠ  currentLevel

    return result

// ä¼˜åŒ–ç‰ˆï¼ˆåŒé˜Ÿåˆ—äº¤æ›¿ï¼‰
å‡½æ•° levelOrderOptimized(root):
    if root ä¸ºç©º: return []
    result = []
    currentLevelNodes = [root]

    while currentLevelNodes ä¸ä¸ºç©º:
        currentLevel = []
        nextLevelNodes = []

        for node in currentLevelNodes:
            currentLevel æ·»åŠ  node.val
            if node.left éç©º: nextLevelNodes æ·»åŠ  node.left
            if node.right éç©º: nextLevelNodes æ·»åŠ  node.right

        result æ·»åŠ  currentLevel
        currentLevelNodes = nextLevelNodes

    return result
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³å±‚åºéå†ç›¸å…³é—®é¢˜ï¼Œå¹¶å±•ç°å¯¹æ ‘ç»“æ„å’Œéå†ç®—æ³•çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
