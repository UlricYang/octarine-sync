# LeetCode 117 - å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II

## 1. é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼š

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º `NULL`

åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º `NULL`

### è¿›é˜¶

- ä½ åªèƒ½ä½¿ç”¨å¸¸é‡é¢å¤–ç©ºé—´
- ä½¿ç”¨é€’å½’è§£é¢˜ä¹Ÿç¬¦åˆè¦æ±‚ï¼Œæœ¬é¢˜ä¸­é€’å½’ç¨‹åºå ç”¨çš„æ ˆç©ºé—´ä¸ç®—åšé¢å¤–çš„ç©ºé—´å¤æ‚åº¦

### ç¤ºä¾‹

![ç¤ºä¾‹å›¾](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)

```
è¾“å…¥ï¼šroot = [1,2,3,4,5,null,7]
è¾“å‡ºï¼š[1,#,2,3,#,4,5,7,#]
è§£é‡Šï¼šç»™å®šäºŒå‰æ ‘å¦‚å›¾ A æ‰€ç¤ºï¼Œä½ çš„å‡½æ•°åº”è¯¥å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œä»¥æŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œå¦‚å›¾ B æ‰€ç¤ºã€‚åºåˆ—åŒ–è¾“å‡ºæŒ‰å±‚åºéå†é¡ºåºï¼ˆç”± next æŒ‡é’ˆè¿æ¥ï¼‰ï¼Œ'#' è¡¨ç¤ºæ¯å±‚çš„æœ«å°¾
```

### çº¦æŸæ¡ä»¶

- æ ‘ä¸­çš„èŠ‚ç‚¹æ•°å°äº `6000`
- `-100 <= node.val <= 100`

## 2. è§£æ³•åˆ†æï¼šå±‚åºéå† + é“¾è¡¨æ„å»º

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯å±‚åºéå† + é“¾è¡¨æ„å»ºï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. è‡ªç„¶åŒ¹é…å±‚åºç»“æ„ - BFSå¤©ç„¶æŒ‰å±‚è®¿é—®èŠ‚ç‚¹
1. å¸¸é‡ç©ºé—´å®ç° - é€šè¿‡nextæŒ‡é’ˆæ„å»ºé“¾è¡¨ï¼Œæ— éœ€é¢å¤–é˜Ÿåˆ—
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - O(n)æ—¶é—´è®¿é—®æ‰€æœ‰èŠ‚ç‚¹
1. ç©ºé—´å¤æ‚åº¦å¯æ§ - O(1)é¢å¤–ç©ºé—´ï¼ˆä¸è®¡é€’å½’æ ˆï¼‰
1. å®ç°æ¸…æ™°ç›´è§‚ - ä»£ç é€»è¾‘æ˜“äºç†è§£

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆå±‚åºéå†+é“¾è¡¨æ„å»ºæ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å±‚åºç»“æ„çš„åŸºç¡€ï¼šnextæŒ‡é’ˆéœ€è¦è¿æ¥åŒä¸€å±‚çš„ç›¸é‚»èŠ‚ç‚¹
1. BFSçš„ç‰¹æ€§ï¼šæŒ‰å±‚è®¿é—®èŠ‚ç‚¹ï¼Œä¸é¢˜ç›®è¦æ±‚å®Œå…¨åŒ¹é…
1. å¸¸é‡ç©ºé—´ï¼šåˆ©ç”¨nextæŒ‡é’ˆæ„å»ºé“¾è¡¨ï¼Œæ— éœ€é¢å¤–é˜Ÿåˆ—
1. å¤ç”¨æ€§å¼ºï¼šåŸºäº116é¢˜çš„è§£æ³•ï¼Œé€‚ç”¨äºæ™®é€šäºŒå‰æ ‘
1. æ€§èƒ½ä¼˜å¼‚ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡ï¼Œæ— é‡å¤è®¡ç®—

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•                      | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                           |
| ------------------------- | -------- | ---------- | ---------- | -------- | ------------------------------ |
| å±‚åºéå†+é“¾è¡¨æ„å»ºï¼ˆæœ¬è§£ï¼‰ | âœ…       | O(n)       | O(1)       | ä¸­       | é¢è¯•é¦–é€‰ï¼Œå¸¸é‡ç©ºé—´             |
| BFS+é˜Ÿåˆ—                  | âœ…       | O(n)       | O(n)       | ä½       | ç®€å•ç›´è§‚ï¼Œä½†ç©ºé—´å¤æ‚åº¦é«˜       |
| DFS+å±‚æ•°è®°å½•              | âœ…       | O(n)       | O(h)       | ä¸­       | é€’å½’å®ç°ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ‘é«˜ |
| é€’å½’+nextæŒ‡é’ˆ             | âœ…       | O(n)       | O(h)       | é«˜       | é€’å½’å®ç°ï¼Œä»£ç ç®€æ´ä½†ç†è§£éš¾åº¦å¤§ |

> å±‚åºéå†+é“¾è¡¨æ„å»ºæ˜¯æœ€ç¬¦åˆè¿›é˜¶è¦æ±‚ï¼ˆå¸¸é‡ç©ºé—´ï¼‰çš„è§£å†³æ–¹æ¡ˆ

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. æ ‘ç»“æ„ï¼šé€‚ç”¨äºä»»ä½•äºŒå‰æ ‘ï¼ˆæ™®é€šäºŒå‰æ ‘ï¼Œéå®Œç¾äºŒå‰æ ‘ï¼‰
1. ç©ºæ ‘å¤„ç†ï¼šéœ€ç‰¹æ®Šå¤„ç†rootä¸ºnullçš„æƒ…å†µ
1. èŠ‚ç‚¹å€¼èŒƒå›´ï¼šé¢˜ç›®çº¦æŸå†…æ— å½±å“
1. nextæŒ‡é’ˆåˆå§‹åŒ–ï¼šé¢˜ç›®ä¿è¯åˆå§‹ä¸ºNULL

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. å¤ç”¨æ€§ï¼šåŸºäº116é¢˜çš„è§£æ³•ï¼Œé€‚ç”¨äºæ™®é€šäºŒå‰æ ‘
1. æ€§èƒ½ï¼šæ¯å±‚å¤„ç†å®Œæ¯•åæ„å»ºé“¾è¡¨
1. å¯è¯»æ€§ï¼šä»£ç é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç»´æŠ¤
1. æ‰©å±•æ€§ï¼šå¯è½»æ¾æ‰©å±•åˆ°å…¶ä»–é“¾è¡¨æ„å»ºåœºæ™¯

### æ€»ç»“

å±‚åºéå† + é“¾è¡¨æ„å»ºæ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€ç©ºé—´æ•ˆç‡å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶å±•ç¤ºä¸åŒè¯­è¨€åœ¨æŒ‡é’ˆæ“ä½œå’Œé“¾è¡¨æ„å»ºä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 *     Next *Node
 * }
 */

func connect(root *Node) *Node {
    if root == nil {
        return nil
    }

    // å½“å‰å±‚çš„èµ·å§‹èŠ‚ç‚¹
    currentLevelStart := root

    // éå†æ¯ä¸€å±‚
    for currentLevelStart != nil {
        // å½“å‰å±‚çš„éå†æŒ‡é’ˆ
        current := currentLevelStart
        // ä¸‹ä¸€å±‚çš„è™šæ‹Ÿå¤´èŠ‚ç‚¹
        dummy := &Node{}
        // ä¸‹ä¸€å±‚çš„å°¾æŒ‡é’ˆ
        tail := dummy

        // éå†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
        for current != nil {
            // å¤„ç†å·¦å­èŠ‚ç‚¹
            if current.Left != nil {
                tail.Next = current.Left
                tail = tail.Next
            }
            // å¤„ç†å³å­èŠ‚ç‚¹
            if current.Right != nil {
                tail.Next = current.Right
                tail = tail.Next
            }
            // ç§»åŠ¨åˆ°å½“å‰å±‚çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            current = current.Next
        }

        // ç§»åŠ¨åˆ°ä¸‹ä¸€å±‚çš„èµ·å§‹èŠ‚ç‚¹
        currentLevelStart = dummy.Next
    }

    return root
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if root == nil` - ç©ºæ ‘ç›´æ¥è¿”å›
1. å±‚çº§éå†ï¼š`for currentLevelStart != nil` - éå†æ¯ä¸€å±‚
1. å½“å‰å±‚æŒ‡é’ˆï¼š`current` - éå†å½“å‰å±‚èŠ‚ç‚¹
1. ä¸‹ä¸€å±‚é“¾è¡¨æ„å»ºï¼š
   - `dummy` - è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œç®€åŒ–é“¾è¡¨æ„å»º
   - `tail` - å°¾æŒ‡é’ˆï¼Œè¿½åŠ ä¸‹ä¸€å±‚èŠ‚ç‚¹
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å…ˆå¤„ç†å·¦å­èŠ‚ç‚¹ï¼š`tail.Next = current.Left`
   - å†å¤„ç†å³å­èŠ‚ç‚¹ï¼š`tail.Next = current.Right`
1. å±‚çº§åˆ‡æ¢ï¼š`currentLevelStart = dummy.Next` - ç§»åŠ¨åˆ°ä¸‹ä¸€å±‚èµ·å§‹èŠ‚ç‚¹

è®¾è®¡åŠ¨æœºï¼š

- ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–é“¾è¡¨æ„å»ºé€»è¾‘
- é€šè¿‡nextæŒ‡é’ˆéå†å½“å‰å±‚ï¼Œæ— éœ€é¢å¤–é˜Ÿåˆ—
- å°¾æŒ‡é’ˆè¿½åŠ èŠ‚ç‚¹ï¼Œé«˜æ•ˆæ„å»ºä¸‹ä¸€å±‚é“¾è¡¨
- å¸¸é‡ç©ºé—´å®ç°ï¼Œç¬¦åˆè¿›é˜¶è¦æ±‚

### B. Python ğŸ å®ç°

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None

        current_level_start = root

        while current_level_start:
            current = current_level_start
            dummy = Node()  # è™šæ‹Ÿå¤´èŠ‚ç‚¹
            tail = dummy

            while current:
                if current.left:
                    tail.next = current.left
                    tail = tail.next
                if current.right:
                    tail.next = current.right
                    tail = tail.next
                current = current.next

            current_level_start = dummy.next

        return root
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if not root` - Pythoné£æ ¼çš„ç©ºæ£€æŸ¥
1. å±‚çº§éå†ï¼š`while current_level_start` - éå†æ¯ä¸€å±‚
1. å½“å‰å±‚æŒ‡é’ˆï¼š`current` - éå†å½“å‰å±‚èŠ‚ç‚¹
1. ä¸‹ä¸€å±‚é“¾è¡¨æ„å»ºï¼š
   - `dummy` - è™šæ‹Ÿå¤´èŠ‚ç‚¹
   - `tail` - å°¾æŒ‡é’ˆ
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å…ˆå¤„ç†å·¦å­èŠ‚ç‚¹
   - å†å¤„ç†å³å­èŠ‚ç‚¹
1. å±‚çº§åˆ‡æ¢ï¼š`current_level_start = dummy.next`

Pythonç‰¹æ€§ï¼š

- åŠ¨æ€ç±»å‹ç®€åŒ–ä»£ç 
- è™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–é“¾è¡¨æ„å»º
- ä»£ç ç®€æ´æ˜“è¯»

### C. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for Node.
 * class Node {
 *     val: number
 *     left: Node | null
 *     right: Node | null
 *     next: Node | null
 *     constructor(val?: number, left?: Node, right?: Node, next?: Node) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function connect(root: Node | null): Node | null {
    if (!root) {
        return null;
    }

    let currentLevelStart: Node | null = root;

    while (currentLevelStart) {
        let current: Node | null = currentLevelStart;
        const dummy = new Node(); // è™šæ‹Ÿå¤´èŠ‚ç‚¹
        let tail: Node = dummy;

        while (current) {
            if (current.left) {
                tail.next = current.left;
                tail = tail.next;
            }
            if (current.right) {
                tail.next = current.right;
                tail = tail.next;
            }
            current = current.next;
        }

        currentLevelStart = dummy.next;
    }

    return root;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if (!root)` - TypeScripté£æ ¼çš„ç©ºæ£€æŸ¥
1. ç±»å‹å®šä¹‰ï¼š`Node | null` - æ˜ç¡®å¯ç©ºç±»å‹
1. å±‚çº§éå†ï¼š`while (currentLevelStart)` - éå†æ¯ä¸€å±‚
1. ä¸‹ä¸€å±‚é“¾è¡¨æ„å»ºï¼š
   - `dummy` - è™šæ‹Ÿå¤´èŠ‚ç‚¹
   - `tail` - å°¾æŒ‡é’ˆ
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - å…ˆå¤„ç†å·¦å­èŠ‚ç‚¹
   - å†å¤„ç†å³å­èŠ‚ç‚¹
1. å±‚çº§åˆ‡æ¢ï¼š`currentLevelStart = dummy.next`

TypeScriptç‰¹æ€§ï¼š

- ç±»å‹æ³¨è§£å¢å¼ºä»£ç å®‰å…¨æ€§
- å¯ç©ºç±»å‹å¤„ç†æ˜ç¡®
- ç±»æ„é€ å‡½æ•°ç®€åŒ–èŠ‚ç‚¹åˆ›å»º

### D. Rust ğŸ¦€ å®ç°

```rust
// Definition for a Node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct Node {
//   pub val: i32,
//   pub left: Option<Box<Node>>,
//   pub right: Option<Box<Node>>,
//   pub next: Option<Box<Node>>,
// }
//
// impl Node {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     Node {
//       val,
//       left: None,
//       right: None,
//       next: None
//     }
//   }
// }

use std::mem;

impl Solution {
    pub fn connect(root: Option<Box<Node>>) -> Option<Box<Node>> {
        let mut root = root;
        let mut current_level_start = root.as_ref();

        while let Some(start) = current_level_start {
            let mut current = start;
            let mut dummy = Box::new(Node::new(0));
            let mut tail = &mut dummy;

            // éå†å½“å‰å±‚
            while let Some(node) = current {
                // å¤„ç†å·¦å­èŠ‚ç‚¹
                if let Some(left) = &node.left {
                    tail.next = Some(Box::new(Node {
                        val: left.val,
                        left: left.left.clone(),
                        right: left.right.clone(),
                        next: None,
                    }));
                    tail = tail.next.as_mut().unwrap();
                }

                // å¤„ç†å³å­èŠ‚ç‚¹
                if let Some(right) = &node.right {
                    tail.next = Some(Box::new(Node {
                        val: right.val,
                        left: right.left.clone(),
                        right: right.right.clone(),
                        next: None,
                    }));
                    tail = tail.next.as_mut().unwrap();
                }

                current = node.next.as_ref();
            }

            // ç§»åŠ¨åˆ°ä¸‹ä¸€å±‚
            current_level_start = dummy.next.as_ref();
        }

        root
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. æ‰€æœ‰æƒå¤„ç†ï¼š`let mut root = root` - è·å–æ‰€æœ‰æƒ
1. å±‚çº§éå†ï¼š`while let Some(start) = current_level_start` - æ¨¡å¼åŒ¹é…
1. ä¸‹ä¸€å±‚é“¾è¡¨æ„å»ºï¼š
   - `dummy` - è™šæ‹Ÿå¤´èŠ‚ç‚¹
   - `tail` - å°¾æŒ‡é’ˆ
1. å­èŠ‚ç‚¹å¤„ç†ï¼š
   - ä½¿ç”¨`if let`å¤„ç†Optionç±»å‹
   - å…‹éš†å­èŠ‚ç‚¹å€¼å’Œå­æ ‘
1. å±‚çº§åˆ‡æ¢ï¼š`current_level_start = dummy.next.as_ref()`

Rustç‰¹æ€§ï¼š

- æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨
- æ¨¡å¼åŒ¹é…å¤„ç†Optionç±»å‹
- å…‹éš†èŠ‚ç‚¹å€¼å’Œå­æ ‘
- ç±»å‹å®‰å…¨ä¿è¯

æ³¨æ„ï¼šRustå®ç°è¾ƒä¸ºå¤æ‚ï¼Œéœ€è¦å…‹éš†èŠ‚ç‚¹å€¼å’Œå­æ ‘ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦ä¼˜åŒ–

### E. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | æŒ‡é’ˆæ“ä½œ   | é“¾è¡¨æ„å»º | ç‰¹ç‚¹                 |
| ---------- | ---------- | ---------- | ---------- | -------- | -------------------- |
| Go         | O(n)       | O(1)       | ç®€å•ç›´æ¥   | é«˜æ•ˆ     | é¢è¯•é¦–é€‰ï¼Œå®ç°ç®€å•   |
| Python     | O(n)       | O(1)       | åŠ¨æ€ç±»å‹   | ç®€æ´     | ä»£ç ç®€æ´ï¼Œæ˜“äºç†è§£   |
| TypeScript | O(n)       | O(1)       | ç±»å‹å®‰å…¨   | æ˜ç¡®     | ç±»å‹å®‰å…¨ï¼Œå¯è¯»æ€§é«˜   |
| Rust       | O(n)       | O(1)       | æ‰€æœ‰æƒå¤æ‚ | å®‰å…¨     | å†…å­˜å®‰å…¨ï¼Œä½†å®ç°å¤æ‚ |

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```text
å‡½æ•° connect(root):
    å¦‚æœ root ä¸ºç©º:
        è¿”å› null

    currentLevelStart = root

    å½“ currentLevelStart ä¸ä¸ºç©º:
        current = currentLevelStart
        dummy = æ–°èŠ‚ç‚¹(0)  // è™šæ‹Ÿå¤´èŠ‚ç‚¹
        tail = dummy

        å½“ current ä¸ä¸ºç©º:
            å¦‚æœ current.left ä¸ä¸ºç©º:
                tail.next = current.left
                tail = tail.next
            å¦‚æœ current.right ä¸ä¸ºç©º:
                tail.next = current.right
                tail = tail.next
            current = current.next

        currentLevelStart = dummy.next

    è¿”å› root
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: connect(root)] --> B{root ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› null]
    B -- å¦ --> D[åˆå§‹åŒ– currentLevelStart = root]
    D --> E{currentLevelStart ä¸ºç©º?}
    E -- æ˜¯ --> F[è¿”å› root]
    E -- å¦ --> G[åˆå§‹åŒ– current = currentLevelStart]
    G --> H[åˆ›å»º dummy èŠ‚ç‚¹]
    H --> I[åˆå§‹åŒ– tail = dummy]
    I --> J{current ä¸ºç©º?}
    J -- æ˜¯ --> K[currentLevelStart = dummy.next]
    J -- å¦ --> L{current.left éç©º?}
    L -- æ˜¯ --> M[tail.next = current.left]
    M --> N[tail = tail.next]
    L -- å¦ --> O{current.right éç©º?}
    N --> O
    O -- æ˜¯ --> P[tail.next = current.right]
    P --> Q[tail = tail.next]
    O -- å¦ --> R[current = current.next]
    Q --> R
    R --> J
    K --> E
```

### çŠ¶æ€è½¬ç§»å›¾ï¼ˆç¤ºä¾‹ï¼‰

```mermaid
graph LR
    subgraph "æ‰§è¡Œè¿‡ç¨‹: root = [1,2,3,4,5,null,7]"
        direction TB
        S1["ç¬¬0å±‚: currentLevelStart=1"] --> S1a["current=1, dummy=0, tail=0"]
        S1a --> S1b["å¤„ç†èŠ‚ç‚¹1: å·¦å­2, å³å­3"]
        S1b --> S1c["tail.next=2, tail=2; tail.next=3, tail=3"]
        S1c --> S1d["current=1.next=null"]
        S1d --> S1e["currentLevelStart=dummy.next=2"]

        S1e --> S2["ç¬¬1å±‚: currentLevelStart=2"]
        S2 --> S2a["current=2, dummy=0, tail=0"]
        S2a --> S2b["å¤„ç†èŠ‚ç‚¹2: å·¦å­4, å³å­5"]
        S2b --> S2c["tail.next=4, tail=4; tail.next=5, tail=5"]
        S2c --> S2d["current=2.next=3"]
        S2d --> S2e["å¤„ç†èŠ‚ç‚¹3: å³å­7"]
        S2e --> S2f["tail.next=7, tail=7"]
        S2f --> S2g["current=3.next=null"]
        S2g --> S2h["currentLevelStart=dummy.next=4"]

        S2h --> S3["ç¬¬2å±‚: currentLevelStart=4"]
        S3 --> S3a["current=4, dummy=0, tail=0"]
        S3a --> S3b["å¤„ç†èŠ‚ç‚¹4: æ— å­èŠ‚ç‚¹"]
        S3b --> S3c["current=4.next=5"]
        S3c --> S3d["å¤„ç†èŠ‚ç‚¹5: æ— å­èŠ‚ç‚¹"]
        S3d --> S3e["current=5.next=7"]
        S3e --> S3f["å¤„ç†èŠ‚ç‚¹7: æ— å­èŠ‚ç‚¹"]
        S3f --> S3g["current=7.next=null"]
        S3g --> S3h["currentLevelStart=dummy.next=null"]

        S3h --> S4["ç»“æŸ: è¿”å› root"]
    end

    %% æ ·å¼è®¾ç½®
    style S1 fill:#e6f3ff,stroke:#333
    style S2 fill:#e6f3ff,stroke:#333
    style S3 fill:#e6f3ff,stroke:#333
    style S4 fill:#6f9,stroke:#333
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: root = [1,2,3,4,5,null,7]

#### è¯¦ç»†æ‰§è¡Œæ­¥éª¤

åˆå§‹çŠ¶æ€ï¼š

```
        1
       / \
      2   3
     / \   \
    4   5   7
```

ç¬¬0å±‚ï¼ˆæ ¹å±‚ï¼‰ï¼š

- currentLevelStart = 1
- current = 1
- dummy = Node(0), tail = dummy
- å¤„ç†èŠ‚ç‚¹1ï¼š
  - å·¦å­2ï¼štail.next = 2, tail = 2
  - å³å­3ï¼štail.next = 3, tail = 3
- current = 1.next = null
- currentLevelStart = dummy.next = 2

ç¬¬1å±‚ï¼š

- currentLevelStart = 2
- current = 2
- dummy = Node(0), tail = dummy
- å¤„ç†èŠ‚ç‚¹2ï¼š
  - å·¦å­4ï¼štail.next = 4, tail = 4
  - å³å­5ï¼štail.next = 5, tail = 5
- current = 2.next = 3
- å¤„ç†èŠ‚ç‚¹3ï¼š
  - å³å­7ï¼štail.next = 7, tail = 7
- current = 3.next = null
- currentLevelStart = dummy.next = 4

ç¬¬2å±‚ï¼š

- currentLevelStart = 4
- current = 4
- dummy = Node(0), tail = dummy
- å¤„ç†èŠ‚ç‚¹4ï¼šæ— å­èŠ‚ç‚¹
- current = 4.next = 5
- å¤„ç†èŠ‚ç‚¹5ï¼šæ— å­èŠ‚ç‚¹
- current = 5.next = 7
- å¤„ç†èŠ‚ç‚¹7ï¼šæ— å­èŠ‚ç‚¹
- current = 7.next = null
- currentLevelStart = dummy.next = null

æœ€ç»ˆç»“æœï¼š

```
        1 â†’ null
       / \
      2 â†’ 3 â†’ null
     / \   \
    4â†’5â†’7 â†’ null
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type Node struct {
    Val   int
    Left  *Node
    Right *Node
    Next  *Node
}

func connect(root *Node) *Node {
    if root == nil {
        return nil
    }

    currentLevelStart := root

    for currentLevelStart != nil {
        current := currentLevelStart
        dummy := &Node{}
        tail := dummy

        for current != nil {
            if current.Left != nil {
                tail.Next = current.Left
                tail = tail.Next
            }
            if current.Right != nil {
                tail.Next = current.Right
                tail = tail.Next
            }
            current = current.Next
        }

        currentLevelStart = dummy.Next
    }

    return root
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®å±‚åºæ•°ç»„æ„å»ºäºŒå‰æ ‘
func buildTree(nums []interface{}) *Node {
    if len(nums) == 0 || nums[0] == nil {
        return nil
    }

    root := &Node{Val: nums[0].(int)}
    queue := []*Node{root}
    i := 1

    for len(queue) > 0 && i < len(nums) {
        node := queue[0]
        queue = queue[1:]

        if i < len(nums) && nums[i] != nil {
            node.Left = &Node{Val: nums[i].(int)}
            queue = append(queue, node.Left)
        }
        i++

        if i < len(nums) && nums[i] != nil {
            node.Right = &Node{Val: nums[i].(int)}
            queue = append(queue, node.Right)
        }
        i++
    }

    return root
}

// è¾…åŠ©å‡½æ•°ï¼šå±‚åºéå†å¹¶æ‰“å°nextæŒ‡é’ˆ
func printLevelOrder(root *Node) {
    if root == nil {
        fmt.Println("[]")
        return
    }

    result := []string{}
    currentLevelStart := root

    for currentLevelStart != nil {
        current := currentLevelStart
        for current != nil {
            result = append(result, fmt.Sprintf("%d", current.Val))
            current = current.Next
        }
        result = append(result, "#")
        currentLevelStart = currentLevelStart.Left
    }

    fmt.Printf("[%s]\n", joinStrings(result, ","))
}

func joinStrings(strs []string, sep string) string {
    result := ""
    for i, s := range strs {
        if i > 0 {
            result += sep
        }
        result += s
    }
    return result
}

func main() {
    // Test Case 1
    nums1 := []interface{}{1, 2, 3, 4, 5, nil, 7}
    tree1 := buildTree(nums1)
    connected1 := connect(tree1)
    fmt.Print("Test Case 1: ")
    printLevelOrder(connected1) // [1,#,2,3,#,4,5,7,#]

    // Test Case 2
    nums2 := []interface{}{}
    tree2 := buildTree(nums2)
    connected2 := connect(tree2)
    fmt.Print("Test Case 2: ")
    printLevelOrder(connected2) // []

    // Test Case 3
    nums3 := []interface{}{1}
    tree3 := buildTree(nums3)
    connected3 := connect(tree3)
    fmt.Print("Test Case 3: ")
    printLevelOrder(connected3) // [1,#]
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

æœ¬ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦

- æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ï¼šO(n) - æ¯ä¸ªèŠ‚ç‚¹åœ¨å…¶æ‰€åœ¨å±‚è¢«è®¿é—®ä¸€æ¬¡
- é“¾è¡¨æ„å»ºï¼šæ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹è¢«å¤„ç†ä¸€æ¬¡ï¼ŒO(n)
- å±‚çº§éå†ï¼šå¤–å±‚å¾ªç¯æ¬¡æ•°ç­‰äºæ ‘çš„é«˜åº¦hï¼Œå†…å±‚å¾ªç¯æ€»æ¬¡æ•°ä¸ºn
- æ€»æ—¶é—´ï¼šO(n) + O(n) = O(n)

#### B. ç©ºé—´å¤æ‚åº¦

- é¢å¤–ç©ºé—´ï¼šO(1) - ä»…ä½¿ç”¨äº†å‡ ä¸ªæŒ‡é’ˆå˜é‡ï¼ˆcurrentLevelStart, current, dummy, tailï¼‰
- é€’å½’æ ˆï¼šé¢˜ç›®è¯´æ˜ä¸è®¡é€’å½’æ ˆç©ºé—´
- æ€»ç©ºé—´ï¼šO(1)

#### C. æœ€å¥½/å¹³å‡/æœ€åæƒ…å†µåˆ†æ

| æƒ…å†µ           | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                             |
| -------------- | ---------- | ---------- | -------------------------------- |
| æœ€å¥½ï¼ˆå¹³è¡¡æ ‘ï¼‰ | O(n)       | O(1)       | æ¯å±‚èŠ‚ç‚¹æ•°å‡åŒ€åˆ†å¸ƒ               |
| å¹³å‡           | O(n)       | O(1)       | å…¸å‹äºŒå‰æ ‘                       |
| æœ€åï¼ˆé€€åŒ–æ ‘ï¼‰ | O(n)       | O(1)       | æ¯å±‚åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä½†ä»ç„¶O(n)æ—¶é—´ |

#### D. å¸¸æ•°å› å­åˆ†æ

- æŒ‡é’ˆæ“ä½œå¼€é”€ï¼šæŒ‡é’ˆèµ‹å€¼å’Œç§»åŠ¨
- é“¾è¡¨æ„å»ºå¼€é”€ï¼šè™šæ‹Ÿå¤´èŠ‚ç‚¹åˆ›å»ºå’Œå°¾æŒ‡é’ˆç§»åŠ¨
- è¯­è¨€ç‰¹æ€§å½±å“ï¼š
  - GoæŒ‡é’ˆæ“ä½œé«˜æ•ˆ
  - PythonåŠ¨æ€ç±»å‹ç®€åŒ–æ“ä½œ
  - TypeScriptç±»å‹æ£€æŸ¥å¢åŠ å®‰å…¨æ€§
  - Rustæ‰€æœ‰æƒç³»ç»Ÿå¢åŠ å¤æ‚æ€§

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆï¼šæŒ‡é’ˆæ“ä½œçš„é¢‘ç¹èµ‹å€¼
- ä¼˜åŒ–æ–¹å‘ï¼š
  - å‡å°‘ä¸å¿…è¦çš„æŒ‡é’ˆèµ‹å€¼
  - ä½¿ç”¨æ›´é«˜æ•ˆçš„é“¾è¡¨æ„å»ºæ–¹æ³•
  - åœ¨ç¼–è¯‘å™¨ä¼˜åŒ–ä¸‹ï¼ŒæŒ‡é’ˆæ“ä½œé€šå¸¸å·²ç»è¶³å¤Ÿé«˜æ•ˆ

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"å±‚çº§é“¾è¡¨æ„å»º"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. BFSä¸é“¾è¡¨æ„å»ºçš„ç»“åˆ
1. è™šæ‹Ÿå¤´èŠ‚ç‚¹æŠ€å·§
1. å¸¸é‡ç©ºé—´å®ç°
1. å¯æ‰©å±•åˆ°å¤šç§å±‚çº§ç»“æ„

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- å±‚åºéå†çš„å˜ä½“ï¼šå±‚çº§é“¾è¡¨æ„å»º = å±‚åºéå† + é“¾è¡¨è¿æ¥
- è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼šç®€åŒ–é“¾è¡¨æ„å»ºé€»è¾‘
- å¸¸é‡ç©ºé—´ï¼šåˆ©ç”¨nextæŒ‡é’ˆæ„å»ºé“¾è¡¨ï¼Œæ— éœ€é¢å¤–é˜Ÿåˆ—
- å¤ç”¨æ€§ï¼šç›´æ¥åŸºäº116é¢˜çš„è§£æ³•ï¼Œé€‚ç”¨äºæ™®é€šäºŒå‰æ ‘
- æ‰©å±•æ€§ï¼šå¯åº”ç”¨äºå…¶ä»–å±‚çº§é“¾è¡¨æ„å»ºåœºæ™¯

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®                             | æ ¸å¿ƒæ€æƒ³                   | åŒ¹é…æ¨¡å¼ |
| ---- | -------------------------------- | -------------------------- | -------- |
| 117  | æœ¬é¢˜                             | å¡«å……nextæŒ‡é’ˆ II            | æ ¸å¿ƒæ¨¡å¼ |
| 116  | å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ | å¡«å……nextæŒ‡é’ˆï¼ˆå®Œç¾äºŒå‰æ ‘ï¼‰ | åŸºç¡€æ¨¡å¼ |
| 102  | äºŒå‰æ ‘çš„å±‚åºéå†                 | æ­£å¸¸å±‚åºéå†               | ç›¸å…³æ¨¡å¼ |
| 103  | äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†           | å±‚åºéå†å˜ä½“               | ç›¸å…³æ¨¡å¼ |
| 429  | Nå‰æ ‘çš„å±‚åºéå†                  | Nå‰æ ‘å±‚åºéå†              | æ¨¡å¼æ‰©å±• |

#### C. æ¨¡å¼æ³›åŒ–

- Nå‰æ ‘nextæŒ‡é’ˆï¼šNå‰æ ‘çš„å±‚çº§é“¾è¡¨æ„å»º
- å›¾çš„å±‚çº§é“¾è¡¨ï¼šå›¾çš„å±‚çº§é“¾è¡¨æ„å»º
- ç»„ç»‡ç»“æ„ï¼šå…¬å¸ç»„ç»‡ç»“æ„çš„å±‚çº§é“¾è¡¨
- æ–‡ä»¶ç³»ç»Ÿï¼šç›®å½•æ ‘çš„å±‚çº§é“¾è¡¨
- ç½‘ç»œæ‹“æ‰‘ï¼šç½‘ç»œèŠ‚ç‚¹çš„å±‚çº§é“¾è¡¨

#### D. å·¥ä¸šåº”ç”¨

- ç»„ç»‡ç»“æ„å›¾ï¼šæ„å»ºå…¬å¸å±‚çº§é“¾è¡¨
- æ–‡ä»¶ç³»ç»Ÿï¼šæ„å»ºç›®å½•å±‚çº§é“¾è¡¨
- ç½‘ç»œè·¯ç”±ï¼šæ„å»ºè·¯ç”±å±‚çº§é“¾è¡¨
- æ¸¸æˆåœºæ™¯ï¼šæ„å»ºåœºæ™¯å±‚çº§é“¾è¡¨
- æ•°æ®åº“ç´¢å¼•ï¼šæ„å»ºBæ ‘å±‚çº§é“¾è¡¨

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆé€‰æ‹©è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Ÿ
   - ç®€åŒ–é“¾è¡¨æ„å»ºé€»è¾‘ï¼Œé¿å…ç©ºæŒ‡é’ˆåˆ¤æ–­
   - ç»Ÿä¸€å¤„ç†å¤´èŠ‚ç‚¹å’Œéå¤´èŠ‚ç‚¹
   - ä»£ç æ›´ç®€æ´ï¼Œå¯è¯»æ€§æ›´é«˜

1. ä¸ºä»€ä¹ˆå¿…é¡»ä¿æŒå­èŠ‚ç‚¹å¤„ç†é¡ºåºï¼Ÿ
   - å­èŠ‚ç‚¹å¤„ç†é¡ºåºå†³å®šäº†é“¾è¡¨çš„æ„å»ºé¡ºåº
   - å¿…é¡»ä¿æŒå…ˆå·¦åå³çš„é¡ºåº
   - å¦åˆ™ä¼šå¯¼è‡´é“¾è¡¨é¡ºåºé”™è¯¯

1. å¸¸é‡ç©ºé—´å¦‚ä½•å®ç°ï¼Ÿ
   - åˆ©ç”¨nextæŒ‡é’ˆæ„å»ºä¸‹ä¸€å±‚é“¾è¡¨
   - é€šè¿‡currentæŒ‡é’ˆéå†å½“å‰å±‚
   - æ— éœ€é¢å¤–é˜Ÿåˆ—å­˜å‚¨èŠ‚ç‚¹

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿï¼š

1. å¯¹BFSå’Œé“¾è¡¨æ„å»ºçš„ç†è§£
1. å¸¸é‡ç©ºé—´å®ç°çš„èƒ½åŠ›
1. ä»åŸºç¡€åˆ°å˜ä½“çš„æ‰©å±•èƒ½åŠ›
1. ä¸åŒå®ç°æ–¹å¼çš„æƒè¡¡

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆé€‰æ‹©BFSè€Œä¸æ˜¯DFSï¼Ÿ

â†’ æ ‡å‡†: BFSå¤©ç„¶æŒ‰å±‚è®¿é—®ï¼Œä¸nextæŒ‡é’ˆè¿æ¥å®Œå…¨åŒ¹é…
â†’ åŠ åˆ†: DFSéœ€è¦é¢å¤–è®°å½•å±‚æ•°å’Œå‰é©±èŠ‚ç‚¹ï¼Œå®ç°å¤æ‚

#### Q2: è™šæ‹Ÿå¤´èŠ‚ç‚¹çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ

â†’ æ ‡å‡†: ç®€åŒ–é“¾è¡¨æ„å»ºé€»è¾‘ï¼Œé¿å…ç©ºæŒ‡é’ˆåˆ¤æ–­
â†’ åŠ åˆ†: è¯´æ˜è™šæ‹Ÿå¤´èŠ‚ç‚¹ç»Ÿä¸€å¤„ç†å¤´èŠ‚ç‚¹å’Œéå¤´èŠ‚ç‚¹ï¼Œä»£ç æ›´ç®€æ´

#### Q3: å¦‚ä½•å¤„ç†ç©ºæ ‘çš„æƒ…å†µï¼Ÿ

â†’ æ ‡å‡†: åœ¨å‡½æ•°å¼€å§‹æ—¶æ£€æŸ¥rootæ˜¯å¦ä¸ºnull
â†’ åŠ åˆ†: æä¾›å…·ä½“ä»£ç å®ç°ï¼Œå±•ç¤ºè¾¹ç•Œå¤„ç†

#### Q4: è¿™ä¸ªç®—æ³•å’Œ116é¢˜æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

â†’ æ ‡å‡†: 116é¢˜é€‚ç”¨äºå®Œç¾äºŒå‰æ ‘ï¼Œæœ¬é¢˜é€‚ç”¨äºæ™®é€šäºŒå‰æ ‘
â†’ åŠ åˆ†: æœ¬é¢˜è§£æ³•å¯ä»¥ç›´æ¥ç”¨äº116é¢˜ï¼Œä½†116é¢˜çš„è§£æ³•ä¸èƒ½ç”¨äºæœ¬é¢˜

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°é€’å½’ç‰ˆæœ¬çš„nextæŒ‡é’ˆå¡«å……ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨é€’å½’éå†ï¼Œè¿æ¥è·¨å­æ ‘çš„èŠ‚ç‚¹
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// é€’å½’å®ç°
func connect(root *Node) *Node {
    if root == nil {
        return nil
    }

    // è¿æ¥å·¦å­æ ‘çš„æœ€å³èŠ‚ç‚¹å’Œå³å­æ ‘çš„æœ€å·¦èŠ‚ç‚¹
    if root.Left != nil && root.Right != nil {
        root.Left.Next = root.Right
    }

    // è¿æ¥è·¨å­æ ‘çš„èŠ‚ç‚¹
    if root.Left != nil && root.Right == nil {
        root.Left.Next = findNext(root.Next)
    }

    if root.Right != nil {
        root.Right.Next = findNext(root.Next)
    }

    // æ³¨æ„ï¼šå¿…é¡»å…ˆå¤„ç†å³å­æ ‘ï¼Œå†å¤„ç†å·¦å­æ ‘
    // å› ä¸ºå³å­æ ‘å¯èƒ½ä¾èµ–å·¦å­æ ‘çš„nextæŒ‡é’ˆ
    connect(root.Right)
    connect(root.Left)

    return root
}

// è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾ä¸‹ä¸€ä¸ªæœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹
func findNext(node *Node) *Node {
    for node != nil {
        if node.Left != nil {
            return node.Left
        }
        if node.Right != nil {
            return node.Right
        }
        node = node.Next
    }
    return nil
}
```

#### Q2: å¦‚ä½•å®ç°Nå‰æ ‘çš„nextæŒ‡é’ˆå¡«å……ï¼Ÿ

â†’ æ ‡å‡†: å¤ç”¨Nå‰æ ‘å±‚åºéå†é€»è¾‘ï¼Œæ„å»ºå±‚çº§é“¾è¡¨
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// Nå‰æ ‘èŠ‚ç‚¹å®šä¹‰
type Node struct {
    Val      int
    Children []*Node
    Next     *Node
}

func connect(root *Node) *Node {
    if root == nil {
        return nil
    }

    currentLevelStart := root

    for currentLevelStart != nil {
        current := currentLevelStart
        dummy := &Node{}
        tail := dummy

        for current != nil {
            // éå†æ‰€æœ‰å­èŠ‚ç‚¹
            for _, child := range current.Children {
                if child != nil {
                    tail.Next = child
                    tail = tail.Next
                }
            }
            current = current.Next
        }

        currentLevelStart = dummy.Next
    }

    return root
}
```

#### Q3: å¦‚ä½•ä¼˜åŒ–Rustçš„å®ç°ï¼Ÿ

â†’ æ ‡å‡†: å‡å°‘ä¸å¿…è¦çš„å…‹éš†ï¼Œä½¿ç”¨å¼•ç”¨
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–åçš„ä»£ç 

```rust
// ä¼˜åŒ–ç‰ˆï¼šä½¿ç”¨å¼•ç”¨é¿å…å…‹éš†
impl Solution {
    pub fn connect(root: Option<Box<Node>>) -> Option<Box<Node>> {
        let mut root = root;
        let mut current_level_start = root.as_ref();

        while let Some(start) = current_level_start {
            let mut current = start;
            let mut dummy = Box::new(Node::new(0));
            let mut tail = &mut dummy;

            while let Some(node) = current {
                // å¤„ç†å·¦å­èŠ‚ç‚¹
                if let Some(left) = &node.left {
                    tail.next = Some(Box::new(Node {
                        val: left.val,
                        left: None,  // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ä¿ç•™å­æ ‘ç»“æ„
                        right: None,
                        next: None,
                    }));
                    tail = tail.next.as_mut().unwrap();
                }

                // å¤„ç†å³å­èŠ‚ç‚¹
                if let Some(right) = &node.right {
                    tail.next = Some(Box::new(Node {
                        val: right.val,
                        left: None,
                        right: None,
                        next: None,
                    }));
                    tail = tail.next.as_mut().unwrap();
                }

                current = node.next.as_ref();
            }

            current_level_start = dummy.next.as_ref();
        }

        root
    }
}
```

æ³¨æ„ï¼šRustå®ç°è¾ƒä¸ºå¤æ‚ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦æ›´æ·±å…¥çš„ä¼˜åŒ–

#### Q4: å¦‚ä½•å®ç°äºŒå‰æ ‘çš„åå‘nextæŒ‡é’ˆï¼Ÿ

â†’ æ ‡å‡†: ä¿®æ”¹é“¾è¡¨æ„å»ºæ–¹å‘ï¼Œä»å³åˆ°å·¦è¿æ¥
â†’ åŠ åˆ†: æä¾›å…·ä½“å®ç°

```go
// åå‘nextæŒ‡é’ˆï¼šä»å³åˆ°å·¦è¿æ¥
func connectReverse(root *Node) *Node {
    if root == nil {
        return nil
    }

    currentLevelStart := root

    for currentLevelStart != nil {
        current := currentLevelStart
        dummy := &Node{}
        tail := dummy

        for current != nil {
            // å…ˆå¤„ç†å³å­èŠ‚ç‚¹ï¼Œå†å¤„ç†å·¦å­èŠ‚ç‚¹
            if current.Right != nil {
                tail.Next = current.Right
                tail = tail.Next
            }
            if current.Left != nil {
                tail.Next = current.Left
                tail = tail.Next
            }
            current = current.Next
        }

        currentLevelStart = dummy.Next
    }

    return root
}
```

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®ï¼š

1. BFSä¸é“¾è¡¨æ„å»ºçš„ç»“åˆ
1. è™šæ‹Ÿå¤´èŠ‚ç‚¹æŠ€å·§
1. å¸¸é‡ç©ºé—´å®ç°
1. å±‚çº§éå†çš„å˜ä½“

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹           | å£è¯€                       |
| ---------------- | -------------------------- |
| nextæŒ‡é’ˆå¡«å……æ ¸å¿ƒ | å±‚åºéå† + é“¾è¡¨æ„å»º        |
| è™šæ‹Ÿå¤´èŠ‚ç‚¹       | ç®€åŒ–é“¾è¡¨æ„å»ºï¼Œé¿å…ç©ºæŒ‡é’ˆ   |
| å¸¸é‡ç©ºé—´         | åˆ©ç”¨nextæŒ‡é’ˆï¼Œæ— éœ€é¢å¤–é˜Ÿåˆ— |
| å­èŠ‚ç‚¹å¤„ç†é¡ºåº   | å…ˆå·¦åå³ï¼Œä¿æŒé“¾è¡¨é¡ºåº     |
| ç©ºæ ‘å¤„ç†         | å…ˆæ£€æŸ¥rootä¸ºç©º             |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹           | è§¦å‘åœºæ™¯             | åº”å¯¹æªæ–½                        |
| ------------------ | -------------------- | ------------------------------- |
| å¿˜è®°åˆ‡æ¢å±‚çº§       | æ‰€æœ‰èŠ‚ç‚¹è¿æ¥åˆ°åŒä¸€å±‚ | æ¯å±‚ç»“æŸæ—¶åˆ‡æ¢currentLevelStart |
| å­èŠ‚ç‚¹å¤„ç†é¡ºåºé”™è¯¯ | é“¾è¡¨é¡ºåºé”™è¯¯         | ä¿æŒå…ˆå·¦åå³çš„å¤„ç†é¡ºåº          |
| ç©ºæ ‘æœªå¤„ç†         | rootä¸ºnullæ—¶å´©æºƒ     | å‡½æ•°å¼€å§‹æ£€æŸ¥rootä¸ºç©º            |
| æŒ‡é’ˆæ“ä½œé”™è¯¯       | é“¾è¡¨æ–­è£‚æˆ–å¾ªç¯       | ç¡®ä¿æŒ‡é’ˆèµ‹å€¼æ­£ç¡®ï¼Œé¿å…å¾ªç¯å¼•ç”¨  |
| é—æ¼èŠ‚ç‚¹           | æŸäº›èŠ‚ç‚¹æœªè¿æ¥       | ç¡®ä¿éå†æ‰€æœ‰èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹        |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯              | åº”ç”¨åœºæ™¯           |
| ------------------- | ------------------ |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ | æè¿°ç®—æ³•é€‰æ‹©       |
| è™šæ‹Ÿå¤´èŠ‚ç‚¹          | è¯´æ˜é“¾è¡¨æ„å»ºæŠ€å·§   |
| å¸¸é‡ç©ºé—´            | å¼ºè°ƒç©ºé—´å¤æ‚åº¦ä¼˜åŠ¿ |
| å±‚åºéå†å˜ä½“        | å‘½åç®—æ³•èŒƒå¼       |
| æ—¶é—´å¤æ‚åº¦O(n)      | å¤æ‚åº¦åˆ†æ         |
| ç©ºé—´å¤æ‚åº¦O(1)      | å¤æ‚åº¦åˆ†æ         |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: å±‚çº§é“¾è¡¨æ„å»º
â”œâ”€â”€ å¿…è¦æ¡ä»¶: BFS + è™šæ‹Ÿå¤´èŠ‚ç‚¹
â”œâ”€â”€ æœ¬è´¨: å±‚åºéå† + é“¾è¡¨è¿æ¥
â”œâ”€â”€ æ–¹æ³•: å±‚åºéå† + é“¾è¡¨æ„å»º
â”‚   â”œâ”€â”€ åˆå§‹åŒ–: currentLevelStart = root
â”‚   â”œâ”€â”€ å¤–å±‚å¾ªç¯: å½“å‰å±‚éç©º
â”‚   â”œâ”€â”€ å†…å±‚å¾ªç¯: éå†å½“å‰å±‚èŠ‚ç‚¹
â”‚   â”œâ”€â”€ é“¾è¡¨æ„å»º: è™šæ‹Ÿå¤´èŠ‚ç‚¹ + å°¾æŒ‡é’ˆ
â”‚   â”œâ”€â”€ å­èŠ‚ç‚¹å¤„ç†: å…ˆå·¦åå³
â”‚   â””â”€â”€ å±‚çº§åˆ‡æ¢: currentLevelStart = dummy.next
â”œâ”€â”€ ä¼˜åŒ–: é€’å½’å®ç°ã€Nå‰æ ‘æ‰©å±•
â”œâ”€â”€ å˜ä½“: åå‘nextæŒ‡é’ˆã€è·¨å­æ ‘è¿æ¥
â””â”€â”€ åº”ç”¨: ç»„ç»‡ç»“æ„ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œæ‹“æ‰‘
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆï¼ˆBFS+è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼‰
å‡½æ•° connect(root):
    if root ä¸ºç©º: return null
    currentLevelStart = root

    while currentLevelStart ä¸ä¸ºç©º:
        current = currentLevelStart
        dummy = æ–°èŠ‚ç‚¹(0)
        tail = dummy

        while current ä¸ä¸ºç©º:
            if current.left éç©º:
                tail.next = current.left
                tail = tail.next
            if current.right éç©º:
                tail.next = current.right
                tail = tail.next
            current = current.next

        currentLevelStart = dummy.next

    return root

// é€’å½’ç‰ˆï¼ˆè·¨å­æ ‘è¿æ¥ï¼‰
å‡½æ•° connectRecursive(root):
    if root ä¸ºç©º: return null

    if root.left éç©ºä¸” root.right éç©º:
        root.left.next = root.right

    if root.left éç©ºä¸” root.right ä¸ºç©º:
        root.left.next = findNext(root.next)

    if root.right éç©º:
        root.right.next = findNext(root.next)

    connectRecursive(root.right)  // æ³¨æ„ï¼šå…ˆå³åå·¦
    connectRecursive(root.left)

    return root

å‡½æ•° findNext(node):
    while node ä¸ä¸ºç©º:
        if node.left éç©º: return node.left
        if node.right éç©º: return node.right
        node = node.next
    return null
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³nextæŒ‡é’ˆå¡«å……ç›¸å…³é—®é¢˜ï¼Œå¹¶å±•ç°å¯¹æ ‘ç»“æ„éå†ç®—æ³•å’Œé“¾è¡¨æ„å»ºæŠ€å·§çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
