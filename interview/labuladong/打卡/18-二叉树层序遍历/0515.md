# LeetCode 515 - åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

## 1. é¢˜ç›®æè¿°

ç»™å®šä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root`ï¼Œè¯·åœ¨æ¯å±‚ä¸­æ‰¾åˆ°è¯¥å±‚èŠ‚ç‚¹å€¼çš„æœ€å¤§å€¼ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å«æ¯å±‚æœ€å¤§å€¼çš„åˆ—è¡¨

### ç¤ºä¾‹ 1

```
è¾“å…¥ï¼šroot = [1,3,2,5,3,null,9]
è¾“å‡ºï¼š[1,3,9]
```

### ç¤ºä¾‹ 2

```
è¾“å…¥ï¼šroot = [1,2,3]
è¾“å‡ºï¼š[1,3]
```

### ç¤ºä¾‹ 3

```
è¾“å…¥ï¼šroot = [1]
è¾“å‡ºï¼š[1]
```

### ç¤ºä¾‹ 4

```
è¾“å…¥ï¼šroot = []
è¾“å‡ºï¼š[]
```

### çº¦æŸæ¡ä»¶

- æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 10â´]` å†…
- `-2Â³Â¹ <= Node.val <= 2Â³Â¹ - 1`

## 2. è§£æ³•åˆ†æï¼šBFS + å±‚çº§æœ€å¤§å€¼è¿½è¸ª

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ å±‚çº§æœ€å¤§å€¼è¿½è¸ªï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. è‡ªç„¶åŒ¹é…å±‚åºç»“æ„ - BFSå¤©ç„¶æŒ‰å±‚è®¿é—®èŠ‚ç‚¹
1. å•æ¬¡éå†è·å–æœ€å¤§å€¼ - æ¯å±‚éå†æ—¶åŠ¨æ€æ›´æ–°æœ€å¤§å€¼
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - O(n)æ—¶é—´è®¿é—®æ‰€æœ‰èŠ‚ç‚¹
1. ç©ºé—´å¤æ‚åº¦å¯æ§ - O(n)ç©ºé—´å­˜å‚¨é˜Ÿåˆ—
1. å®ç°æ¸…æ™°ç›´è§‚ - ä»£ç é€»è¾‘æ˜“äºç†è§£

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆBFS+å±‚çº§æœ€å¤§å€¼è¿½è¸ªæ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å±‚åºéå†çš„åŸºç¡€ï¼šæ¯å±‚æœ€å¤§å€¼éœ€æŒ‰å±‚è®¡ç®—
1. BFSçš„ç‰¹æ€§ï¼šæŒ‰å±‚è®¿é—®èŠ‚ç‚¹ï¼Œä¸é¢˜ç›®è¦æ±‚å®Œå…¨åŒ¹é…
1. åŠ¨æ€æ›´æ–°æœ€å¤§å€¼ï¼šæ¯å±‚å†…éå†æ—¶ç»´æŠ¤å½“å‰æœ€å¤§å€¼ï¼Œæ— éœ€é¢å¤–å­˜å‚¨
1. å¤ç”¨æ€§å¼ºï¼šåŸºäº102é¢˜çš„BFSå®ç°
1. æ€§èƒ½ä¼˜å¼‚ï¼šæ¯ä¸ªèŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡ï¼Œæ— é‡å¤è®¡ç®—

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•                   | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                     |
| ---------------------- | -------- | ---------- | ---------- | -------- | ------------------------ |
| BFS+å±‚çº§æœ€å¤§å€¼ï¼ˆæœ¬è§£ï¼‰ | âœ…       | O(n)       | O(n)       | ä½       | é¢è¯•é¦–é€‰ï¼Œå®ç°ç®€å•       |
| DFS+å±‚çº§è®°å½•           | âœ…       | O(n)       | O(h)       | ä¸­       | ç©ºé—´æ›´ä¼˜ï¼Œä½†éœ€é¢å¤–å“ˆå¸Œè¡¨ |
| é€’å½’+å±‚æ•°å‚æ•°          | âœ…       | O(n)       | O(h)       | ä¸­       | ä»£ç ç®€æ´ï¼Œä½†æ ˆæ·±åº¦å—é™   |
| å…ˆå±‚åºå†æ’åº           | âœ…       | O(n log n) | O(n)       | ä¸­       | æ—¶é—´å¤æ‚åº¦å·®ï¼Œä¸æ¨è     |

> BFS+å±‚çº§æœ€å¤§å€¼è¿½è¸ªæ˜¯æœ€ç›´æ¥ã€æœ€é«˜æ•ˆã€æœ€ç¬¦åˆå·¥ç¨‹å®è·µçš„è§£å†³æ–¹æ¡ˆ

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. æ ‘ç»“æ„ï¼šé€‚ç”¨äºä»»ä½•äºŒå‰æ ‘
1. ç©ºæ ‘å¤„ç†ï¼šéœ€ç‰¹æ®Šå¤„ç†rootä¸ºnullçš„æƒ…å†µ
1. æ•°å€¼èŒƒå›´ï¼šé¢˜ç›®ä¸­åŒ…å«æœ€å°æ•´æ•°ï¼Œåˆå§‹åŒ–æœ€å¤§å€¼éœ€ä½¿ç”¨`math.MinInt32`
1. å±‚åºè¦æ±‚ï¼šç»“æœå¿…é¡»æŒ‰ä»ä¸Šåˆ°ä¸‹çš„å±‚çº§é¡ºåºè¾“å‡º

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. å¤ç”¨æ€§ï¼šåŸºäº102é¢˜çš„BFSæ¡†æ¶
1. æ€§èƒ½ï¼šæ¯å±‚ä»…éå†ä¸€æ¬¡ï¼Œæœ€å¤§å€¼å³æ—¶æ›´æ–°
1. å¯è¯»æ€§ï¼šé€»è¾‘æ¸…æ™°ï¼Œæ˜“è°ƒè¯•
1. æ‰©å±•æ€§ï¼šå¯è½»æ¾æ‰©å±•ä¸ºæ±‚æœ€å°å€¼ã€å¹³å‡å€¼ç­‰

### æ€»ç»“

å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰+ å±‚çº§æœ€å¤§å€¼è¿½è¸ªæ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ—¶é—´/ç©ºé—´æ•ˆç‡å’Œå·¥ç¨‹å®ç°å¤æ‚åº¦ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶å±•ç¤ºä¸åŒè¯­è¨€åœ¨é˜Ÿåˆ—æ“ä½œã€è¾¹ç•Œå¤„ç†å’Œæ•°å€¼ç±»å‹ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func largestValues(root *TreeNode) []int {
    // å¤„ç†ç©ºæ ‘
    if root == nil {
        return []int{}
    }

    result := []int{}           // å­˜å‚¨æ¯å±‚æœ€å¤§å€¼
    queue := []*TreeNode{root}  // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œæ”¾å…¥æ ¹èŠ‚ç‚¹

    for len(queue) > 0 {
        levelSize := len(queue)  // å½“å‰å±‚èŠ‚ç‚¹æ•°
        maxVal := queue[0].Val   // åˆå§‹åŒ–æœ€å¤§å€¼ä¸ºå½“å‰å±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼

        // éå†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < levelSize; i++ {
            node := queue[0]     // å–é˜Ÿé¦–èŠ‚ç‚¹
            queue = queue[1:]    // å‡ºé˜Ÿ

            // åŠ¨æ€æ›´æ–°æœ€å¤§å€¼
            if node.Val > maxVal {
                maxVal = node.Val
            }

            // å°†å­èŠ‚ç‚¹å…¥é˜Ÿï¼ˆå…ˆå·¦åå³ï¼‰
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        // å°†å½“å‰å±‚æœ€å¤§å€¼åŠ å…¥ç»“æœ
        result = append(result, maxVal)
    }

    return result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if root == nil` - ä¿è¯è¾“å…¥åˆæ³•æ€§ï¼Œé¿å…åç»­panic
1. ç»“æœå®¹å™¨ï¼š`result` - åˆ‡ç‰‡å­˜å‚¨æ¯å±‚æœ€å¤§å€¼ï¼ŒæŒ‰å±‚é¡ºåºè¿½åŠ 
1. é˜Ÿåˆ—åˆå§‹åŒ–ï¼š`queue := []*TreeNode{root}` - ä½¿ç”¨åˆ‡ç‰‡æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œåˆå§‹æ”¾å…¥æ ¹èŠ‚ç‚¹
1. å±‚çº§å¾ªç¯ï¼š`for len(queue) > 0` - é˜Ÿåˆ—éç©ºæ—¶ç»§ç»­å¤„ç†ä¸‹ä¸€å±‚
1. å±‚å¤§å°è®°å½•ï¼š`levelSize := len(queue)` - è®°å½•å½“å‰å±‚èŠ‚ç‚¹æ•°ï¼Œç”¨äºæ§åˆ¶å†…å±‚å¾ªç¯æ¬¡æ•°
1. æœ€å¤§å€¼åˆå§‹åŒ–ï¼š`maxVal := queue[0].Val` - ä»¥å½“å‰å±‚é¦–ä¸ªèŠ‚ç‚¹ä¸ºåˆå§‹æœ€å¤§å€¼ï¼Œé¿å…ä½¿ç”¨`math.MinInt32`ï¼Œå‡å°‘ä¾èµ–
1. èŠ‚ç‚¹å¤„ç†å¾ªç¯ï¼š`for i := 0; i < levelSize; i++`
   - `node := queue[0]; queue = queue[1:]` - å‡ºé˜Ÿæ“ä½œï¼ˆGoåˆ‡ç‰‡å¤´éƒ¨å¼¹å‡ºï¼‰
   - `if node.Val > maxVal` - å®æ—¶æ¯”è¾ƒå¹¶æ›´æ–°æœ€å¤§å€¼ï¼Œæ— éœ€é¢å¤–æ•°ç»„å­˜å‚¨æ•´å±‚èŠ‚ç‚¹
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼š`if node.Left != nil` / `if node.Right != nil` - æŒ‰é¡ºåºæ·»åŠ å­èŠ‚ç‚¹ï¼Œç¡®ä¿ä¸‹ä¸€å±‚é¡ºåºæ­£ç¡®
1. ç»“æœè¿½åŠ ï¼š`result = append(result, maxVal)` - æ¯å±‚å¤„ç†å®Œæ¯•åç«‹å³åŠ å…¥ç»“æœ

è®¾è®¡åŠ¨æœºï¼š

- ä½¿ç”¨åˆ‡ç‰‡æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œé¿å…å¼•å…¥`container/list`ï¼Œå‡å°‘ä¾èµ–
- æœ€å¤§å€¼åˆå§‹åŒ–å–ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼ï¼Œé¿å…ä½¿ç”¨å…¨å±€æœ€å°å€¼ï¼Œå¢å¼ºé²æ£’æ€§
- æ¯å±‚ä»…éå†ä¸€æ¬¡ï¼Œæ— å†—ä½™è®¡ç®—ï¼Œæ—¶é—´æ•ˆç‡æœ€ä¼˜
- æ‰€æœ‰æ“ä½œå‡ä¸ºåŸåœ°æ›´æ–°ï¼Œå†…å­˜å¸ƒå±€è¿ç»­ï¼Œç¼“å­˜å‹å¥½

### B. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque

class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []

        result = []
        queue = deque([root])  # ä½¿ç”¨åŒç«¯é˜Ÿåˆ—æé«˜å‡ºé˜Ÿæ•ˆç‡

        while queue:
            level_size = len(queue)
            max_val = queue[0].val  # åˆå§‹åŒ–æœ€å¤§å€¼ä¸ºå½“å‰å±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼

            for _ in range(level_size):
                node = queue.popleft()  # é«˜æ•ˆå‡ºé˜Ÿ

                if node.val > max_val:
                    max_val = node.val

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

            result.append(max_val)

        return result
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if not root` - Pythoné£æ ¼çš„å¸ƒå°”åˆ¤æ–­ï¼Œç®€æ´å®‰å…¨
1. ç»“æœå®¹å™¨ï¼š`result` - åˆ—è¡¨å­˜å‚¨æ¯å±‚æœ€å¤§å€¼
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`deque` - ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ä¼˜åŒ–å‡ºé˜Ÿæ“ä½œï¼ˆO(1) vs åˆ—è¡¨pop(0)çš„O(n)ï¼‰
1. å±‚çº§å¾ªç¯ï¼š`while queue` - é˜Ÿåˆ—éç©ºæ—¶æŒç»­å¤„ç†
1. å±‚å¤§å°è®°å½•ï¼š`level_size = len(queue)` - ç²¾å‡†æ§åˆ¶å½“å‰å±‚èŠ‚ç‚¹æ•°
1. æœ€å¤§å€¼åˆå§‹åŒ–ï¼š`max_val = queue[0].val` - é¦–èŠ‚ç‚¹å€¼åˆå§‹åŒ–ï¼Œé¿å…`-float('inf')`ï¼Œæé«˜æ•°å€¼ç¨³å®šæ€§
1. èŠ‚ç‚¹å¤„ç†ï¼š`node = queue.popleft()` - é«˜æ•ˆå‡ºé˜Ÿ
1. æœ€å¤§å€¼æ›´æ–°ï¼š`if node.val > max_val` - æ¯èŠ‚ç‚¹ä»…ä¸€æ¬¡æ¯”è¾ƒï¼Œçº¿æ€§æ—¶é—´
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼š`queue.append()` - æŒ‰å·¦â†’å³é¡ºåºå…¥é˜Ÿï¼Œä¿æŒå±‚åº
1. ç»“æœè¿½åŠ ï¼š`result.append(max_val)` - æ¯å±‚ç»“æŸæ—¶è¿½åŠ æœ€å¤§å€¼

Pythonç‰¹æ€§ï¼š

- `deque`æ˜¾è‘—æå‡æ€§èƒ½ï¼ˆç›¸æ¯”åˆ—è¡¨ï¼‰
- `popleft()` ä¸ºO(1)æ“ä½œ
- ä»£ç æç®€ï¼Œè¯­ä¹‰æ¸…æ™°
- æ— éœ€æ˜¾å¼ç±»å‹å£°æ˜ï¼Œé€‚åˆå¿«é€Ÿå¼€å‘

### C. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function largestValues(root: TreeNode | null): number[] {
    if (!root) {
        return [];
    }

    const result: number[] = [];
    const queue: TreeNode[] = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        let maxVal = queue[0].val; // åˆå§‹åŒ–æœ€å¤§å€¼ä¸ºç¬¬ä¸€èŠ‚ç‚¹å€¼

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift()!; // TypeScriptéç©ºæ–­è¨€

            if (node.val > maxVal) {
                maxVal = node.val;
            }

            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }

        result.push(maxVal);
    }

    return result;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if (!root)` - TypeScriptç©ºå€¼åˆ¤æ–­
1. ç±»å‹å®‰å…¨ï¼š`const result: number[]` - æ˜ç¡®è¿”å›ç±»å‹ï¼Œæå‡ä»£ç å¯ç»´æŠ¤æ€§
1. é˜Ÿåˆ—å®ç°ï¼šä½¿ç”¨æ™®é€šæ•°ç»„æ¨¡æ‹Ÿé˜Ÿåˆ—ï¼ˆJavaScriptæ— å†…ç½®é˜Ÿåˆ—ï¼‰
1. å±‚çº§å¾ªç¯ï¼š`while (queue.length > 0)` - æŒç»­å¤„ç†ç›´åˆ°å±‚ç©º
1. å±‚å¤§å°è®°å½•ï¼š`levelSize = queue.length` - æ•æ‰å½“å‰å±‚èŠ‚ç‚¹æ•°é‡
1. æœ€å¤§å€¼åˆå§‹åŒ–ï¼š`maxVal = queue[0].val` - é¦–èŠ‚ç‚¹åˆå§‹åŒ–ï¼Œè§„é¿`-Infinity`ç²¾åº¦é—®é¢˜
1. èŠ‚ç‚¹å¤„ç†ï¼š`queue.shift()!` - ä½¿ç”¨éç©ºæ–­è¨€`!`ï¼Œå› å·²æ£€æŸ¥`root`éç©ºä¸”å±‚çº§éç©º
1. æœ€å¤§å€¼æ›´æ–°ï¼š`if (node.val > maxVal)` - åŸåœ°æ¯”è¾ƒï¼ŒO(1)æ›´æ–°
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼š`queue.push()` - æŒ‰å·¦â†’å³é¡ºåº
1. ç»“æœè¿½åŠ ï¼š`result.push(maxVal)` - æ¯å±‚å®Œæˆç«‹å³è®°å½•

TypeScriptç‰¹æ€§ï¼š

- ç±»å‹ç³»ç»Ÿä¿éšœå®‰å…¨æ€§ï¼Œé¿å…è¿è¡Œæ—¶é”™è¯¯
- `shift()` æ˜¯O(n)æ“ä½œï¼Œåœ¨å¤§æ•°æ®é›†ä¸‹æ€§èƒ½ç“¶é¢ˆï¼ˆå»ºè®®ä½¿ç”¨åŒç«¯é˜Ÿåˆ—åº“å¦‚`collections/deque`ï¼‰
- éç©ºæ–­è¨€`!`éœ€è°¨æ…ä½¿ç”¨ï¼Œæ­¤å¤„åˆç†ï¼ˆå› å±‚çº§éç©ºï¼‰

### D. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::VecDeque;

impl Solution {
    pub fn largest_values(root: Option<Box<TreeNode>>) -> Vec<i32> {
        let mut result = Vec::new();
        let mut queue = VecDeque::new();

        // å¤„ç†ç©ºæ ‘
        if let Some(node) = root {
            queue.push_back(node);
        }

        while !queue.is_empty() {
            let level_size = queue.len();
            let mut max_val = queue[0].val; // åˆå§‹åŒ–ä¸ºå½“å‰å±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼

            // éå†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
            for _ in 0..level_size {
                if let Some(node) = queue.pop_front() {
                    if node.val > max_val {
                        max_val = node.val;
                    }

                    // å°†å­èŠ‚ç‚¹å…¥é˜Ÿ
                    if let Some(left) = node.left {
                        queue.push_back(left);
                    }
                    if let Some(right) = node.right {
                        queue.push_back(right);
                    }
                }
            }

            result.push(max_val);
        }

        result
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. ç©ºæ ‘å¤„ç†ï¼š`if let Some(node) = root` - Rustæ¨¡å¼åŒ¹é…ï¼Œå®‰å…¨æå–å€¼
1. é˜Ÿåˆ—é€‰æ‹©ï¼š`VecDeque` - Rustæ ‡å‡†åº“ä¸­é«˜æ•ˆåŒç«¯é˜Ÿåˆ—
1. ç»“æœå®¹å™¨ï¼š`Vec<i32>` - åŠ¨æ€æ•°ç»„ï¼Œè‡ªåŠ¨æ‰©å®¹
1. å±‚çº§å¾ªç¯ï¼š`while !queue.is_empty()` - æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
1. å±‚å¤§å°è®°å½•ï¼š`level_size = queue.len()` - è·å–å½“å‰å±‚èŠ‚ç‚¹æ•°
1. æœ€å¤§å€¼åˆå§‹åŒ–ï¼š`max_val = queue[0].val` - ä½¿ç”¨é¦–ä¸ªèŠ‚ç‚¹å€¼ï¼Œé¿å…`i32::MIN`ï¼Œå‡å°‘ä¾èµ–
1. èŠ‚ç‚¹å¤„ç†ï¼š`queue.pop_front()` - å¼¹å‡ºå¹¶è·å–æ‰€æœ‰æƒï¼Œé«˜æ•ˆä¸”å®‰å…¨
1. æœ€å¤§å€¼æ›´æ–°ï¼š`if node.val > max_val` - ç›´æ¥æ¯”è¾ƒï¼Œæ— ä¸­é—´å˜é‡
1. å­èŠ‚ç‚¹å…¥é˜Ÿï¼š`if let Some(left) = node.left` - ä½¿ç”¨æ¨¡å¼åŒ¹é…å®‰å…¨æå–Option
1. ç»“æœè¿½åŠ ï¼š`result.push(max_val)` - æ¯å±‚å¤„ç†å®Œç«‹å³å†™å…¥

Rustç‰¹æ€§ï¼š

- æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ï¼Œæ— GCå¼€é”€
- `VecDeque`æ€§èƒ½æœ€ä¼˜ï¼Œåº•å±‚ä¸ºç¯å½¢ç¼“å†²åŒº
- æ¨¡å¼åŒ¹é…å¤„ç†`Option<T>`ï¼Œä»£ç å¥å£®
- `pop_front()` ä¸ºO(1)ï¼Œé€‚åˆé«˜é¢‘æ“ä½œ

### E. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é˜Ÿåˆ—å®ç° | æœ€å¤§å€¼åˆå§‹åŒ– | æ€§èƒ½ç‰¹å¾                             |
| ---------- | ---------- | ---------- | -------- | ------------ | ------------------------------------ |
| Go         | O(n)       | O(n)       | åˆ‡ç‰‡     | é¦–èŠ‚ç‚¹å€¼     | é«˜æ•ˆï¼Œç¼“å­˜å‹å¥½ï¼Œæ— GCï¼Œé¢è¯•é¦–é€‰       |
| Python     | O(n)       | O(n)       | deque    | é¦–èŠ‚ç‚¹å€¼     | æç®€ï¼Œ`popleft()` O(1)ï¼Œé€‚åˆåŸå‹     |
| TypeScript | O(n)       | O(n)       | æ•°ç»„     | é¦–èŠ‚ç‚¹å€¼     | `shift()` O(n)ï¼Œå¤§æ•°æ®æ€§èƒ½å·®ï¼Œéœ€ä¼˜åŒ– |
| Rust       | O(n)       | O(n)       | VecDeque | é¦–èŠ‚ç‚¹å€¼     | å†…å­˜å®‰å…¨ï¼Œæ€§èƒ½æœ€ä¼˜ï¼Œæ— è¿è¡Œæ—¶å¼€é”€     |

> æ€§èƒ½å»ºè®®ï¼šåœ¨JavaScript/TypeScriptä¸­ï¼Œå¦‚å¤„ç†å¤§é‡æ•°æ®ï¼Œåº”ä½¿ç”¨`collections/deque`æˆ–ä¸¤ä¸ªæ•°ç»„äº¤æ›¿æ›¿ä»£`shift()`

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```text
å‡½æ•° largestValues(root):
    å¦‚æœ root ä¸ºç©º:
        è¿”å›ç©ºåˆ—è¡¨

    result = ç©ºåˆ—è¡¨
    queue = é˜Ÿåˆ—([root])

    å½“ queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        maxVal = queue[0].val  // å–å½“å‰å±‚ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼ä½œä¸ºåˆå§‹æœ€å¤§å€¼

        å¯¹äº i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ

            å¦‚æœ node.val > maxVal:
                maxVal = node.val

            å¦‚æœ node.left ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.left
            å¦‚æœ node.right ä¸ä¸ºç©º:
                queue å…¥é˜Ÿ node.right

        result æ·»åŠ  maxVal

    è¿”å› result
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: largestValues(root)] --> B{root ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› []]
    B -- å¦ --> D[åˆå§‹åŒ– result = [], queue = [root]]
    D --> E{queue ä¸ºç©º?}
    E -- æ˜¯ --> F[è¿”å› result]
    E -- å¦ --> G[levelSize = queue é•¿åº¦]
    G --> H[maxVal = queue[0].val]
    H --> I[i = 0]
    I --> J{i < levelSize?}
    J -- æ˜¯ --> K[node = queue å‡ºé˜Ÿ]
    K --> L{node.val > maxVal?}
    L -- æ˜¯ --> M[maxVal = node.val]
    L -- å¦ --> N{node.left éç©º?}
    M --> N
    N -- æ˜¯ --> O[queue å…¥é˜Ÿ node.left]
    N -- å¦ --> P{node.right éç©º?}
    O --> P
    P -- æ˜¯ --> Q[queue å…¥é˜Ÿ node.right]
    P -- å¦ --> R[i = i + 1]
    Q --> R
    R --> J
    J -- å¦ --> S[result æ·»åŠ  maxVal]
    S --> E
```

### çŠ¶æ€è½¬ç§»å›¾ï¼ˆç¤ºä¾‹ï¼‰

```mermaid
graph LR
    subgraph "æ‰§è¡Œè¿‡ç¨‹: root = [1,3,2,5,3,null,9]"
        direction TB
        S1["ç¬¬0å±‚: queue=[1], maxVal=1"] --> S1a["å¤„ç†èŠ‚ç‚¹1: val=1, maxVal=1"]
        S1a --> S1b["å…¥é˜Ÿ3,2"]
        S1b --> S1c["result=[1], queue=[3,2]"]

        S1c --> S2["ç¬¬1å±‚: queue=[3,2], maxVal=3"]
        S2 --> S2a["å¤„ç†èŠ‚ç‚¹3: val=3, maxVal=3"]
        S2a --> S2b["å…¥é˜Ÿ5,3"]
        S2b --> S2c["å¤„ç†èŠ‚ç‚¹2: val=2, maxVal=3"]
        S2c --> S2d["å…¥é˜Ÿ9"]
        S2d --> S2e["result=[1,3], queue=[5,3,9]"]

        S2e --> S3["ç¬¬2å±‚: queue=[5,3,9], maxVal=5"]
        S3 --> S3a["å¤„ç†èŠ‚ç‚¹5: val=5, maxVal=5"]
        S3a --> S3b["æ— å­èŠ‚ç‚¹"]
        S3b --> S3c["å¤„ç†èŠ‚ç‚¹3: val=3, maxVal=5"]
        S3c --> S3d["æ— å­èŠ‚ç‚¹"]
        S3d --> S3e["å¤„ç†èŠ‚ç‚¹9: val=9, maxVal=9"]
        S3e --> S3f["æ— å­èŠ‚ç‚¹"]
        S3f --> S3g["result=[1,3,9], queue=[]"]

        S3g --> S4["ç»“æŸ: è¿”å› [1,3,9]"]
    end

    %% æ ·å¼è®¾ç½®
    style S1 fill:#e6f3ff,stroke:#333
    style S2 fill:#e6f3ff,stroke:#333
    style S3 fill:#e6f3ff,stroke:#333
    style S4 fill:#6f9,stroke:#333
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: root = [1,3,2,5,3,null,9]

#### è¯¦ç»†æ‰§è¡Œæ­¥éª¤

| å±‚æ•° | queueçŠ¶æ€ | levelSize | maxValåˆå§‹ | å¤„ç†èŠ‚ç‚¹åºåˆ—               | æ›´æ–°åmaxVal | å­èŠ‚ç‚¹å…¥é˜Ÿ | ç»“æœ    |
| ---- | --------- | --------- | ---------- | -------------------------- | ------------ | ---------- | ------- |
| 0    | [1]       | 1         | 1          | 1 â†’ maxVal=1               | 1            | 3,2        | [1]     |
| 1    | [3,2]     | 2         | 3          | 3 â†’ maxVal=3, 2 â†’ maxVal=3 | 3            | 5,3,9      | [1,3]   |
| 2    | [5,3,9]   | 3         | 5          | 5â†’max=5, 3â†’max=5, 9â†’max=9  | 9            | æ—          | [1,3,9] |

#### æ‰§è¡Œè½¨è¿¹å¯è§†åŒ–è¡¨æ ¼

| æ­¥éª¤ | é˜Ÿåˆ—    | å±‚çº§ | å¤„ç†èŠ‚ç‚¹ | å½“å‰maxVal | æ˜¯å¦æ›´æ–°   | å­èŠ‚ç‚¹å…¥é˜Ÿ | ç»“æœæ•°ç»„ |
| ---- | ------- | ---- | -------- | ---------- | ---------- | ---------- | -------- |
| 1    | [1]     | 0    | 1        | 1          | å¦ï¼ˆåˆå§‹ï¼‰ | 3,2        | [1]      |
| 2    | [3,2]   | 1    | 3        | 3          | æ˜¯ï¼ˆ3>1ï¼‰  | 5,3        | [1,3]    |
| 3    | [2,5,3] | 1    | 2        | 3          | å¦ï¼ˆ2\<3ï¼‰ | 9          | [1,3]    |
| 4    | [5,3,9] | 2    | 5        | 5          | æ˜¯ï¼ˆ5>3ï¼‰  | æ—          | [1,3,5]  |
| 5    | [3,9]   | 2    | 3        | 5          | å¦ï¼ˆ3\<5ï¼‰ | æ—          | [1,3,5]  |
| 6    | [9]     | 2    | 9        | 9          | æ˜¯ï¼ˆ9>5ï¼‰  | æ—          | [1,3,9]  |

> å…³é”®æ´å¯Ÿï¼šå³ä½¿æŸå±‚èŠ‚ç‚¹å€¼è¾ƒå°ï¼ˆå¦‚2ï¼‰ï¼Œåªè¦ä¸æ˜¯æœ€å¤§å€¼ï¼Œä¸å½±å“ç»“æœï¼›æœ€ç»ˆæœ€å¤§å€¼ç”±æœ€å³èŠ‚ç‚¹9å†³å®š

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç ï¼ˆGoï¼‰

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func largestValues(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        maxVal := queue[0].Val

        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]

            if node.Val > maxVal {
                maxVal = node.Val
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }

        result = append(result, maxVal)
    }

    return result
}

// è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®å±‚åºæ•°ç»„æ„å»ºäºŒå‰æ ‘
func buildTree(nums []interface{}) *TreeNode {
    if len(nums) == 0 || nums[0] == nil {
        return nil
    }

    root := &TreeNode{Val: nums[0].(int)}
    queue := []*TreeNode{root}
    i := 1

    for len(queue) > 0 && i < len(nums) {
        node := queue[0]
        queue = queue[1:]

        if i < len(nums) && nums[i] != nil {
            node.Left = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Left)
        }
        i++

        if i < len(nums) && nums[i] != nil {
            node.Right = &TreeNode{Val: nums[i].(int)}
            queue = append(queue, node.Right)
        }
        i++
    }

    return root
}

func main() {
    // Test Case 1
    nums1 := []interface{}{1, 3, 2, 5, 3, nil, 9}
    tree1 := buildTree(nums1)
    fmt.Printf("Test Case 1: %v\n", largestValues(tree1)) // [1,3,9]

    // Test Case 2
    nums2 := []interface{}{1, 2, 3}
    tree2 := buildTree(nums2)
    fmt.Printf("Test Case 2: %v\n", largestValues(tree2)) // [1,3]

    // Test Case 3
    nums3 := []interface{}{1}
    tree3 := buildTree(nums3)
    fmt.Printf("Test Case 3: %v\n", largestValues(tree3)) // [1]

    // Test Case 4
    nums4 := []interface{}{}
    tree4 := buildTree(nums4)
    fmt.Printf("Test Case 4: %v\n", largestValues(tree4)) // []
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

æœ¬ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­nä¸ºæ ‘çš„èŠ‚ç‚¹æ•°

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦

- æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ï¼šO(n)
- æ¯å±‚æœ€å¤§å€¼æ›´æ–°ï¼šO(1)æ¯”è¾ƒï¼Œnæ¬¡æ¯”è¾ƒ = O(n)
- é˜Ÿåˆ—å…¥é˜Ÿå‡ºé˜Ÿï¼šæ¯ä¸ªèŠ‚ç‚¹å„ä¸€æ¬¡ï¼ŒO(1)æ“ä½œ Ã— n = O(n)
- æ€»æ—¶é—´ï¼šO(n) + O(n) + O(n) = O(n)

#### B. ç©ºé—´å¤æ‚åº¦

- é˜Ÿåˆ—å­˜å‚¨ï¼šæœ€åæƒ…å†µä¸ºæœ€åä¸€å±‚æ‰€æœ‰èŠ‚ç‚¹ï¼ŒO(n/2) â‰ˆ O(n)
- ç»“æœå­˜å‚¨ï¼šO(h)ï¼Œhä¸ºæ ‘é«˜ï¼Œæœ€åä¸ºO(n)ï¼ˆé€€åŒ–æ ‘ï¼‰
- ä¸´æ—¶å˜é‡ï¼šO(1)
- æ€»ç©ºé—´ï¼šO(n) + O(n) + O(1) = O(n)

#### C. æœ€å¥½/å¹³å‡/æœ€åæƒ…å†µåˆ†æ

| æƒ…å†µ               | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜                                     |
| ------------------ | ---------- | ---------- | ---------------------------------------- |
| æœ€å¥½ï¼ˆå®Œç¾å¹³è¡¡æ ‘ï¼‰ | O(n)       | O(n/2)     | æœ€åä¸€å±‚èŠ‚ç‚¹æœ€å¤šï¼Œçº¦ä¸ºn/2                |
| å¹³å‡               | O(n)       | O(n)       | å…¸å‹äºŒå‰æ ‘ï¼Œå±‚æ•°çº¦log nï¼Œæ¯å±‚å¹³å‡n/log n |
| æœ€åï¼ˆé€€åŒ–ä¸ºé“¾è¡¨ï¼‰ | O(n)       | O(1)       | æ¯å±‚ä»…1èŠ‚ç‚¹ï¼Œé˜Ÿåˆ—æœ€å¤§é•¿åº¦ä¸º1             |

> æ³¨æ„ï¼šè™½ç„¶æœ€åç©ºé—´ä¸ºO(1)ï¼Œä½†æœ€åæ—¶é—´ä»ä¸ºO(n)ï¼Œå› ä»éœ€è®¿é—®æ‰€æœ‰èŠ‚ç‚¹

#### D. å¸¸æ•°å› å­åˆ†æ

- é˜Ÿåˆ—æ“ä½œå¼€é”€ï¼šGoåˆ‡ç‰‡å‡ºé˜Ÿä¸ºå†…å­˜æ‹·è´ï¼ˆ`queue = queue[1:]`ï¼‰ï¼Œå¯ä¼˜åŒ–ä¸ºåŒæŒ‡é’ˆ
- æœ€å¤§å€¼æ¯”è¾ƒï¼šæ•´æ•°æ¯”è¾ƒï¼ŒCPUåŸç”Ÿæ”¯æŒï¼Œæå¿«
- ç¼“å­˜å‹å¥½æ€§ï¼šé˜Ÿåˆ—è¿ç»­å­˜å‚¨ï¼Œå†…å­˜å±€éƒ¨æ€§å¥½
- è¯­è¨€ç‰¹æ€§å½±å“ï¼š
  - Goåˆ‡ç‰‡æ‹·è´æˆæœ¬åœ¨å¤§æ•°æ®æ—¶å¯èƒ½è¾ƒé«˜ï¼ˆå¯ä¼˜åŒ–ä¸ºåŒæŒ‡é’ˆï¼‰
  - Python dequeæ— æ‹·è´ï¼Œæ€§èƒ½ä¼˜ç§€
  - Rust VecDequeæ— GCï¼Œæ€§èƒ½æœ€ä½³
  - TypeScript shift()ä¸ºO(n)ï¼Œä¸¥é‡æ‹–æ…¢æ€§èƒ½

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆï¼šGoå’ŒTypeScriptä¸­é˜Ÿåˆ—å‡ºé˜Ÿæ“ä½œï¼ˆ`queue = queue[1:]` / `shift()`ï¼‰ä¸ºO(n)
- ä¼˜åŒ–æ–¹å‘ï¼š
  - ä½¿ç”¨åŒæŒ‡é’ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼ˆhead/tailï¼‰ï¼Œé¿å…åˆ‡ç‰‡æ‹·è´
  - TypeScriptä¸­ä½¿ç”¨`collections/deque`åº“
  - Goä¸­ä½¿ç”¨`container/list`ï¼ˆä½†å¢åŠ ä¾èµ–ï¼Œéæ¨èï¼‰
  - é¢„åˆ†é…é˜Ÿåˆ—å®¹é‡ï¼ˆ`make([]*TreeNode, 0, 10000)`ï¼‰

> æ¨èä¼˜åŒ–Goç‰ˆæœ¬ï¼š

```go
// ä¼˜åŒ–ï¼šåŒæŒ‡é’ˆé˜Ÿåˆ—
func largestValues(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    queue := make([]*TreeNode, 1, 10000) // é¢„åˆ†é…å®¹é‡
    queue[0] = root
    head, tail := 0, 1

    for head < tail {
        levelSize := tail - head
        maxVal := queue[head].Val

        for i := 0; i < levelSize; i++ {
            node := queue[head]
            head++

            if node.Val > maxVal {
                maxVal = node.Val
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
                tail++
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
                tail++
            }
        }

        result = append(result, maxVal)
    }

    return result
}
```

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"å±‚çº§èšåˆ"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. BFSé€å±‚éå†
1. æ¯å±‚åŠ¨æ€èšåˆï¼ˆmax/min/avgï¼‰
1. æ— éœ€å­˜å‚¨æ•´å±‚ï¼Œä»…ç»´æŠ¤èšåˆå€¼
1. å¯æ³›åŒ–ä¸ºå…¶ä»–èšåˆä»»åŠ¡

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- å±‚åºèšåˆï¼šåœ¨æ¯å±‚èŠ‚ç‚¹ä¸­è®¡ç®—å•ä¸€ç»Ÿè®¡å€¼ï¼ˆæœ€å¤§å€¼ã€æœ€å°å€¼ã€å¹³å‡å€¼ã€æ€»å’Œç­‰ï¼‰
- ç©ºé—´ä¼˜åŒ–ï¼šä¸å­˜å‚¨æ•´å±‚èŠ‚ç‚¹ï¼Œä»…è®°å½•èšåˆå€¼ï¼Œé™ä½ç©ºé—´å ç”¨
- å®æ—¶æ›´æ–°ï¼šåœ¨éå†è¿‡ç¨‹ä¸­å³æ—¶æ›´æ–°èšåˆå€¼ï¼Œé¿å…äºŒæ¬¡éå†
- å¤ç”¨æ€§å¼ºï¼šå¯è½»æ¾æ‰©å±•ä¸ºæ±‚æ¯å±‚å¹³å‡å€¼ï¼ˆLeetCode 637ï¼‰ã€æœ€å°å€¼ã€ä¼—æ•°ç­‰

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®                             | æ ¸å¿ƒæ€æƒ³     | åŒ¹é…æ¨¡å¼                |
| ---- | -------------------------------- | ------------ | ----------------------- |
| 515  | æœ¬é¢˜                             | æ¯å±‚æœ€å¤§å€¼   | æ ¸å¿ƒæ¨¡å¼                |
| 637  | äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼                 | æ¯å±‚å¹³å‡å€¼   | æ¨¡å¼å˜ä½“ï¼ˆèšåˆ=å¹³å‡ï¼‰   |
| 513  | æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼                   | æ¯å±‚æœ€å·¦èŠ‚ç‚¹ | æ¨¡å¼å˜ä½“ï¼ˆèšåˆ=å·¦ç«¯ç‚¹ï¼‰ |
| 102  | äºŒå‰æ ‘çš„å±‚åºéå†                 | è¾“å‡ºæ•´å±‚èŠ‚ç‚¹ | åŸºç¡€æ¨¡å¼                |
| 116  | å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ | æ¯å±‚è¿æ¥èŠ‚ç‚¹ | æ¨¡å¼æ‰©å±•ï¼ˆèšåˆ=è¿æ¥ï¼‰   |

#### C. æ¨¡å¼æ³›åŒ–

- æ±‚æ¯å±‚æœ€å°å€¼ï¼šæ›¿æ¢`maxVal`ä¸º`minVal`ï¼Œåˆå§‹å€¼ä¸º`math.MaxInt32`
- æ±‚æ¯å±‚èŠ‚ç‚¹æ€»æ•°ï¼šç›´æ¥ç”¨`levelSize`
- æ±‚æ¯å±‚èŠ‚ç‚¹æ€»å’Œï¼šç´¯åŠ `sum += node.Val`
- æ±‚æ¯å±‚ä¼—æ•°ï¼šä½¿ç”¨å“ˆå¸Œè¡¨è®¡æ•°ï¼Œç©ºé—´O(n)
- æ±‚æ¯å±‚æ˜¯å¦ä¸ºå›æ–‡ï¼šå­˜å‚¨æ•´å±‚å€¼ï¼Œæ¯”è¾ƒå‰å

#### D. å·¥ä¸šç•Œåº”ç”¨

- ç›‘æ§ç³»ç»Ÿï¼šæ¯ç§’é‡‡é›†æœåŠ¡å™¨è´Ÿè½½ï¼Œå–æœ€å¤§å€¼åšå‘Šè­¦
- æ—¥å¿—åˆ†æï¼šæ¯åˆ†é’Ÿè¯·æ±‚é‡æœ€å¤§å€¼ç›‘æ§
- é‡‘èç³»ç»Ÿï¼šæ¯å°æ—¶äº¤æ˜“é¢æœ€å¤§å€¼ç»Ÿè®¡
- æ¸¸æˆå¼•æ“ï¼šæ¯å¸§æ¸²æŸ“å¯¹è±¡æ•°æœ€å¤§å€¼ä¼˜åŒ–
- åˆ†å¸ƒå¼ç³»ç»Ÿï¼šæ¯è½®å¿ƒè·³å“åº”æ—¶é—´æœ€å¤§å€¼æ£€æµ‹å»¶è¿Ÿ

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆä¸éœ€è¦å­˜å‚¨æ•´å±‚èŠ‚ç‚¹ï¼Ÿ
   - é—®é¢˜åªéœ€â€œæœ€å¤§å€¼â€ï¼Œéâ€œèŠ‚ç‚¹åºåˆ—â€
   - èšåˆå‡½æ•°å…·æœ‰å¯å‹ç¼©æ€§ï¼ˆmax(a,b,c) = max(max(a,b), c)ï¼‰
   - ç¬¦åˆæµå¼å¤„ç†æ¨¡å‹ï¼šæ•°æ®æµä¸­å•æ¬¡æ‰«æï¼Œä¸å›æº¯

1. ä¸ºä»€ä¹ˆåˆå§‹åŒ–ä¸º`queue[0].Val`è€Œä¸æ˜¯`math.MinInt32`ï¼Ÿ
   - é¿å…ç¡¬ç¼–ç å¸¸é‡ï¼Œå¢å¼ºæ³›åŒ–æ€§
   - é¿å…æ•°å€¼æº¢å‡ºé£é™©ï¼ˆå¦‚ä½¿ç”¨`int`è€Œé`int32`ï¼‰
   - æ›´ç¬¦åˆâ€œçœŸå®æ•°æ®é©±åŠ¨â€åŸåˆ™
   - ä¸çœŸå®ä¸šåŠ¡åœºæ™¯ä¸€è‡´ï¼ˆå¦‚ç›‘æ§ç³»ç»Ÿä¸­ï¼Œåˆå§‹å€¼å–ç¬¬ä¸€ä¸ªé‡‡æ ·ç‚¹ï¼‰

1. è¯¥æ¨¡å¼ä¸ºä½•èƒ½æ¨å¹¿åˆ°å…¶ä»–èšåˆå‡½æ•°ï¼Ÿ
   - èšåˆå‡½æ•°æ»¡è¶³ç»“åˆå¾‹ä¸äº¤æ¢å¾‹ï¼ˆmaxã€minã€sumã€avgï¼‰
   - æ‰€æœ‰èšåˆå‡å¯åœ¨å•æ¬¡éå†ä¸­å®Œæˆ
   - æ— éœ€é¢å¤–æ•°æ®ç»“æ„æ”¯æŒ
   - ä¸MapReduceä¸­çš„â€œMap-Reduceâ€æ¨¡å¼é«˜åº¦ä¸€è‡´

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿï¼š

1. å¯¹BFSå’Œèšåˆé€»è¾‘çš„ç†è§£
1. ç©ºé—´ä¼˜åŒ–èƒ½åŠ›
1. ä»å•ä¸€èšåˆåˆ°å¤æ‚ç»Ÿè®¡çš„æ‰©å±•èƒ½åŠ›
1. æ€§èƒ½ç“¶é¢ˆè¯†åˆ«ä¸ä¼˜åŒ–æ„è¯†

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆä¸ç”¨DFSï¼Ÿ

â†’ æ ‡å‡†: DFSéœ€è®°å½•å±‚æ•°ï¼Œç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯å±‚èŠ‚ç‚¹ï¼Œç©ºé—´O(h)ï¼Œä¸å¦‚BFSç›´æ¥
â†’ åŠ åˆ†: DFSéœ€å›æº¯ï¼ŒBFSå¤©ç„¶æŒ‰å±‚ï¼Œæ›´é€‚åˆâ€œå±‚çº§èšåˆâ€ä»»åŠ¡ï¼Œä¸”å¯å¹¶è¡ŒåŒ–

#### Q2: ä¸ºä»€ä¹ˆåˆå§‹åŒ–maxValä¸ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼ï¼Œè€Œä¸æ˜¯-10^9ï¼Ÿ

â†’ æ ‡å‡†: é¿å…ä¾èµ–ç¡¬ç¼–ç ï¼Œå¢å¼ºä»£ç é²æ£’æ€§
â†’ åŠ åˆ†: è‹¥æ•°æ®èŒƒå›´å˜åŒ–ï¼ˆå¦‚æ”¹ä¸ºint64ï¼‰ï¼Œæ— éœ€ä¿®æ”¹åˆå§‹åŒ–é€»è¾‘ï¼›ç¬¦åˆæœ€å°ä¾èµ–åŸåˆ™

#### Q3: å¦‚æœè¦æ±‚è¿”å›æœ€å¤§å€¼æ‰€åœ¨çš„èŠ‚ç‚¹ï¼Œå¦‚ä½•ä¿®æ”¹ï¼Ÿ

â†’ æ ‡å‡†: ç”¨`maxNode`å˜é‡è®°å½•æœ€å¤§å€¼èŠ‚ç‚¹
â†’ åŠ åˆ†: ä»£ç ç¤ºä¾‹ï¼š

```go
var maxNode *TreeNode
maxVal := queue[0].Val
maxNode = queue[0]

// åœ¨æ›´æ–°maxValæ—¶åŒæ—¶æ›´æ–°maxNode
if node.Val > maxVal {
    maxVal = node.Val
    maxNode = node
}
```

#### Q4: æœ¬é¢˜ä¸LeetCode 637ï¼ˆå±‚å¹³å‡å€¼ï¼‰æœ‰ä½•å¼‚åŒï¼Ÿ

â†’ æ ‡å‡†: éƒ½æ˜¯å±‚çº§èšåˆï¼Œ637éœ€ç´¯åŠ +è®¡æ•°ï¼Œ515åªéœ€æ¯”è¾ƒ
â†’ åŠ åˆ†: 637éœ€è¦`sum += node.Val; count++`ï¼Œæœ€å`sum/count`ï¼Œ515ä»…éœ€`maxVal = max(maxVal, val)`

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°æ¯å±‚çš„æœ€å°å€¼ï¼Ÿ

â†’ æ ‡å‡†: æ›¿æ¢`maxVal`ä¸º`minVal`ï¼Œåˆå§‹åŒ–ä¸º`queue[0].Val`
â†’ åŠ åˆ†:

```go
minVal := queue[0].Val
for i := 0; i < levelSize; i++ {
    if node.Val < minVal {
        minVal = node.Val
    }
}
```

#### Q2: å¦‚ä½•å®ç°æ¯å±‚çš„èŠ‚ç‚¹æ€»å’Œï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨`sum`å˜é‡ï¼Œåˆå§‹åŒ–ä¸º0ï¼Œç´¯åŠ æ‰€æœ‰èŠ‚ç‚¹å€¼
â†’ åŠ åˆ†:

```go
sum := 0
for i := 0; i < levelSize; i++ {
    sum += node.Val
}
result = append(result, sum)
```

#### Q3: å¦‚ä½•å®ç°æ¯å±‚çš„ä¼—æ•°ï¼ˆå‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼ï¼‰ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨å“ˆå¸Œè¡¨ç»Ÿè®¡é¢‘æ¬¡ï¼Œå†éå†å–æœ€å¤§é¢‘æ¬¡
â†’ åŠ åˆ†:

```go
freq := make(map[int]int)
for i := 0; i < levelSize; i++ {
    freq[node.Val]++
}
maxFreq := 0
mode := 0
for val, f := range freq {
    if f > maxFreq {
        maxFreq = f
        mode = val
    }
}
result = append(result, mode)
```

> æ³¨æ„ï¼šæ­¤æ—¶ç©ºé—´å¤æ‚åº¦å˜ä¸ºO(å±‚å¤§å°)ï¼Œä¸å†æ˜¯O(1)èšåˆ

#### Q4: å¦‚ä½•ä¼˜åŒ–Goä¸­çš„åˆ‡ç‰‡å‡ºé˜Ÿæ€§èƒ½ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨åŒæŒ‡é’ˆ(head/tail)ä»£æ›¿`queue = queue[1:]`
â†’ åŠ åˆ†: æä¾›åŒæŒ‡é’ˆä¼˜åŒ–ä»£ç ï¼ˆè§ç¬¬6èŠ‚ï¼‰

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®ï¼š

1. BFSä¸å±‚çº§èšåˆçš„ç»“åˆ
1. åŠ¨æ€æ›´æ–°æœ€å¤§å€¼ï¼Œä¸å­˜å‚¨æ•´å±‚
1. åˆå§‹åŒ–å€¼é€‰å–çš„å·¥ç¨‹æ™ºæ…§
1. å¯æ³›åŒ–ä¸ºå¤šç§èšåˆä»»åŠ¡

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹         | å£è¯€                          |
| -------------- | ----------------------------- |
| å±‚çº§èšåˆæ ¸å¿ƒ   | BFS + å®æ—¶æ›´æ–°èšåˆå€¼          |
| åˆå§‹åŒ–æŠ€å·§     | å–ç¬¬ä¸€èŠ‚ç‚¹å€¼ï¼Œä¸ç¡¬ç¼–ç         |
| æ—¶é—´å¤æ‚åº¦     | O(n) â€” æ¯èŠ‚ç‚¹ä»…è®¿é—®ä¸€æ¬¡       |
| ç©ºé—´å¤æ‚åº¦     | O(n) â€” é˜Ÿåˆ—æœ€åå­˜æœ€åä¸€å±‚     |
| é¢è¯•è¯„åˆ†å…³é”®è¯ | BFSã€å±‚çº§èšåˆã€åŠ¨æ€æ›´æ–°ã€O(n) |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹                      | è§¦å‘åœºæ™¯                         | åº”å¯¹æªæ–½                            |
| ----------------------------- | -------------------------------- | ----------------------------------- |
| åˆå§‹åŒ–ä¸º`math.MinInt32`       | æŸå±‚å…¨ä¸ºè´Ÿæ•°ï¼Œä½†æœ€å¤§å€¼ä»å¯èƒ½ä¸ºè´Ÿ | æ”¹ä¸ºå–`queue[0].Val`                |
| ä½¿ç”¨DFSé€’å½’                   | æ··æ·†å±‚åºä¸æ·±åº¦ä¼˜å…ˆ               | è®¤æ¸…â€œæ¯å±‚â€æ˜¯å±‚åºç‰¹å¾                |
| å¿˜è®°è®°å½•å±‚å¤§å°                | å¯¼è‡´éå†ä¸‹ä¸€å±‚èŠ‚ç‚¹               | æ¯å±‚å¾ªç¯å‰`levelSize := len(queue)` |
| Goä¸­`queue = queue[1:]`æ€§èƒ½å·® | å¤§æ•°æ®è¶…æ—¶                       | ä½¿ç”¨åŒæŒ‡é’ˆä¼˜åŒ–                      |
| TypeScriptä½¿ç”¨`shift()`       | O(n)å¯¼è‡´è¶…æ—¶                     | æ”¹ç”¨åŒæ•°ç»„äº¤æ›¿æˆ–ç¬¬ä¸‰æ–¹åº“            |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯              | åº”ç”¨åœºæ™¯         |
| ------------------- | ---------------- |
| å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ | æè¿°ç®—æ³•é€‰æ‹©     |
| å±‚çº§èšåˆ            | å‘½åç®—æ³•èŒƒå¼     |
| å®æ—¶æ›´æ–°æœ€å¤§å€¼      | ä½“ç°ç©ºé—´ä¼˜åŒ–æ„è¯† |
| æ—¶é—´å¤æ‚åº¦O(n)      | è¯æ˜ç®—æ³•æ•ˆç‡     |
| ç©ºé—´å¤æ‚åº¦O(n)      | åˆç†åˆ†æé˜Ÿåˆ—å¼€é”€ |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: å±‚çº§èšåˆï¼ˆæœ€å¤§å€¼ï¼‰
â”œâ”€â”€ å¿…è¦æ¡ä»¶: BFS + åŠ¨æ€æ›´æ–°
â”œâ”€â”€ æœ¬è´¨: æ¯å±‚å•æ¬¡éå†ï¼Œèšåˆå€¼å³æ—¶æ›´æ–°
â”œâ”€â”€ æ–¹æ³•: BFS + èšåˆå˜é‡
â”‚   â”œâ”€â”€ é˜Ÿåˆ—åˆå§‹åŒ–: [root]
â”‚   â”œâ”€â”€ å¤–å±‚å¾ªç¯: é˜Ÿåˆ—éç©º
â”‚   â”œâ”€â”€ å†…å±‚å¾ªç¯: éå†å½“å‰å±‚æ‰€æœ‰èŠ‚ç‚¹
â”‚   â”œâ”€â”€ èšåˆåˆå§‹åŒ–: å–é¦–ä¸ªèŠ‚ç‚¹å€¼
â”‚   â”œâ”€â”€ èšåˆæ›´æ–°: æ¯”è¾ƒå¹¶æ›´æ–°
â”‚   â””â”€â”€ ç»“æœè¿½åŠ : æ¯å±‚ç»“æŸæ—¶åŠ å…¥
â”œâ”€â”€ æ‰©å±•: æœ€å°å€¼ã€å¹³å‡å€¼ã€æ€»å’Œã€ä¼—æ•°
â”œâ”€â”€ ä¼˜åŒ–: åŒæŒ‡é’ˆé˜Ÿåˆ—ã€é¢„åˆ†é…å®¹é‡
â””â”€â”€ åº”ç”¨: ç›‘æ§ç³»ç»Ÿã€æ—¥å¿—åˆ†æã€é‡‘èç»Ÿè®¡
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€æ¨¡æ¿ï¼šæ¯å±‚æœ€å¤§å€¼
å‡½æ•° largestValues(root):
    if root ä¸ºç©º: è¿”å› []
    result = []
    queue = é˜Ÿåˆ—([root])

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        maxVal = queue[0].val   // å…³é”®ï¼šå–ç¬¬ä¸€ä¸ªå€¼åˆå§‹åŒ–

        for i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ

            if node.val > maxVal:
                maxVal = node.val

            if node.left éç©º: queue å…¥é˜Ÿ node.left
            if node.right éç©º: queue å…¥é˜Ÿ node.right

        result æ·»åŠ  maxVal

    return result

// é€šç”¨æ¨¡æ¿ï¼šä»»æ„èšåˆå‡½æ•°
å‡½æ•° levelAggregate(root, aggregateFn):
    if root ä¸ºç©º: è¿”å› []
    result = []
    queue = é˜Ÿåˆ—([root])

    while queue ä¸ä¸ºç©º:
        levelSize = queue é•¿åº¦
        aggregateValue = queue[0].val   // åˆå§‹åŒ–ä¸ºé¦–ä¸ªå€¼

        for i ä» 0 åˆ° levelSize-1:
            node = queue å‡ºé˜Ÿ
            aggregateValue = aggregateFn(aggregateValue, node.val)

            if node.left éç©º: queue å…¥é˜Ÿ node.left
            if node.right éç©º: queue å…¥é˜Ÿ node.right

        result æ·»åŠ  aggregateValue

    return result

// ä½¿ç”¨ç¤ºä¾‹ï¼š
// æœ€å¤§å€¼ï¼šaggregateFn = max(x, y)
// æœ€å°å€¼ï¼šaggregateFn = min(x, y)
// æ€»å’Œï¼šaggregateFn = x + y
// å¹³å‡å€¼ï¼šéœ€æ”¹ç”¨ sum + count æ¨¡å¼
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³å±‚çº§èšåˆç±»é—®é¢˜ï¼Œå¹¶å±•ç°å‡ºå¯¹æ ‘ç»“æ„éå†ã€ç©ºé—´ä¼˜åŒ–å’Œå·¥ç¨‹å®ç°çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
