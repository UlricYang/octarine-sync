# LeetCode 106 - ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

## 1. é¢˜ç›®æè¿°

æ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘

æ³¨æ„:
ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ 

### ç¤ºä¾‹

```
è¾“å…¥:
ä¸­åºéå† inorder = [9,3,15,20,7]
ååºéå† postorder = [9,15,7,20,3]

è¾“å‡º:
    3
   / \
  9  20
    /  \
   15   7
```

### çº¦æŸæ¡ä»¶

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` å’Œ `postorder` å‡æ— é‡å¤å…ƒç´ 
- `postorder` ä¸­æ¯ä¸€ä¸ªå€¼éƒ½åœ¨ `inorder` ä¸­
- `inorder` ä¿è¯æ˜¯æ ‘çš„ä¸­åºéå†
- `postorder` ä¿è¯æ˜¯æ ‘çš„ååºéå†

## 2. è§£æ³•åˆ†æï¼šé€’å½’åˆ’åˆ†æ³•

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯é€’å½’åˆ’åˆ†æ³•ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. åˆ©ç”¨ååºå’Œä¸­åºéå†çš„ç»“æ„ç‰¹æ€§ - ååºéå†çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹ï¼Œä¸­åºéå†å¯ä»¥åˆ’åˆ†å·¦å³å­æ ‘
1. å®ç°é€»è¾‘é«˜åº¦è‡ªæ´½ - æ¯æ¬¡é€’å½’å¤„ç†ä¸€ä¸ªå­é—®é¢˜ï¼Œæ¸…æ™°ç›´è§‚
1. æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ - é€šè¿‡å“ˆå¸Œä¼˜åŒ–å¯è¾¾åˆ°O(n)æ—¶é—´å¤æ‚åº¦
1. ç›´æ¥æ˜ å°„åˆ°äºŒå‰æ ‘æ„é€ è¿‡ç¨‹ - ç¬¦åˆæ ‘çš„é€’å½’å®šä¹‰

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆé€’å½’åˆ’åˆ†æ³•æ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. ååºéå†ç‰¹æ€§ï¼šæœ€åä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯å½“å‰å­æ ‘çš„æ ¹èŠ‚ç‚¹
1. ä¸­åºéå†ç‰¹æ€§ï¼šæ ¹èŠ‚ç‚¹å°†æ•°ç»„åˆ†ä¸ºå·¦å­æ ‘(å·¦ä¾§)å’Œå³å­æ ‘(å³ä¾§)
1. ç»„åˆå¨åŠ›ï¼šååºæä¾›"æ ¹æ˜¯è°"ï¼Œä¸­åºæä¾›"æ ¹çš„å·¦å³å­æ ‘èŒƒå›´"ï¼Œä¸¤è€…ç»“åˆå¯å”¯ä¸€ç¡®å®šä¸€æ£µäºŒå‰æ ‘
1. é€’å½’åˆ’åˆ†ï¼šæ¯æ¬¡å–ååºæœ«å…ƒç´ ä½œä¸ºæ ¹ï¼Œåœ¨ä¸­åºä¸­å®šä½å…¶ä½ç½®ï¼Œåˆ†å‰²å‡ºå·¦/å³å­æ ‘åŒºé—´ï¼Œé€’å½’æ„å»º
1. æ— å†—ä½™ä¿¡æ¯ï¼šä»…ç”¨ä¸¤ä¸ªéå†åºåˆ—ï¼Œä¸ä¾èµ–é¢å¤–æ•°æ®ç»“æ„(å“ˆå¸Œè¡¨è™½æå‡æ•ˆç‡ä½†éæœ¬è´¨)

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•               | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                 |
| ------------------ | -------- | ---------- | ---------- | -------- | -------------------- |
| é€’å½’åˆ’åˆ†æ³•(æœ¬è§£)   | âœ…       | O(n)       | O(n)       | ä¸­       | é¢è¯•é¦–é€‰ï¼Œé€»è¾‘æ¸…æ™°   |
| å“ˆå¸Œä¼˜åŒ–é€’å½’æ³•     | âœ…       | O(n)       | O(n)       | ä¸­       | æ•ˆç‡æ›´é«˜ï¼Œå¼•å…¥å“ˆå¸Œè¡¨ |
| è¿­ä»£æ ˆæ³•           | âœ…       | O(n)       | O(n)       | é«˜       | ä»£ç å¤æ‚ï¼Œéš¾è°ƒè¯•     |
| å‰åº+ä¸­åºæ„é€       | âœ…       | O(n)       | O(n)       | ä¸­       | åŒç±»é¢˜ï¼Œæ ¹åœ¨å‰åºé¦–ä½ |
| æš´åŠ›é€’å½’(æ¯æ¬¡æŸ¥æ‰¾) | âœ…       | O(nÂ²)      | O(n)       | ä½       | ä¼šè¶…æ—¶ï¼Œä¸å¯å–       |

> å“ˆå¸Œä¼˜åŒ–æœ¬è´¨æ˜¯é¢„å¤„ç†ä¼˜åŒ–ï¼Œä¸æ”¹å˜ç®—æ³•èŒƒå¼ã€‚æœ¬é¢˜æ ¸å¿ƒæ˜¯"é€’å½’åˆ’åˆ†"æ€æƒ³

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. å¿…é¡»æ˜¯äºŒå‰æ ‘ï¼šNå‰æ ‘æ— å”¯ä¸€ä¸­åºå®šä¹‰
1. èŠ‚ç‚¹å€¼å”¯ä¸€ï¼šè‹¥é‡å¤ï¼Œä¸­åºä¸­æ— æ³•å”¯ä¸€å®šä½æ ¹
1. åºåˆ—å®Œæ•´ä¸€è‡´ï¼šä¸¤åºåˆ—å¿…é¡»æ¥è‡ªåŒä¸€æ£µæ ‘
1. æ— ç©ºèŠ‚ç‚¹æ ‡è®°ï¼šåºåˆ—ä¸­ä¸å«nullï¼Œä¸èƒ½ç›´æ¥ç”¨äºåºåˆ—åŒ–

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. é€’å½’æ·±åº¦ï¼šæœ€åO(n)ï¼Œéœ€è€ƒè™‘æ ˆæº¢å‡º(å¯ç”¨è¿­ä»£æ¨¡æ‹Ÿ)
1. å‚æ•°ä¼ é€’ï¼šä½¿ç”¨ç´¢å¼•è€Œéåˆ‡ç‰‡ï¼Œé¿å…æ•°ç»„å¤åˆ¶
1. å¯è¯»æ€§ä¼˜å…ˆï¼šé¢è¯•ä¸­ä¼˜å…ˆæ¸…æ™°é€’å½’ç‰ˆæœ¬
1. è°ƒè¯•å‹å¥½ï¼šæ¯å±‚é€’å½’å¯¹åº”ä¸€ä¸ªå­æ ‘ï¼Œå¯æ‰“å°åŒºé—´éªŒè¯

### æ€»ç»“

é€’å½’åˆ’åˆ†æ³•æ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ€ç»´æ¸…æ™°åº¦å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶æ´å¯Ÿä¸åŒè¯­è¨€åœ¨é€’å½’ã€ç´¢å¼•ç®¡ç†å’Œå†…å­˜æ•ˆç‡ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°(åŸºç¡€ç‰ˆ)

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(inorder []int, postorder []int) *TreeNode {
    if len(postorder) == 0 {
        return nil
    }

    // ååºæœ€åä¸€ä¸ªå…ƒç´ ä¸ºæ ¹èŠ‚ç‚¹
    rootVal := postorder[len(postorder)-1]
    root := &TreeNode{Val: rootVal}

    // åœ¨ä¸­åºä¸­æŸ¥æ‰¾æ ¹èŠ‚ç‚¹ä½ç½®
    rootIdx := 0
    for i, val := range inorder {
        if val == rootVal {
            rootIdx = i
            break
        }
    }

    // åˆ’åˆ†å·¦å³å­æ ‘
    leftSize := rootIdx
    rightSize := len(inorder) - 1 - rootIdx

    // é€’å½’æ„å»ºå·¦å³å­æ ‘
    root.Left = buildTree(inorder[:rootIdx], postorder[:leftSize])
    root.Right = buildTree(inorder[rootIdx+1:], postorder[leftSize:len(postorder)-1])

    return root
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. é€’å½’åŸºçº¿ï¼š`if len(postorder) == 0` - ç©ºåºåˆ—è¿”å›nil
1. æ ¹èŠ‚ç‚¹ç¡®å®šï¼š`postorder[len(postorder)-1]` - ååºæœ«å…ƒç´ å¿…ä¸ºæ ¹
1. æ ¹ä½ç½®æŸ¥æ‰¾ï¼šçº¿æ€§æ‰«æä¸­åºæ•°ç»„ - O(n)æ—¶é—´
1. å­æ ‘åˆ’åˆ†ï¼š
   - `leftSize = rootIdx` - å·¦å­æ ‘èŠ‚ç‚¹æ•°
   - `rightSize = len(inorder)-1-rootIdx` - å³å­æ ‘èŠ‚ç‚¹æ•°
1. é€’å½’æ„å»ºï¼š
   - å·¦å­æ ‘ï¼šä¸­åº[0:rootIdx], ååº[0:leftSize]
   - å³å­æ ‘ï¼šä¸­åº[rootIdx+1:], ååº[leftSize:len-1]

è®¾è®¡åŠ¨æœºï¼š

- å®Œå…¨åŸºäºé€’å½’åˆ’åˆ†ï¼Œæ¯å±‚å¤„ç†ä¸€ä¸ªå­æ ‘
- åˆ‡ç‰‡å¤åˆ¶å¯¼è‡´O(nÂ²)æ—¶é—´ï¼Œä½†é€»è¾‘æ¸…æ™°
- ä½“ç°"ååºå®šæ ¹ï¼Œä¸­åºåˆ†å·¦å³"çš„æ ¸å¿ƒæ€æƒ³

### B. Go ğŸ¹ å®ç°(ä¼˜åŒ–ç‰ˆ)

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
    // é¢„å¤„ç†ä¸­åºç´¢å¼•
    idxMap := make(map[int]int)
    for i, v := range inorder {
        idxMap[v] = i
    }

    var build func(int, int, int, int) *TreeNode
    build = func(inStart, inEnd, postStart, postEnd int) *TreeNode {
        if postStart >= postEnd {
            return nil
        }

        rootVal := postorder[postEnd-1]
        root := &TreeNode{Val: rootVal}
        rootIdx := idxMap[rootVal]

        leftSize := rootIdx - inStart
        root.Left = build(inStart, rootIdx, postStart, postStart+leftSize)
        root.Right = build(rootIdx+1, inEnd, postStart+leftSize, postEnd-1)

        return root
    }

    return build(0, len(inorder), 0, len(postorder))
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. å“ˆå¸Œé¢„å¤„ç†ï¼š`idxMap`å­˜å‚¨ä¸­åºå€¼â†’ç´¢å¼•ï¼ŒO(1)æŸ¥æ‰¾
1. ç´¢å¼•ä¼ é€’ï¼šä½¿ç”¨åŒºé—´å‚æ•°é¿å…åˆ‡ç‰‡å¤åˆ¶
1. æ ¹èŠ‚ç‚¹å¤„ç†ï¼š`postorder[postEnd-1]`è·å–æ ¹å€¼
1. å­æ ‘åˆ’åˆ†ï¼š
   - `leftSize = rootIdx - inStart` - å·¦å­æ ‘å¤§å°
   - å·¦å­æ ‘åŒºé—´ï¼šä¸­åº\[inStart, rootIdx), ååº\[postStart, postStart+leftSize)
   - å³å­æ ‘åŒºé—´ï¼šä¸­åº\[rootIdx+1, inEnd), ååº\[postStart+leftSize, postEnd-1)

ä¼˜åŒ–ç‚¹ï¼š

- æ—¶é—´å¤æ‚åº¦é™ä¸ºO(n)
- ç©ºé—´å¤æ‚åº¦O(n)ç”¨äºå“ˆå¸Œè¡¨
- æ— æ•°ç»„å¤åˆ¶ï¼Œå†…å­˜æ•ˆç‡é«˜

### C. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # é¢„å¤„ç†ä¸­åºç´¢å¼•
        idx_map = {val: idx for idx, val in enumerate(inorder)}

        def helper(in_start, in_end, post_start, post_end):
            if post_start >= post_end:
                return None

            root_val = postorder[post_end-1]
            root = TreeNode(root_val)
            root_idx = idx_map[root_val]

            left_size = root_idx - in_start
            root.left = helper(in_start, root_idx, post_start, post_start+left_size)
            root.right = helper(root_idx+1, in_end, post_start+left_size, post_end-1)

            return root

        return helper(0, len(inorder), 0, len(postorder))
```

#### ç®—æ³•æ·±å…¥è§£æ

1. å­—å…¸é¢„å¤„ç†ï¼š`idx_map`å¿«é€ŸæŸ¥æ‰¾æ ¹ä½ç½®
1. é—­åŒ…å‡½æ•°ï¼š`helper`ä½¿ç”¨å¤–éƒ¨`idx_map`
1. åŒºé—´å¤„ç†ï¼šä¸Goä¼˜åŒ–ç‰ˆæœ¬é€»è¾‘ä¸€è‡´
1. Pythonç‰¹æ€§ï¼š
   - å­—å…¸æ¨å¯¼å¼ç®€æ´é«˜æ•ˆ
   - é—­åŒ…è®¿é—®å¤–éƒ¨å˜é‡
   - ç±»å‹æç¤ºå¢å¼ºå¯è¯»æ€§

### D. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function buildTree(inorder: number[], postorder: number[]): TreeNode | null {
    const idxMap = new Map<number, number>();
    inorder.forEach((val, idx) => idxMap.set(val, idx));

    const build = (inStart: number, inEnd: number, postStart: number, postEnd: number): TreeNode | null => {
        if (postStart >= postEnd) return null;

        const rootVal = postorder[postEnd - 1];
        const root = new TreeNode(rootVal);
        const rootIdx = idxMap.get(rootVal)!;

        const leftSize = rootIdx - inStart;
        root.left = build(inStart, rootIdx, postStart, postStart + leftSize);
        root.right = build(rootIdx + 1, inEnd, postStart + leftSize, postEnd - 1);

        return root;
    };

    return build(0, inorder.length, 0, postorder.length);
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. Mapé¢„å¤„ç†ï¼š`idxMap`å­˜å‚¨å€¼â†’ç´¢å¼•
1. ç®­å¤´å‡½æ•°ï¼š`build`ä½¿ç”¨å¤–éƒ¨`idxMap`
1. ç±»å‹å®‰å…¨ï¼š
   - `Map<number, number>`æ˜ç¡®ç±»å‹
   - `!`æ–­è¨€éç©º(é¢˜ç›®ä¿è¯å­˜åœ¨)
1. TypeScriptç‰¹æ€§ï¼š
   - ç±»å‹æ³¨è§£å¢å¼ºå¯ç»´æŠ¤æ€§
   - ç®­å¤´å‡½æ•°ä¿æŒthisä¸Šä¸‹æ–‡

### E. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::HashMap;

impl Solution {
    pub fn build_tree(inorder: Vec<i32>, postorder: Vec<i32>) -> Option<Box<TreeNode>> {
        let idx_map: HashMap<i32, usize> = inorder.iter()
            .enumerate()
            .map(|(i, &v)| (v, i))
            .collect();

        fn build(
            inorder: &[i32],
            postorder: &[i32],
            in_start: usize,
            in_end: usize,
            post_start: usize,
            post_end: usize,
            idx_map: &HashMap<i32, usize>
        ) -> Option<Box<TreeNode>> {
            if post_start >= post_end {
                return None;
            }

            let root_val = postorder[post_end - 1];
            let root_idx = idx_map[&root_val];
            let left_size = root_idx - in_start;

            let mut root = TreeNode::new(root_val);
            root.left = build(
                inorder,
                postorder,
                in_start,
                root_idx,
                post_start,
                post_start + left_size,
                idx_map
            );
            root.right = build(
                inorder,
                postorder,
                root_idx + 1,
                in_end,
                post_start + left_size,
                post_end - 1,
                idx_map
            );

            Some(Box::new(root))
        }

        build(
            &inorder,
            &postorder,
            0,
            inorder.len(),
            0,
            postorder.len(),
            &idx_map
        )
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. HashMapé¢„å¤„ç†ï¼š`idx_map`å­˜å‚¨å€¼â†’ç´¢å¼•
1. åˆ‡ç‰‡å¼•ç”¨ï¼š`&inorder`å’Œ`&postorder`é¿å…æ‰€æœ‰æƒè½¬ç§»
1. åµŒå¥—å‡½æ•°ï¼š`build`ä½¿ç”¨å¤–éƒ¨`idx_map`
1. Rustç‰¹æ€§ï¼š
   - æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨
   - åˆ‡ç‰‡å¼•ç”¨æé«˜æ•ˆç‡
   - è¿­ä»£å™¨é“¾å¼è°ƒç”¨ç®€æ´é«˜æ•ˆ

### F. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°æ–¹å¼     | ç‰¹ç‚¹               |
| ---------- | ---------- | ---------- | ------------ | ------------------ |
| Go(åŸºç¡€)   | O(nÂ²)      | O(nÂ²)      | åˆ‡ç‰‡å¤åˆ¶     | é€»è¾‘æ¸…æ™°ï¼Œé¢è¯•é¦–é€‰ |
| Go(ä¼˜åŒ–)   | O(n)       | O(n)       | ç´¢å¼•ä¼ é€’     | å·¥ä¸šçº§å®ç°         |
| Python     | O(n)       | O(n)       | å­—å…¸+é—­åŒ…    | ç®€æ´é«˜æ•ˆ           |
| TypeScript | O(n)       | O(n)       | Map+ç®­å¤´å‡½æ•° | ç±»å‹å®‰å…¨           |
| Rust       | O(n)       | O(n)       | HashMap+åˆ‡ç‰‡ | å†…å­˜å®‰å…¨           |

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```
å‡½æ•° buildTree(inorder, postorder):
    å¦‚æœ postorder ä¸ºç©º:
        è¿”å› null

    æ ¹å€¼ = postorder æœ€åä¸€ä¸ªå…ƒç´ 
    åˆ›å»ºæ ¹èŠ‚ç‚¹

    åœ¨ inorder ä¸­æŸ¥æ‰¾æ ¹å€¼çš„ç´¢å¼• rootIdx

    å·¦å­æ ‘å¤§å° = rootIdx
    å³å­æ ‘å¤§å° = inorder é•¿åº¦ - 1 - rootIdx

    å·¦å­æ ‘ = buildTree(
        inorder[0:rootIdx],
        postorder[0:leftSize]
    )

    å³å­æ ‘ = buildTree(
        inorder[rootIdx+1:],
        postorder[leftSize:len(postorder)-1]
    )

    è¿”å› æ ¹èŠ‚ç‚¹
```

### Mermaid æµç¨‹å›¾

```mermaid
flowchart TD
    A[å¼€å§‹: buildTree(inorder, postorder)] --> B{postorder ä¸ºç©º?}
    B -- æ˜¯ --> C[è¿”å› null]
    B -- å¦ --> D[å– postorder æœ€åå…ƒç´ ä¸ºæ ¹]
    D --> E[åœ¨ inorder ä¸­æŸ¥æ‰¾æ ¹ä½ç½® rootIdx]
    E --> F[è®¡ç®—å·¦å­æ ‘å¤§å° leftSize]
    F --> G[è®¡ç®—å³å­æ ‘å¤§å° rightSize]
    G --> H[é€’å½’æ„å»ºå·¦å­æ ‘]
    H --> I[é€’å½’æ„å»ºå³å­æ ‘]
    I --> J[åˆ›å»ºæ ¹èŠ‚ç‚¹]
    J --> K[è¿æ¥å·¦å³å­æ ‘]
    K --> L[è¿”å›æ ¹èŠ‚ç‚¹]
```

### çŠ¶æ€è½¬ç§»å›¾(ç¤ºä¾‹)

```mermaid
graph LR
    subgraph æ‰§è¡Œè¿‡ç¨‹: inorder=[9,3,15,20,7], postorder=[9,15,7,20,3]
        S1[ç¬¬1å±‚: root=3] --> S1a[inorderä¸­3ä½ç½®=1]
        S1a --> S1b[å·¦å­æ ‘: inorder[0:1]=[9], postorder[0:1]=[9]]
        S1b --> S1c[å³å­æ ‘: inorder[2:5]=[15,20,7], postorder[1:4]=[15,7,20]]

        S1c --> S2[ç¬¬2å±‚: root=20]
        S2 --> S2a[inorderä¸­20ä½ç½®=3]
        S2a --> S2b[å·¦å­æ ‘: inorder[2:3]=[15], postorder[1:2]=[15]]
        S2b --> S2c[å³å­æ ‘: inorder[4:5]=[7], postorder[2:3]=[7]]

        S2b --> S3[ç¬¬3å±‚: root=15, æ— å­æ ‘]
        S2c --> S4[ç¬¬3å±‚: root=7, æ— å­æ ‘]
        S1b --> S5[ç¬¬2å±‚: root=9, æ— å­æ ‘]
    end
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: inorder=[9,3,15,20,7], postorder=[9,15,7,20,3]

#### é€’å½’æ‰§è¡Œè½¨è¿¹

| å±‚çº§ | inorder       | postorder     | æ ¹å€¼ | rootIdx | leftSize | rightSize | å·¦å­æ ‘åŒºé—´ | å³å­æ ‘åŒºé—´ |
| ---- | ------------- | ------------- | ---- | ------- | -------- | --------- | ---------- | ---------- |
| 1    | [9,3,15,20,7] | [9,15,7,20,3] | 3    | 1       | 1        | 3         | [9]        | [15,20,7]  |
| 2L   | [9]           | [9]           | 9    | 0       | 0        | 0         | []         | []         |
| 2R   | [15,20,7]     | [15,7,20]     | 20   | 1       | 1        | 1         | [15]       | [7]        |
| 3RL  | [15]          | [15]          | 15   | 0       | 0        | 0         | []         | []         |
| 3RR  | [7]           | [7]           | 7    | 0       | 0        | 0         | []         | []         |

#### æ„å»ºè¿‡ç¨‹

1. æ ¹=3ï¼Œåœ¨inorderä¸­ä½ç½®1 â†’ å·¦å­æ ‘1ä¸ªèŠ‚ç‚¹ï¼Œå³å­æ ‘3ä¸ªèŠ‚ç‚¹
1. å·¦å­æ ‘: inorder=[9], postorder=[9] â†’ èŠ‚ç‚¹9
1. å³å­æ ‘: inorder=[15,20,7], postorder=[15,7,20] â†’ æ ¹=20
1. 20çš„å·¦å­æ ‘: inorder=[15], postorder=[15] â†’ èŠ‚ç‚¹15
1. 20çš„å³å­æ ‘: inorder=[7], postorder=[7] â†’ èŠ‚ç‚¹7

æœ€ç»ˆæ ‘ç»“æ„:

```
    3
   / \
  9  20
    /  \
   15   7
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç (Go)

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func buildTree(inorder []int, postorder []int) *TreeNode {
    if len(postorder) == 0 {
        return nil
    }

    rootVal := postorder[len(postorder)-1]
    root := &TreeNode{Val: rootVal}

    rootIdx := 0
    for i, val := range inorder {
        if val == rootVal {
            rootIdx = i
            break
        }
    }

    leftSize := rootIdx
    rightSize := len(inorder) - 1 - rootIdx

    root.Left = buildTree(inorder[:rootIdx], postorder[:leftSize])
    root.Right = buildTree(inorder[rootIdx+1:], postorder[leftSize:len(postorder)-1])

    return root
}

// å±‚åºéå†è¾…åŠ©å‡½æ•°
func levelOrder(root *TreeNode) []interface{} {
    if root == nil {
        return []interface{}{}
    }
    queue := []*TreeNode{root}
    result := []interface{}{}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if node == nil {
            result = append(result, nil)
        } else {
            result = append(result, node.Val)
            queue = append(queue, node.Left, node.Right)
        }
    }
    // å»é™¤æœ«å°¾nil
    for len(result) > 0 && result[len(result)-1] == nil {
        result = result[:len(result)-1]
    }
    return result
}

func main() {
    // Test Case 1
    inorder1 := []int{9, 3, 15, 20, 7}
    postorder1 := []int{9, 15, 7, 20, 3}
    tree1 := buildTree(inorder1, postorder1)
    fmt.Printf("Test Case 1: %v\n", levelOrder(tree1)) // [3,9,20,null,null,15,7]

    // Test Case 2
    inorder2 := []int{-1}
    postorder2 := []int{-1}
    tree2 := buildTree(inorder2, postorder2)
    fmt.Printf("Test Case 2: %v\n", levelOrder(tree2)) // [-1]

    // Test Case 3
    inorder3 := []int{2, 1}
    postorder3 := []int{2, 1}
    tree3 := buildTree(inorder3, postorder3)
    fmt.Printf("Test Case 3: %v\n", levelOrder(tree3)) // [1,null,2]
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

åŸºç¡€ç‰ˆæœ¬æ—¶é—´å¤æ‚åº¦O(nÂ²)ï¼Œç©ºé—´å¤æ‚åº¦O(nÂ²)ï¼›ä¼˜åŒ–ç‰ˆæœ¬æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦(åŸºç¡€ç‰ˆ)

- æ¯å±‚é€’å½’éœ€åœ¨ä¸­åºæ•°ç»„ä¸­æŸ¥æ‰¾æ ¹ä½ç½®ï¼Œè€—æ—¶O(k)
- æœ€åæƒ…å†µ(é€€åŒ–æ ‘):
  - ç¬¬ä¸€å±‚: O(n)
  - ç¬¬äºŒå±‚: O(n-1)
  - ç¬¬ä¸‰å±‚: O(n-2)
  - ...
  - æ€»æ—¶é—´: n + (n-1) + ... + 1 = O(nÂ²)

#### B. ç©ºé—´å¤æ‚åº¦(åŸºç¡€ç‰ˆ)

- æ¯æ¬¡é€’å½’å¤åˆ¶å­æ•°ç»„:
  - ç¬¬ä¸€å±‚: O(n)
  - ç¬¬äºŒå±‚: O(n-1) + O(0)
  - ç¬¬ä¸‰å±‚: O(n-2) + O(1)
  - æ€»ç©ºé—´: O(nÂ²)

#### C. ä¼˜åŒ–ç‰ˆæœ¬å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦: O(n)
  - å“ˆå¸Œè¡¨é¢„å¤„ç†: O(n)
  - æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡: O(n)
- ç©ºé—´å¤æ‚åº¦: O(n)
  - å“ˆå¸Œè¡¨: O(n)
  - é€’å½’æ ˆ: O(h) â‰¤ O(n)

#### D. å¸¸æ•°å› å­åˆ†æ

- åˆ‡ç‰‡å¤åˆ¶å¼€é”€: å†…å­˜åˆ†é… + æ•°æ®æ‹·è´
- å“ˆå¸ŒæŸ¥æ‰¾å¼€é”€: O(1)å¹³å‡æ—¶é—´
- é€’å½’è°ƒç”¨å¼€é”€: å‡½æ•°æ ˆå¸§

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆ: é‡å¤éå†ä¸­åºæ•°ç»„æŸ¥æ‰¾æ ¹ä½ç½®
- ä¼˜åŒ–: å“ˆå¸Œè¡¨é¢„å¤„ç†ç´¢å¼•æ˜ å°„
- å·¥ç¨‹æƒè¡¡:
  - é¢è¯•ä¸­å…ˆå†™åŸºç¡€ç‰ˆæœ¬ï¼Œå†é—®"èƒ½å¦ä¼˜åŒ–?"
  - ä¼˜åŒ–ç‰ˆæœ¬ä¸ºåŠ åˆ†é¡¹ï¼Œä½†æ ¸å¿ƒæ€æƒ³ä¸å˜

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"éå†åºåˆ—é‡æ„æ ‘"æ¨¡å¼ï¼Œæ ¸å¿ƒåœ¨äº:

1. åˆ©ç”¨éå†é¡ºåºçš„ç»“æ„æ€§ä¿¡æ¯
1. é€šè¿‡æ ¹ä½ç½®åˆ’åˆ†é€’å½’å­é—®é¢˜
1. ä¾èµ–å”¯ä¸€æ€§ä¿è¯ç»“æ„å”¯ä¸€

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- æ ‘æ˜¯é€’å½’ç»“æ„ï¼Œéå†åºåˆ—æ˜¯å…¶"æŠ•å½±"
- ååº: æä¾›"æ ¹æ˜¯è°" â†’ æ„é€ é¡ºåº
- ä¸­åº: æä¾›"æ ¹çš„å·¦å³å­æ ‘èŒƒå›´" â†’ ç©ºé—´åˆ’åˆ†
- ç»„åˆå³å”¯ä¸€ç¼–ç : ä¸¤ç§éå†å…±åŒæ„æˆæ ‘çš„"DNA"

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®          | æ ¸å¿ƒæ€æƒ³      | åŒ¹é…æ¨¡å¼   |
| ---- | ------------- | ------------- | ---------- |
| 106  | æœ¬é¢˜          | ååº+ä¸­åºé‡å»º | æ ¸å¿ƒæ¨¡å¼   |
| 105  | å‰åº+ä¸­åºé‡å»º | å‰åºæ ¹åœ¨é¦–    | æ¨¡å¼å˜ä½“   |
| 889  | å‰åº+ååºé‡å»º | æ— æ³•å”¯ä¸€é‡å»º  | æ¨¡å¼è¾¹ç•Œ   |
| 652  | å¯»æ‰¾é‡å¤å­æ ‘  | å­æ ‘åºåˆ—åŒ–    | åºåˆ—åŒ–æ¨¡å¼ |

#### C. æ¨¡å¼æ³›åŒ–

- è¯­æ³•æ ‘è§£æ: ç¼–è¯‘å™¨æ ¹æ®è¡¨è¾¾å¼é¡ºåºæ„é€ AST
- æ•°æ®åº“ç´¢å¼•: B+æ ‘èŠ‚ç‚¹æŒ‰é¡ºåºå†™å…¥ï¼Œå¯é‡å»º
- ç½‘ç»œåè®®: æ ‘çŠ¶é…ç½®ç»“æ„é€šè¿‡åºåˆ—åŒ–æµè¿˜åŸ

#### D. å·¥ä¸šåº”ç”¨

- SQLè§£æå™¨: å°†ä¸­ç¼€è¡¨è¾¾å¼è§£æä¸ºè¯­æ³•æ ‘
- JSON Schema: æ ‘å½¢ç»“æ„é€šè¿‡"å­—æ®µé¡ºåº"é‡å»º
- ç¼–è¯‘å™¨å‰ç«¯: LRè§£æå™¨æœ¬è´¨å°±æ˜¯é€’å½’ä¸‹é™

#### E. ç®—æ³•æ·±å…¥è§£æ

1. å”¯ä¸€æ€§è¯æ˜:
   - æ•°å­¦å½’çº³æ³•
   - åŸºç¡€: å•èŠ‚ç‚¹å”¯ä¸€
   - å‡è®¾: k\<nèŠ‚ç‚¹å”¯ä¸€
   - å½’çº³: nèŠ‚ç‚¹æ ‘ï¼Œæ ¹ç”±ååºç¡®å®šï¼Œä¸­åºåˆ’åˆ†å·¦å³å­æ ‘ï¼Œå·¦å³å­æ ‘å”¯ä¸€ â†’ æ•´ä½“å”¯ä¸€

1. ä¸ºä½•å¿…é¡»å”¯ä¸€å€¼:
   - é‡å¤å€¼å¯¼è‡´ä¸­åºä¸­å¤šä¸ªç›¸åŒèŠ‚ç‚¹ï¼Œæ— æ³•åˆ¤æ–­å½“å‰æ ¹

1. ä¸ºä½•å¿…é¡»ååº+ä¸­åº:
   - ååºæä¾›æ ¹ï¼Œä¸­åºæä¾›ç»“æ„åˆ’åˆ†
   - å‰åº+ååºä¸èƒ½å”¯ä¸€é‡å»º(é™¤éæ»¡äºŒå‰æ ‘)

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿ:

1. å¯¹æ ‘ç»“æ„ä¸éå†å…³ç³»çš„ç†è§£
1. å¤æ‚åº¦æƒè¡¡çš„å·¥ç¨‹æ€ç»´
1. ä»åŸºç¡€åˆ°ä¼˜åŒ–çš„é€’è¿›èƒ½åŠ›

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆå¿…é¡»ç”¨ååºå’Œä¸­åº?åªç”¨ååºè¡Œå—?

â†’ æ ‡å‡†: ä¸è¡Œï¼Œååºåªèƒ½çŸ¥é“æ ¹å’Œé¡ºåºï¼Œä¸çŸ¥é“å·¦å³è¾¹ç•Œ
â†’ åŠ åˆ†: ååºå¦‚[9,15,7,20,3]å¯ä»¥æ˜¯å¤šç§ç»“æ„ï¼Œå¿…é¡»ç»“åˆä¸­åºçš„ä½ç½®ä¿¡æ¯

#### Q2: å¦‚æœæœ‰é‡å¤å…ƒç´ ï¼Œè¿˜èƒ½é‡å»ºå—?

â†’ æ ‡å‡†: ä¸èƒ½ï¼Œä¸­åºä¸­å¤šä¸ªç›¸åŒå€¼æ— æ³•ç¡®å®šæ ¹
â†’ åŠ åˆ†: å¯æ‰©å±•ä¸º"èŠ‚ç‚¹ID+å€¼"ç»“æ„ï¼Œæˆ–ä½¿ç”¨ç´¢å¼•å…ƒç»„

#### Q3: ä¸ºä»€ä¹ˆä¸ç”¨å“ˆå¸Œè¡¨ä¸€å¼€å§‹å°±ä¼˜åŒ–?

â†’ æ ‡å‡†: é¢è¯•ä¸­ä¼˜å…ˆå†™æ¸…æ™°ç‰ˆæœ¬ï¼Œå†ä¼˜åŒ–
â†’ åŠ åˆ†: åŸºç¡€ç‰ˆå±•ç¤ºç†è§£æœ¬è´¨ï¼Œä¼˜åŒ–ç‰ˆå±•ç¤ºå·¥ç¨‹èƒ½åŠ›

#### Q4: å¦‚æœç»™çš„æ˜¯å‰åºå’Œä¸­åºï¼Œæ€ä¹ˆæ”¹?

â†’ æ ‡å‡†: å‰åºç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ ¹ï¼Œå…¶ä½™é€»è¾‘ç›¸åŒ
â†’ åŠ åˆ†: æ”¹postorder[-1]ä¸ºpreorder[0]ï¼Œåˆ’åˆ†æ–¹å¼ä¸å˜

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•å®ç°ä¸å¤åˆ¶æ•°ç»„çš„O(n)è§£æ³•?

â†’ æ ‡å‡†: ç”¨å“ˆå¸Œè¡¨å­˜ä¸­åºç´¢å¼•ï¼Œä¼ é€’ç´¢å¼•èŒƒå›´
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–ç‰ˆä»£ç ï¼Œå±•ç¤ºç´¢å¼•ä¼ é€’æŠ€å·§

#### Q2: ä¸ºä»€ä¹ˆå‰åº+ååºä¸èƒ½å”¯ä¸€é‡å»º?

â†’ æ ‡å‡†: æ— æ³•ç¡®å®šå·¦å³å­æ ‘åˆ†ç•Œç‚¹
â†’ åŠ åˆ†: ä¸¾ä¾‹[1,2,3]æœ‰å¤šç§ç»“æ„ï¼Œé™¤éæ»¡äºŒå‰æ ‘

#### Q3: å¦‚ä½•æ‰©å±•ä¸ºæ”¯æŒNå‰æ ‘?

â†’ æ ‡å‡†: éœ€è¦é¢å¤–ä¿¡æ¯å¦‚å­èŠ‚ç‚¹ä¸ªæ•°
â†’ åŠ åˆ†: ååºæ”¹ä¸º"å­èŠ‚ç‚¹1,å­èŠ‚ç‚¹2,...,æ ¹,å­èŠ‚ç‚¹æ•°"ï¼Œä¸­åºéœ€è‡ªå®šä¹‰è§„åˆ™

#### Q4: è¿™ä¸ªç®—æ³•åœ¨ç¼–è¯‘å™¨ä¸­å¦‚ä½•åº”ç”¨?

â†’ æ ‡å‡†: è¯­æ³•æ ‘æ„é€ 
â†’ åŠ åˆ†: LRè§£æå™¨ç”¨ååº(tokenåºåˆ—)å’Œè¯­æ³•è§„åˆ™(ç±»ä¼¼ä¸­åº)æ„é€ AST

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®:

1. ç‰¢è®°"ååºå®šæ ¹ï¼Œä¸­åºåˆ†å·¦å³"
1. é€’å½’åˆ’åˆ†æ€ç»´æ¨¡å¼
1. ç´¢å¼•ä¼ é€’ä¼˜åŒ–æŠ€å·§
1. é¿å…æ··æ·†ä¸åŒéå†é¡ºåº

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹   | å£è¯€                             |
| -------- | -------------------------------- |
| æ„é€ æ ¸å¿ƒ | ååºå®šæ ¹ï¼Œä¸­åºåˆ†å·¦å³             |
| åˆ’åˆ†ä¾æ® | å·¦å­æ ‘å¤§å°=ä¸­åºæ ¹å·¦ä¾§å…ƒç´ ä¸ªæ•°    |
| é€’å½’å…¥å£ | æ¯æ¬¡é€’å½’:ååºæœ«å…ƒç´ =å½“å‰æ ¹       |
| ä¼˜åŒ–å…³é”® | å“ˆå¸Œè¡¨é¢„å­˜ä¸­åºç´¢å¼•ï¼ŒO(1)æŸ¥æ ¹ä½ç½® |
| æ˜“æ··é™·é˜± | å‰åºæ ¹åœ¨é¦–ï¼Œååºæ ¹åœ¨å°¾           |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹     | è§¦å‘åœºæ™¯                      | åº”å¯¹æªæ–½                        |
| ------------ | ----------------------------- | ------------------------------- |
| æ··æ·†å‰ååº   | æŠŠå‰åºæœ«å…ƒç´ å½“æ ¹              | è®°ä½:å‰åºæ ¹åœ¨é¦–ï¼Œååºæ ¹åœ¨å°¾     |
| ç´¢å¼•è®¡ç®—é”™è¯¯ | å·¦å­æ ‘å¤§å°=rootIdx+1          | å·¦å­æ ‘å¤§å°=rootIdx(ç´¢å¼•ä»0å¼€å§‹) |
| å¿˜è®°è¾¹ç•Œæ£€æŸ¥ | æœªåˆ¤æ–­postorderä¸ºç©º           | æ¯æ¬¡é€’å½’å‰å¿…é¡»æ£€æŸ¥              |
| åˆ‡ç‰‡è¶Šç•Œ     | postorder[leftSize:len-1]è¶…å‡º | ç”¨ç´¢å¼•ä¼ é€’é¿å…åˆ‡ç‰‡              |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯     | åº”ç”¨åœºæ™¯               |
| ---------- | ---------------------- |
| ååºå®šæ ¹   | æè¿°ç®—æ³•ç¬¬ä¸€æ­¥         |
| ä¸­åºåˆ’åˆ†   | æè¿°å­æ ‘åˆ†å‰²ä¾æ®       |
| é€’å½’åˆ’åˆ†   | å‘½åç®—æ³•èŒƒå¼           |
| ç´¢å¼•ä¼ é€’   | æè¿°ä¼˜åŒ–æ–¹æ¡ˆ           |
| å”¯ä¸€æ€§ä¿è¯ | è§£é‡Šä¸ºä»€ä¹ˆå¿…é¡»ä¸¤ä¸ªåºåˆ— |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: éå†åºåˆ—é‡å»ºæ ‘
â”œâ”€â”€ å¿…è¦æ¡ä»¶: ä¸¤ç§éå† + èŠ‚ç‚¹å”¯ä¸€
â”œâ”€â”€ æœ¬è´¨: ç»“æ„-åºåˆ—åŒå‘æ˜ å°„
â”œâ”€â”€ æ–¹æ³•: é€’å½’åˆ’åˆ†
â”‚   â”œâ”€â”€ ååº+ä¸­åº â†’ æ ¹åœ¨åï¼Œåˆ†åœ¨ä¸­
â”‚   â””â”€â”€ å‰åº+ä¸­åº â†’ æ ¹åœ¨å‰ï¼Œåˆ†åœ¨ä¸­
â”œâ”€â”€ ä¼˜åŒ–: å“ˆå¸Œé¢„å¤„ç† â†’ O(n)
â””â”€â”€ åº”ç”¨: ç¼–è¯‘å™¨ASTã€åºåˆ—åŒ–é‡å»º
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆ
å‡½æ•° buildTree(inorder, postorder):
    if postorder ä¸ºç©º: return null
    root_val = postorder[-1]
    root_idx = inorder.index(root_val)
    left_size = root_idx
    root = TreeNode(root_val)
    root.left = buildTree(inorder[:root_idx], postorder[:left_size])
    root.right = buildTree(inorder[root_idx+1:], postorder[left_size:-1])
    return root

// ä¼˜åŒ–ç‰ˆ
å‡½æ•° buildTree(inorder, postorder):
    map = {val: idx for idx, val in enumerate(inorder)}
    def helper(in_start, in_end, post_start, post_end):
        if post_start >= post_end: return null
        root_val = postorder[post_end-1]
        root_idx = map[root_val]
        left_size = root_idx - in_start
        root = TreeNode(root_val)
        root.left = helper(in_start, root_idx, post_start, post_start+left_size)
        root.right = helper(root_idx+1, in_end, post_start+left_size, post_end-1)
        return root
    return helper(0, len(inorder), 0, len(postorder))
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³æ­¤ç±»é—®é¢˜ï¼Œå±•ç°ç³»ç»Ÿæ€§æ€ç»´èƒ½åŠ›ã€‚ğŸ‰
