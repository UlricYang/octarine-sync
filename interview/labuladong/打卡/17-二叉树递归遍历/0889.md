# LeetCode 889 - æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘

## 1. é¢˜ç›®æè¿°

è¿”å›ä¸ç»™å®šçš„å‰åºå’Œååºéå†åŒ¹é…çš„ä»»ä½•äºŒå‰æ ‘

`pre` å’Œ `post` éå†ä¸­çš„å€¼æ˜¯ä¸åŒçš„æ­£æ•´æ•°

### ç¤ºä¾‹

```
è¾“å…¥ï¼špre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
è¾“å‡ºï¼š[1,2,3,4,5,6,7]
```

### çº¦æŸæ¡ä»¶

- `1 <= pre.length == post.length <= 30`
- `pre[]` å’Œ `post[]` éƒ½æ˜¯ `1, 2, ..., pre.length` çš„æ’åˆ—
- æ¯ä¸ªè¾“å…¥ä¿è¯è‡³å°‘æœ‰ä¸€ä¸ªç­”æ¡ˆã€‚å¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆï¼Œå¯ä»¥è¿”å›å…¶ä¸­ä»»ä½•ä¸€ä¸ª

## 2. è§£æ³•åˆ†æï¼šé€’å½’åˆ’åˆ†æ³•

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜çš„æœ€ä¼˜è§£æ˜¯é€’å½’åˆ’åˆ†æ³•ï¼Œå…¶æ ¸å¿ƒä¼˜åŠ¿åœ¨äºï¼š

1. åˆ©ç”¨å‰åºå’Œååºéå†çš„ç»“æ„ç‰¹æ€§ - å‰åºçš„ç¬¬äºŒä¸ªå…ƒç´ æ˜¯å·¦å­æ ‘çš„æ ¹ï¼Œååºçš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å·¦å­æ ‘çš„æ ¹
1. é€šè¿‡æ ¹èŠ‚ç‚¹ä½ç½®åˆ’åˆ†å­æ ‘åŒºé—´ - ç¡®å®šå·¦å­æ ‘çš„å¤§å°
1. é€’å½’æ„å»ºå·¦å³å­æ ‘ - æ¯æ¬¡å¤„ç†ä¸€ä¸ªå­é—®é¢˜
1. å…è®¸å¤šè§£ - ç”±äºå‰åº+ååºä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘ï¼Œç®—æ³•è¿”å›ä»»æ„åˆæ³•è§£

### æ”¯æ’‘è®ºç‚¹

#### A. ä¸ºä»€ä¹ˆé€’å½’åˆ’åˆ†æ³•æ˜¯æœ€ä¼˜è§£ï¼Ÿ

1. å‰åºéå†ç‰¹æ€§ï¼š`pre[0]` æ˜¯æ ¹èŠ‚ç‚¹ï¼Œ`pre[1]` æ˜¯å·¦å­æ ‘çš„æ ¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
1. ååºéå†ç‰¹æ€§ï¼š`post[-1]` æ˜¯æ ¹èŠ‚ç‚¹ï¼Œ`post[left_size-1]` æ˜¯å·¦å­æ ‘çš„æ ¹
1. ç»„åˆå¨åŠ›ï¼šé€šè¿‡åœ¨ååºä¸­æŸ¥æ‰¾å·¦å­æ ‘æ ¹çš„ä½ç½®ï¼Œå¯ä»¥ç¡®å®šå·¦å­æ ‘çš„å¤§å°
1. é€’å½’ç»“æ„ï¼šæ¯æ¬¡é€’å½’å¤„ç†ä¸€ä¸ªå­æ ‘ï¼Œç¬¦åˆæ ‘çš„é€’å½’å®šä¹‰
1. æ—¶é—´æœ€ä¼˜ï¼šæ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡ï¼ŒO(n) æ—¶é—´å¤æ‚åº¦

#### B. ä¸å…¶ä»–ç®—æ³•çš„å¯¹æ¯”åˆ†æ

| æ–¹æ³•             | æ˜¯å¦å¯è¡Œ | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°éš¾åº¦ | ç‰¹ç‚¹                 |
| ---------------- | -------- | ---------- | ---------- | -------- | -------------------- |
| é€’å½’åˆ’åˆ†æ³•(æœ¬è§£) | âœ…       | O(n)       | O(n)       | ä¸­       | é¢è¯•é¦–é€‰ï¼Œé€»è¾‘æ¸…æ™°   |
| å“ˆå¸Œä¼˜åŒ–é€’å½’æ³•   | âœ…       | O(n)       | O(n)       | ä¸­       | æ•ˆç‡æ›´é«˜ï¼Œå¼•å…¥å“ˆå¸Œè¡¨ |
| è¿­ä»£æ ˆæ³•         | âœ…       | O(n)       | O(n)       | é«˜       | ä»£ç å¤æ‚ï¼Œéš¾è°ƒè¯•     |
| æš´åŠ›é€’å½’         | âœ…       | O(nÂ²)      | O(n)       | ä½       | ä¼šè¶…æ—¶ï¼Œä¸å¯å–       |

> æ³¨ï¼šæœ¬é¢˜ä¸105/106ä¸åŒï¼Œå‰åº+ååºä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘ï¼Œå› æ­¤ç®—æ³•è¿”å›ä»»æ„åˆæ³•è§£

#### C. é€‚ç”¨æ¡ä»¶ä¸è¾¹ç•Œ

1. å¿…é¡»æ˜¯äºŒå‰æ ‘ï¼šNå‰æ ‘éœ€è¦ä¸åŒçš„å¤„ç†æ–¹å¼
1. èŠ‚ç‚¹å€¼å”¯ä¸€ï¼šé¢˜ç›®ä¿è¯å€¼å”¯ä¸€
1. åºåˆ—å®Œæ•´ä¸€è‡´ï¼šä¸¤åºåˆ—å¿…é¡»æ¥è‡ªåŒä¸€æ£µæ ‘
1. å…è®¸å¤šè§£ï¼šå‰åº+ååºä¸èƒ½å”¯ä¸€ç¡®å®šæ ‘ç»“æ„

#### D. å·¥ç¨‹å®è·µè€ƒé‡

1. é€’å½’æ·±åº¦ï¼šæœ€åO(n)ï¼Œéœ€è€ƒè™‘æ ˆæº¢å‡º
1. å‚æ•°ä¼ é€’ï¼šä½¿ç”¨ç´¢å¼•è€Œéåˆ‡ç‰‡ï¼Œé¿å…æ•°ç»„å¤åˆ¶
1. å¯è¯»æ€§ä¼˜å…ˆï¼šé¢è¯•ä¸­ä¼˜å…ˆæ¸…æ™°é€’å½’ç‰ˆæœ¬
1. å¤šè§£å¤„ç†ï¼šè¿”å›ä»»æ„åˆæ³•è§£å³å¯

### æ€»ç»“

é€’å½’åˆ’åˆ†æ³•æ˜¯æœ¬é¢˜åœ¨ç†è®ºæ­£ç¡®æ€§ã€æ€ç»´æ¸…æ™°åº¦å’Œå·¥ç¨‹è¡¨è¾¾ä¸Šçš„æœ€ä¼˜å¹³è¡¡ç‚¹

## 3. å¤šè¯­è¨€å®ç°ä¸æ·±åº¦è§£æ

### æ ¸å¿ƒç»“è®º

é€šè¿‡å››ç§è¯­è¨€å®ç°ï¼ŒéªŒè¯ç®—æ³•é€šç”¨æ€§ï¼Œå¹¶æ´å¯Ÿä¸åŒè¯­è¨€åœ¨é€’å½’ã€ç´¢å¼•ç®¡ç†å’Œå†…å­˜æ•ˆç‡ä¸Šçš„å·®å¼‚

### A. Go ğŸ¹ å®ç°

```go
/
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func constructFromPrePost(pre []int, post []int) *TreeNode {
    if len(pre) == 0 {
        return nil
    }

    root := &TreeNode{Val: pre[0]}

    // å•èŠ‚ç‚¹æƒ…å†µ
    if len(pre) == 1 {
        return root
    }

    // åœ¨ååºä¸­æŸ¥æ‰¾å·¦å­æ ‘æ ¹èŠ‚ç‚¹(å³pre[1])
    leftRootVal := pre[1]
    leftSize := 0
    for i, val := range post {
        if val == leftRootVal {
            leftSize = i + 1
            break
        }
    }

    // é€’å½’æ„å»ºå·¦å³å­æ ‘
    root.Left = constructFromPrePost(pre[1:1+leftSize], post[:leftSize])
    root.Right = constructFromPrePost(pre[1+leftSize:], post[leftSize:len(post)-1])

    return root
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. é€’å½’åŸºçº¿ï¼š`if len(pre) == 0` - ç©ºåºåˆ—è¿”å›nil
1. æ ¹èŠ‚ç‚¹ç¡®å®šï¼š`pre[0]` - å‰åºé¦–å…ƒç´ å¿…ä¸ºæ ¹
1. å•èŠ‚ç‚¹å¤„ç†ï¼š`if len(pre) == 1` - å¶å­èŠ‚ç‚¹ç›´æ¥è¿”å›
1. å·¦å­æ ‘æ ¹ç¡®å®šï¼š`pre[1]` - å‰åºç¬¬äºŒä¸ªå…ƒç´ æ˜¯å·¦å­æ ‘æ ¹
1. å·¦å­æ ‘å¤§å°ç¡®å®šï¼šåœ¨ååºä¸­æŸ¥æ‰¾å·¦å­æ ‘æ ¹çš„ä½ç½®
1. å­æ ‘åˆ’åˆ†ï¼š
   - å·¦å­æ ‘ï¼šå‰åº[1:1+leftSize], ååº[0:leftSize]
   - å³å­æ ‘ï¼šå‰åº[1+leftSize:], ååº[leftSize:len-1]

è®¾è®¡åŠ¨æœºï¼š

- å®Œå…¨åŸºäºé€’å½’åˆ’åˆ†ï¼Œæ¯å±‚å¤„ç†ä¸€ä¸ªå­æ ‘
- é€šè¿‡å‰åºç¬¬äºŒä¸ªå…ƒç´ å’Œååºä¸­å¯¹åº”ä½ç½®ç¡®å®šå·¦å­æ ‘å¤§å°
- å…è®¸å¤šè§£ï¼Œè¿”å›ä»»æ„åˆæ³•è§£

### B. Go ğŸ¹ å®ç°(ä¼˜åŒ–ç‰ˆ)

```go
func constructFromPrePost(pre []int, post []int) *TreeNode {
    // é¢„å¤„ç†ååºç´¢å¼•
    idxMap := make(map[int]int)
    for i, v := range post {
        idxMap[v] = i
    }

    var build func(int, int, int, int) *TreeNode
    build = func(preStart, preEnd, postStart, postEnd int) *TreeNode {
        if preStart >= preEnd {
            return nil
        }

        root := &TreeNode{Val: pre[preStart]}

        if preStart + 1 >= preEnd {
            return root
        }

        leftRootVal := pre[preStart+1]
        leftSize := idxMap[leftRootVal] - postStart + 1

        root.Left = build(preStart+1, preStart+1+leftSize, postStart, postStart+leftSize)
        root.Right = build(preStart+1+leftSize, preEnd, postStart+leftSize, postEnd-1)

        return root
    }

    return build(0, len(pre), 0, len(post))
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. å“ˆå¸Œé¢„å¤„ç†ï¼š`idxMap`å­˜å‚¨ååºå€¼â†’ç´¢å¼•ï¼ŒO(1)æŸ¥æ‰¾
1. ç´¢å¼•ä¼ é€’ï¼šä½¿ç”¨åŒºé—´å‚æ•°é¿å…åˆ‡ç‰‡å¤åˆ¶
1. æ ¹èŠ‚ç‚¹å¤„ç†ï¼š`pre[preStart]`è·å–æ ¹å€¼
1. å·¦å­æ ‘å¤§å°ç¡®å®šï¼šé€šè¿‡å“ˆå¸Œè¡¨å¿«é€ŸæŸ¥æ‰¾å·¦å­æ ‘æ ¹ä½ç½®
1. å­æ ‘åˆ’åˆ†ï¼š
   - å·¦å­æ ‘ï¼šå‰åº\[preStart+1, preStart+1+leftSize), ååº\[postStart, postStart+leftSize)
   - å³å­æ ‘ï¼šå‰åº\[preStart+1+leftSize, preEnd), ååº\[postStart+leftSize, postEnd-1)

ä¼˜åŒ–ç‚¹ï¼š

- æ—¶é—´å¤æ‚åº¦é™ä¸ºO(n)
- ç©ºé—´å¤æ‚åº¦O(n)ç”¨äºå“ˆå¸Œè¡¨
- æ— æ•°ç»„å¤åˆ¶ï¼Œå†…å­˜æ•ˆç‡é«˜

### C. Python ğŸ å®ç°

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def constructFromPrePost(self, pre: List[int], post: List[int]) -> Optional[TreeNode]:
        # é¢„å¤„ç†ååºç´¢å¼•
        idx_map = {val: idx for idx, val in enumerate(post)}

        def helper(pre_start, pre_end, post_start, post_end):
            if pre_start >= pre_end:
                return None

            root = TreeNode(pre[pre_start])

            if pre_start + 1 >= pre_end:
                return root

            left_root_val = pre[pre_start + 1]
            left_size = idx_map[left_root_val] - post_start + 1

            root.left = helper(pre_start + 1, pre_start + 1 + left_size,
                              post_start, post_start + left_size)
            root.right = helper(pre_start + 1 + left_size, pre_end,
                               post_start + left_size, post_end - 1)

            return root

        return helper(0, len(pre), 0, len(post))
```

#### ç®—æ³•æ·±å…¥è§£æ

1. å­—å…¸é¢„å¤„ç†ï¼š`idx_map`å¿«é€ŸæŸ¥æ‰¾æ ¹ä½ç½®
1. é—­åŒ…å‡½æ•°ï¼š`helper`ä½¿ç”¨å¤–éƒ¨`idx_map`
1. åŒºé—´å¤„ç†ï¼šä¸Goä¼˜åŒ–ç‰ˆæœ¬é€»è¾‘ä¸€è‡´
1. Pythonç‰¹æ€§ï¼š
   - å­—å…¸æ¨å¯¼å¼ç®€æ´é«˜æ•ˆ
   - é—­åŒ…è®¿é—®å¤–éƒ¨å˜é‡
   - ç±»å‹æç¤ºå¢å¼ºå¯è¯»æ€§

### D. TypeScript ğŸŸ¦ å®ç°

```typescript
/
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function constructFromPrePost(pre: number[], post: number[]): TreeNode | null {
    const idxMap = new Map<number, number>();
    post.forEach((val, idx) => idxMap.set(val, idx));

    const build = (preStart: number, preEnd: number, postStart: number, postEnd: number): TreeNode | null => {
        if (preStart >= preEnd) return null;

        const root = new TreeNode(pre[preStart]);

        if (preStart + 1 >= preEnd) return root;

        const leftRootVal = pre[preStart + 1];
        const leftSize = idxMap.get(leftRootVal)! - postStart + 1;

        root.left = build(preStart + 1, preStart + 1 + leftSize, postStart, postStart + leftSize);
        root.right = build(preStart + 1 + leftSize, preEnd, postStart + leftSize, postEnd - 1);

        return root;
    };

    return build(0, pre.length, 0, post.length);
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. Mapé¢„å¤„ç†ï¼š`idxMap`å­˜å‚¨å€¼â†’ç´¢å¼•
1. ç®­å¤´å‡½æ•°ï¼š`build`ä½¿ç”¨å¤–éƒ¨`idxMap`
1. ç±»å‹å®‰å…¨ï¼š
   - `Map<number, number>`æ˜ç¡®ç±»å‹
   - `!`æ–­è¨€éç©º(é¢˜ç›®ä¿è¯å­˜åœ¨)
1. TypeScriptç‰¹æ€§ï¼š
   - ç±»å‹æ³¨è§£å¢å¼ºå¯ç»´æŠ¤æ€§
   - ç®­å¤´å‡½æ•°ä¿æŒthisä¸Šä¸‹æ–‡

### E. Rust ğŸ¦€ å®ç°

```rust
// Definition for a binary tree node.
// #[derive(Debug, PartialEq, Eq)]
// pub struct TreeNode {
//   pub val: i32,
//   pub left: Option<Box<TreeNode>>,
//   pub right: Option<Box<TreeNode>>,
// }
//
// impl TreeNode {
//   #[inline]
//   pub fn new(val: i32) -> Self {
//     TreeNode {
//       val,
//       left: None,
//       right: None,
//     }
//   }
// }

use std::collections::HashMap;

impl Solution {
    pub fn construct_from_pre_post(pre: Vec<i32>, post: Vec<i32>) -> Option<Box<TreeNode>> {
        let idx_map: HashMap<i32, usize> = post.iter()
            .enumerate()
            .map(|(i, &v)| (v, i))
            .collect();

        fn build(
            pre: &[i32],
            post: &[i32],
            pre_start: usize,
            pre_end: usize,
            post_start: usize,
            post_end: usize,
            idx_map: &HashMap<i32, usize>
        ) -> Option<Box<TreeNode>> {
            if pre_start >= pre_end {
                return None;
            }

            let root_val = pre[pre_start];
            let mut root = TreeNode::new(root_val);

            if pre_start + 1 >= pre_end {
                return Some(Box::new(root));
            }

            let left_root_val = pre[pre_start + 1];
            let left_size = idx_map[&left_root_val] - post_start + 1;

            root.left = build(
                pre,
                post,
                pre_start + 1,
                pre_start + 1 + left_size,
                post_start,
                post_start + left_size,
                idx_map
            );

            root.right = build(
                pre,
                post,
                pre_start + 1 + left_size,
                pre_end,
                post_start + left_size,
                post_end - 1,
                idx_map
            );

            Some(Box::new(root))
        }

        build(
            &pre,
            &post,
            0,
            pre.len(),
            0,
            post.len(),
            &idx_map
        )
    }
}
```

#### ç®—æ³•æ·±å…¥è§£æ

1. HashMapé¢„å¤„ç†ï¼š`idx_map`å­˜å‚¨å€¼â†’ç´¢å¼•
1. åˆ‡ç‰‡å¼•ç”¨ï¼š`&pre`å’Œ`&post`é¿å…æ‰€æœ‰æƒè½¬ç§»
1. åµŒå¥—å‡½æ•°ï¼š`build`ä½¿ç”¨å¤–éƒ¨`idx_map`
1. Rustç‰¹æ€§ï¼š
   - æ‰€æœ‰æƒç³»ç»Ÿç¡®ä¿å†…å­˜å®‰å…¨
   - åˆ‡ç‰‡å¼•ç”¨æé«˜æ•ˆç‡
   - è¿­ä»£å™¨é“¾å¼è°ƒç”¨ç®€æ´é«˜æ•ˆ

### F. æ€§èƒ½å¯¹æ¯”ä¸è¯­è¨€ç‰¹æ€§åˆ†æ

| è¯­è¨€       | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | å®ç°æ–¹å¼     | ç‰¹ç‚¹               |
| ---------- | ---------- | ---------- | ------------ | ------------------ |
| Go(åŸºç¡€)   | O(nÂ²)      | O(nÂ²)      | åˆ‡ç‰‡å¤åˆ¶     | é€»è¾‘æ¸…æ™°ï¼Œé¢è¯•é¦–é€‰ |
| Go(ä¼˜åŒ–)   | O(n)       | O(n)       | ç´¢å¼•ä¼ é€’     | å·¥ä¸šçº§å®ç°         |
| Python     | O(n)       | O(n)       | å­—å…¸+é—­åŒ…    | ç®€æ´é«˜æ•ˆ           |
| TypeScript | O(n)       | O(n)       | Map+ç®­å¤´å‡½æ•° | ç±»å‹å®‰å…¨           |
| Rust       | O(n)       | O(n)       | HashMap+åˆ‡ç‰‡ | å†…å­˜å®‰å…¨           |

## 4. ç®—æ³•å¯è§†åŒ–ä¸ä¼ªä»£ç 

### ä¼ªä»£ç 

```
å‡½æ•° constructFromPrePost(pre, post):
    å¦‚æœ pre ä¸ºç©º:
        è¿”å› null

    æ ¹ = TreeNode(pre[0])

    å¦‚æœ pre é•¿åº¦ä¸º1:
        è¿”å› æ ¹

    å·¦å­æ ‘æ ¹å€¼ = pre[1]
    åœ¨ post ä¸­æŸ¥æ‰¾å·¦å­æ ‘æ ¹å€¼çš„ä½ç½® left_idx
    å·¦å­æ ‘å¤§å° = left_idx + 1

    æ ¹.left = constructFromPrePost(
        pre[1:1+left_size],
        post[0:left_size]
    )

    æ ¹.right = constructFromPrePost(
        pre[1+left_size:],
        post[left_size:len(post)-1]
    )

    è¿”å› æ ¹
```

### Mermaid æµç¨‹å›¾

```mermaid
graph TD
    %% --- é«˜å¯¹æ¯”åº¦æ ·å¼å®šä¹‰ ---
    classDef startEnd fill:#bbdefb,stroke:#1565c0,stroke-width:2px,color:#0d47a1
    classDef process fill:#fff9c4,stroke:#f57f17,stroke-width:2px,color:#1a237e
    classDef decision fill:#ffccbc,stroke:#d84315,stroke-width:2px,color:#4e0000
    classDef recursion fill:#c8e6c9,stroke:#1b5e20,stroke-width:2px,color:#003d00
    classDef partition fill:#e1f5fe,stroke:#0277bd,stroke-width:3px,color:#01579b
    classDef error fill:#ffcdd2,stroke:#b71c1c,stroke-width:2px,color:#4a0000

    %% --- ä¸»æµç¨‹å…¥å£ ---
    A(å¼€å§‹<br>æ„å»ºäºŒå‰æ ‘) --> B{ååºæ•°ç»„ä¸ºç©º?}
    class A,O startEnd
    class B decision

    %% --- é€’å½’åŸº ---
    B -- æ˜¯ --> C[è¿”å› null]
    class C recursion

    B -- å¦ --> D{æ•°ç»„åªæœ‰ä¸€ä¸ªå…ƒç´ ?}
    class D decision

    D -- æ˜¯ --> E[åˆ›å»ºå•èŠ‚ç‚¹æ ‘å¹¶è¿”å›]
    class E process

    %% --- æ ¸å¿ƒé€»è¾‘ï¼šç¡®å®šå·¦å³å­æ ‘æ ¹ ---
    D -- å¦ --> F["å‰åºç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æ ¹ '<b>rootVal</b>'"]
    class F process

    F --> G["å‰åºç¬¬äºŒä¸ªå…ƒç´ æ˜¯å·¦å­æ ‘çš„æ ¹ '<b>leftRootVal</b>'"]
    class G process

    %% --- å…³é”®åˆ†åŒºï¼šåˆ’åˆ†å·¦å³å­æ ‘åŒºé—´ ---
    subgraph åˆ’åˆ†å­æ ‘åŒºé—´
        direction TB
        H(åœ¨ååºæ•°ç»„ä¸­<br>æŸ¥æ‰¾ leftRootVal çš„ç´¢å¼•)
        class H process

        I[ğŸ“Œ å·¦å­æ ‘åŒ…å«çš„èŠ‚ç‚¹æ•°é‡<br><b>leftSize = leftRootIndex + 1</b>]
        class I process

        J[ğŸ“ å·¦å­æ ‘åŒºé—´åˆ’åˆ†]
        class J partition

        J --> J1(å‰åº: 1 ~ leftSize)
        J --> J2(ååº: 0 ~ leftSize-1)

        K[ğŸ“ å³å­æ ‘åŒºé—´åˆ’åˆ†]
        class K partition

        K --> K1(å‰åº: leftSize+1 ~ æœ«å°¾)
        K --> K2(ååº: leftSize ~ æœ«å°¾-1)
    end

    G --> åˆ’åˆ†å­æ ‘åŒºé—´

    %% --- é€’å½’æ„å»ºå­æ ‘ ---
    J1 & J2 --> L[â¬…ï¸ é€’å½’æ„å»ºå·¦å­æ ‘]
    K1 & K2 --> M[â¡ï¸ é€’å½’æ„å»ºå³å­æ ‘]
    class L,M recursion

    %% --- åˆå¹¶ä¸è¿”å› ---
    L --> N[å°†å·¦å­æ ‘æŒ‚åˆ°æ ¹èŠ‚ç‚¹]
    M --> O[å°†å³å­æ ‘æŒ‚åˆ°æ ¹èŠ‚ç‚¹]
    class N,O process

    N & O --> P([è¿”å›æ ¹èŠ‚ç‚¹])
    class P startEnd

```

### çŠ¶æ€è½¬ç§»å›¾(ç¤ºä¾‹)

```mermaid
graph LR
    subgraph æ‰§è¡Œè¿‡ç¨‹: pre=[1,2,4,5,3,6,7], post=[4,5,2,6,7,3,1]
        S1[ç¬¬1å±‚: root=1] --> S1a[å·¦å­æ ‘æ ¹=2]
        S1a --> S1b[åœ¨postä¸­æ‰¾åˆ°2çš„ä½ç½®=2]
        S1b --> S1c[å·¦å­æ ‘å¤§å°=3]
        S1c --> S1d[å·¦å­æ ‘: pre[1:4]=[2,4,5], post[0:3]=[4,5,2]]
        S1d --> S1e[å³å­æ ‘: pre[4:7]=[3,6,7], post[3:6]=[6,7,3]]

        S1d --> S2[ç¬¬2å±‚: root=2]
        S2 --> S2a[å·¦å­æ ‘æ ¹=4]
        S2a --> S2b[åœ¨postä¸­æ‰¾åˆ°4çš„ä½ç½®=0]
        S2b --> S2c[å·¦å­æ ‘å¤§å°=1]
        S2c --> S2d[å·¦å­æ ‘: pre[2:3]=[4], post[0:1]=[4]]
        S2d --> S2e[å³å­æ ‘: pre[3:4]=[5], post[1:2]=[5]]

        S2d --> S3[ç¬¬3å±‚: root=4, æ— å­æ ‘]
        S2e --> S4[ç¬¬3å±‚: root=5, æ— å­æ ‘]

        S1e --> S5[ç¬¬2å±‚: root=3]
        S5 --> S5a[å·¦å­æ ‘æ ¹=6]
        S5a --> S5b[åœ¨postä¸­æ‰¾åˆ°6çš„ä½ç½®=0]
        S5b --> S5c[å·¦å­æ ‘å¤§å°=1]
        S5c --> S5d[å·¦å­æ ‘: pre[5:6]=[6], post[3:4]=[6]]
        S5d --> S5e[å³å­æ ‘: pre[6:7]=[7], post[4:5]=[7]]

        S5d --> S6[ç¬¬3å±‚: root=6, æ— å­æ ‘]
        S5e --> S7[ç¬¬3å±‚: root=7, æ— å­æ ‘]
    end
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤º

### ç¤ºä¾‹: pre=[1,2,4,5,3,6,7], post=[4,5,2,6,7,3,1]

#### é€’å½’æ‰§è¡Œè½¨è¿¹

| å±‚çº§ | preåŒºé—´         | poståŒºé—´        | æ ¹å€¼ | å·¦å­æ ‘æ ¹ | left_idx | left_size | å·¦å­æ ‘åŒºé—´          | å³å­æ ‘åŒºé—´          |
| ---- | --------------- | --------------- | ---- | -------- | -------- | --------- | ------------------- | ------------------- |
| 1    | [1,2,4,5,3,6,7] | [4,5,2,6,7,3,1] | 1    | 2        | 2        | 3         | pre[1:4], post[0:3] | pre[4:7], post[3:6] |
| 2L   | [2,4,5]         | [4,5,2]         | 2    | 4        | 0        | 1         | pre[2:3], post[0:1] | pre[3:4], post[1:2] |
| 3LL  | [4]             | [4]             | 4    | -        | -        | -         | -                   | -                   |
| 3LR  | [5]             | [5]             | 5    | -        | -        | -         | -                   | -                   |
| 2R   | [3,6,7]         | [6,7,3]         | 3    | 6        | 0        | 1         | pre[5:6], post[3:4] | pre[6:7], post[4:5] |
| 3RL  | [6]             | [6]             | 6    | -        | -        | -         | -                   | -                   |
| 3RR  | [7]             | [7]             | 7    | -        | -        | -         | -                   | -                   |

#### æ„å»ºè¿‡ç¨‹

1. æ ¹=1ï¼Œå·¦å­æ ‘æ ¹=2ï¼Œåœ¨postä¸­ä½ç½®2 â†’ å·¦å­æ ‘å¤§å°=3
1. å·¦å­æ ‘: pre=[2,4,5], post=[4,5,2] â†’ æ ¹=2
   - å·¦å­æ ‘æ ¹=4ï¼Œåœ¨postä¸­ä½ç½®0 â†’ å·¦å­æ ‘å¤§å°=1
   - å·¦å­æ ‘: pre=[4], post=[4] â†’ èŠ‚ç‚¹4
   - å³å­æ ‘: pre=[5], post=[5] â†’ èŠ‚ç‚¹5
1. å³å­æ ‘: pre=[3,6,7], post=[6,7,3] â†’ æ ¹=3
   - å·¦å­æ ‘æ ¹=6ï¼Œåœ¨postä¸­ä½ç½®0 â†’ å·¦å­æ ‘å¤§å°=1
   - å·¦å­æ ‘: pre=[6], post=[6] â†’ èŠ‚ç‚¹6
   - å³å­æ ‘: pre=[7], post=[7] â†’ èŠ‚ç‚¹7

æœ€ç»ˆæ ‘ç»“æ„:

```
        1
       / \
      2   3
     / \ / \
    4 5 6 7
```

#### å¯æ‰§è¡Œæµ‹è¯•ä»£ç (Go)

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func constructFromPrePost(pre []int, post []int) *TreeNode {
    if len(pre) == 0 {
        return nil
    }

    root := &TreeNode{Val: pre[0]}

    if len(pre) == 1 {
        return root
    }

    leftRootVal := pre[1]
    leftSize := 0
    for i, val := range post {
        if val == leftRootVal {
            leftSize = i + 1
            break
        }
    }

    root.Left = constructFromPrePost(pre[1:1+leftSize], post[:leftSize])
    root.Right = constructFromPrePost(pre[1+leftSize:], post[leftSize:len(post)-1])

    return root
}

// å±‚åºéå†è¾…åŠ©å‡½æ•°
func levelOrder(root *TreeNode) []interface{} {
    if root == nil {
        return []interface{}{}
    }
    queue := []*TreeNode{root}
    result := []interface{}{}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if node == nil {
            result = append(result, nil)
        } else {
            result = append(result, node.Val)
            queue = append(queue, node.Left, node.Right)
        }
    }
    // å»é™¤æœ«å°¾nil
    for len(result) > 0 && result[len(result)-1] == nil {
        result = result[:len(result)-1]
    }
    return result
}

func main() {
    // Test Case 1
    pre1 := []int{1, 2, 4, 5, 3, 6, 7}
    post1 := []int{4, 5, 2, 6, 7, 3, 1}
    tree1 := constructFromPrePost(pre1, post1)
    fmt.Printf("Test Case 1: %v\n", levelOrder(tree1)) // [1,2,3,4,5,6,7]

    // Test Case 2
    pre2 := []int{1}
    post2 := []int{1}
    tree2 := constructFromPrePost(pre2, post2)
    fmt.Printf("Test Case 2: %v\n", levelOrder(tree2)) // [1]

    // Test Case 3 - å¯èƒ½æœ‰å¤šè§£
    pre3 := []int{1, 2, 3}
    post3 := []int{3, 2, 1}
    tree3 := constructFromPrePost(pre3, post3)
    fmt.Printf("Test Case 3: %v\n", levelOrder(tree3)) // [1,2,null,3] æˆ– [1,null,2,3]
}
```

## 6. å¤æ‚åº¦åˆ†æ

### æ ¸å¿ƒç»“è®º

åŸºç¡€ç‰ˆæœ¬æ—¶é—´å¤æ‚åº¦O(nÂ²)ï¼Œç©ºé—´å¤æ‚åº¦O(nÂ²)ï¼›ä¼˜åŒ–ç‰ˆæœ¬æ—¶é—´å¤æ‚åº¦O(n)ï¼Œç©ºé—´å¤æ‚åº¦O(n)

### æ”¯æ’‘è®ºç‚¹

#### A. æ—¶é—´å¤æ‚åº¦(åŸºç¡€ç‰ˆ)

- æ¯å±‚é€’å½’éœ€åœ¨ååºæ•°ç»„ä¸­æŸ¥æ‰¾å·¦å­æ ‘æ ¹ä½ç½®ï¼Œè€—æ—¶O(k)
- æœ€åæƒ…å†µ(é€€åŒ–æ ‘):
  - ç¬¬ä¸€å±‚: O(n)
  - ç¬¬äºŒå±‚: O(n-1)
  - ç¬¬ä¸‰å±‚: O(n-2)
  - ...
  - æ€»æ—¶é—´: n + (n-1) + ... + 1 = O(nÂ²)

#### B. ç©ºé—´å¤æ‚åº¦(åŸºç¡€ç‰ˆ)

- æ¯æ¬¡é€’å½’å¤åˆ¶å­æ•°ç»„:
  - ç¬¬ä¸€å±‚: O(n)
  - ç¬¬äºŒå±‚: O(n-1) + O(0)
  - ç¬¬ä¸‰å±‚: O(n-2) + O(1)
  - æ€»ç©ºé—´: O(nÂ²)

#### C. ä¼˜åŒ–ç‰ˆæœ¬å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦: O(n)
  - å“ˆå¸Œè¡¨é¢„å¤„ç†: O(n)
  - æ¯ä¸ªèŠ‚ç‚¹è®¿é—®ä¸€æ¬¡: O(n)
- ç©ºé—´å¤æ‚åº¦: O(n)
  - å“ˆå¸Œè¡¨: O(n)
  - é€’å½’æ ˆ: O(h) â‰¤ O(n)

#### D. å¸¸æ•°å› å­åˆ†æ

- åˆ‡ç‰‡å¤åˆ¶å¼€é”€: å†…å­˜åˆ†é… + æ•°æ®æ‹·è´
- å“ˆå¸ŒæŸ¥æ‰¾å¼€é”€: O(1)å¹³å‡æ—¶é—´
- é€’å½’è°ƒç”¨å¼€é”€: å‡½æ•°æ ˆå¸§

#### E. æ€§èƒ½ç“¶é¢ˆä¸ä¼˜åŒ–

- ç“¶é¢ˆ: é‡å¤éå†ååºæ•°ç»„æŸ¥æ‰¾å·¦å­æ ‘æ ¹ä½ç½®
- ä¼˜åŒ–: å“ˆå¸Œè¡¨é¢„å¤„ç†ç´¢å¼•æ˜ å°„
- å·¥ç¨‹æƒè¡¡:
  - é¢è¯•ä¸­å…ˆå†™åŸºç¡€ç‰ˆæœ¬ï¼Œå†é—®"èƒ½å¦ä¼˜åŒ–?"
  - ä¼˜åŒ–ç‰ˆæœ¬ä¸ºåŠ åˆ†é¡¹ï¼Œä½†æ ¸å¿ƒæ€æƒ³ä¸å˜

## 7. æŠ€å·§å½’çº³ä¸æ¨¡å¼æŠ½è±¡

### æ ¸å¿ƒç»“è®º

æœ¬é¢˜å±äº"éå†åºåˆ—é‡æ„æ ‘"æ¨¡å¼çš„è¾¹ç•Œæƒ…å†µï¼Œæ ¸å¿ƒåœ¨äºï¼š

1. ç†è§£å‰åº+ååºä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘
1. é€šè¿‡å·¦å­æ ‘æ ¹çš„ä½ç½®ç¡®å®šå­æ ‘å¤§å°
1. é€’å½’æ„å»ºä»»æ„åˆæ³•è§£
1. è®¤è¯†åˆ°æ ‘çš„ç»“æ„ä¸éå†åºåˆ—çš„å…³ç³»

### æ”¯æ’‘è®ºç‚¹

#### A. æ¨¡å¼æœ¬è´¨

- æ ‘æ˜¯é€’å½’ç»“æ„ï¼Œéå†åºåˆ—æ˜¯å…¶"æŠ•å½±"
- å‰åº: æä¾›"æ ¹-å·¦-å³"é¡ºåº
- ååº: æä¾›"å·¦-å³-æ ¹"é¡ºåº
- ç»„åˆé™åˆ¶: ä»…å‰åº+ååºæ— æ³•å”¯ä¸€ç¡®å®šç»“æ„(é™¤éæ»¡äºŒå‰æ ‘)
- è®¾è®¡å“²å­¦: ç»“æ„ä¸é¡ºåºçš„éƒ¨åˆ†æ˜ å°„ï¼Œä½“ç°ä¿¡æ¯ä¸å®Œå¤‡æ€§

#### B. ç›¸ä¼¼é¢˜ç›®æ˜ å°„

| é¢˜å· | é¢˜ç›®          | æ ¸å¿ƒæ€æƒ³          | åŒ¹é…æ¨¡å¼   |
| ---- | ------------- | ----------------- | ---------- |
| 889  | æœ¬é¢˜          | å‰åº+ååºé‡å»º     | æ¨¡å¼è¾¹ç•Œ   |
| 105  | å‰åº+ä¸­åºé‡å»º | å‰åº+ä¸­åºå”¯ä¸€é‡å»º | æ ¸å¿ƒæ¨¡å¼   |
| 106  | ååº+ä¸­åºé‡å»º | ååº+ä¸­åºå”¯ä¸€é‡å»º | æ ¸å¿ƒæ¨¡å¼   |
| 652  | å¯»æ‰¾é‡å¤å­æ ‘  | å­æ ‘åºåˆ—åŒ–        | åºåˆ—åŒ–æ¨¡å¼ |

#### C. æ¨¡å¼æ³›åŒ–

- è¡¨è¾¾å¼æ ‘: å½“è¡¨è¾¾å¼æ ‘ä¸ºæ»¡äºŒå‰æ ‘æ—¶ï¼Œå¯å”¯ä¸€é‡å»º
- é…ç½®æ ‘: å½“é…ç½®æ ‘æœ‰æ˜ç¡®çš„å­èŠ‚ç‚¹é¡ºåºæ—¶ï¼Œå¯é‡å»º
- ç‰ˆæœ¬æ§åˆ¶: æ ‘çš„å˜æ›´å†å²å¯é€šè¿‡éå†åºåˆ—è¿½è¸ª

#### D. å·¥ä¸šåº”ç”¨

- ç¼–è¯‘å™¨: å½“ASTä¸ºæ»¡äºŒå‰æ ‘æ—¶ï¼Œå¯é€šè¿‡å‰åº+ååºé‡å»º
- æ•°æ®åº“: å½“ç´¢å¼•æ ‘ä¸ºæ»¡äºŒå‰æ ‘æ—¶ï¼Œå¯é‡å»º
- æ¸¸æˆå¼•æ“: åœºæ™¯å›¾çš„éƒ¨åˆ†é‡å»º

#### E. ç®—æ³•æ·±å…¥è§£æ

1. ä¸ºä»€ä¹ˆå‰åº+ååºä¸èƒ½å”¯ä¸€é‡å»ºï¼Ÿ
   - åä¾‹: æ ‘[1,2,3]å¯ä»¥æœ‰ä¸¤ç§ç»“æ„:
     - 1ä¸ºæ ¹ï¼Œ2ä¸ºå·¦ï¼Œ3ä¸ºå³
     - 1ä¸ºæ ¹ï¼Œ2ä¸ºå³ï¼Œ3ä¸ºå·¦
   - ä¸¤è€…å‰åºéƒ½æ˜¯[1,2,3]ï¼Œååºéƒ½æ˜¯[3,2,1]

1. ä»€ä¹ˆæƒ…å†µä¸‹å¯ä»¥å”¯ä¸€é‡å»ºï¼Ÿ
   - å½“æ ‘ä¸ºæ»¡äºŒå‰æ ‘(æ¯ä¸ªèŠ‚ç‚¹æœ‰0æˆ–2ä¸ªå­èŠ‚ç‚¹)æ—¶ï¼Œå¯ä»¥å”¯ä¸€é‡å»º
   - å› ä¸ºæ­¤æ—¶å·¦å­æ ‘å’Œå³å­æ ‘éƒ½å­˜åœ¨ï¼Œå¯ä»¥æ˜ç¡®åˆ’åˆ†

1. æœ¬é¢˜çš„è§£å†³æ–¹æ¡ˆï¼Ÿ
   - é€šè¿‡å‰åºç¬¬äºŒä¸ªå…ƒç´ ä½œä¸ºå·¦å­æ ‘æ ¹ï¼Œåœ¨ååºä¸­æŸ¥æ‰¾å…¶ä½ç½®
   - ç¡®å®šå·¦å­æ ‘å¤§å°åï¼Œé€’å½’æ„å»º
   - è¿”å›ä»»æ„åˆæ³•è§£

## 8. é¢è¯•è¿½é—®ä¸å›ç­”ç­–ç•¥

### æ ¸å¿ƒç»“è®º

é¢è¯•è¿½é—®è€ƒå¯Ÿ:

1. å¯¹æ ‘ç»“æ„ä¸éå†å…³ç³»çš„æ·±å±‚ç†è§£
1. å¤æ‚åº¦åˆ†æä¸ä¼˜åŒ–èƒ½åŠ›
1. ä»åŸºç¡€åˆ°ä¼˜åŒ–çš„é€’è¿›æ€ç»´
1. å¯¹å¤šè§£é—®é¢˜çš„å¤„ç†èƒ½åŠ›

### A. åŸºç¡€è¿½é—®

#### Q1: ä¸ºä»€ä¹ˆå‰åº+ååºä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘ï¼Ÿ

â†’ æ ‡å‡†: å› ä¸ºæ— æ³•ç¡®å®šå·¦å³å­æ ‘çš„åˆ†ç•Œç‚¹
â†’ åŠ åˆ†: ä¸¾ä¾‹[1,2,3]æœ‰ä¸¤ç§ç»“æ„ï¼Œå‰åºååºç›¸åŒ

#### Q2: ä»€ä¹ˆæƒ…å†µä¸‹å¯ä»¥å”¯ä¸€ç¡®å®šï¼Ÿ

â†’ æ ‡å‡†: å½“æ ‘ä¸ºæ»¡äºŒå‰æ ‘æ—¶
â†’ åŠ åˆ†: å› ä¸ºæ¯ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ— å­èŠ‚ç‚¹ï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œå¯ä»¥æ˜ç¡®åˆ’åˆ†

#### Q3: å¦‚ä½•ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ï¼Ÿ

â†’ æ ‡å‡†: ä½¿ç”¨å“ˆå¸Œè¡¨é¢„å¤„ç†ååºç´¢å¼•
â†’ åŠ åˆ†: æä¾›ä¼˜åŒ–ç‰ˆä»£ç ï¼Œå±•ç¤ºO(n)å®ç°

#### Q4: å¦‚æœç»™å®šçš„åºåˆ—ä¸åŒ¹é…ï¼Œå¦‚ä½•å¤„ç†ï¼Ÿ

â†’ æ ‡å‡†: é¢˜ç›®ä¿è¯æœ‰è§£ï¼Œæ— éœ€å¤„ç†
â†’ åŠ åˆ†: å®é™…å·¥ç¨‹ä¸­éœ€éªŒè¯åºåˆ—åˆæ³•æ€§ï¼Œå¯é€šè¿‡é€’å½’è¿‡ç¨‹ä¸­æ£€æŸ¥åŒºé—´æ˜¯å¦æœ‰æ•ˆ

### B. é«˜é˜¶è¿½é—®

#### Q1: å¦‚ä½•æ‰©å±•åˆ°Nå‰æ ‘ï¼Ÿ

â†’ æ ‡å‡†: éœ€è¦é¢å¤–ä¿¡æ¯è¡¨ç¤ºå­èŠ‚ç‚¹ä¸ªæ•°
â†’ åŠ åˆ†: å‰åºæ”¹ä¸º"æ ¹,å­èŠ‚ç‚¹1,å­èŠ‚ç‚¹2,...,å­èŠ‚ç‚¹n"ï¼Œååºæ”¹ä¸º"å­èŠ‚ç‚¹1,...,å­èŠ‚ç‚¹n,æ ¹"

#### Q2: å¦‚ä½•è¯æ˜ç®—æ³•çš„æ­£ç¡®æ€§ï¼Ÿ

â†’ æ ‡å‡†: é€šè¿‡æ„é€ æ€§è¯æ˜
â†’ åŠ åˆ†: æ•°å­¦å½’çº³æ³•ï¼ŒåŸºç¡€å•èŠ‚ç‚¹æ­£ç¡®ï¼Œå‡è®¾k\<nèŠ‚ç‚¹æ­£ç¡®ï¼Œè¯æ˜nèŠ‚ç‚¹æ­£ç¡®

#### Q3: å¦‚ä½•å¤„ç†èŠ‚ç‚¹å€¼é‡å¤çš„æƒ…å†µï¼Ÿ

â†’ æ ‡å‡†: é¢˜ç›®ä¿è¯å€¼å”¯ä¸€ï¼Œæ— éœ€å¤„ç†
â†’ åŠ åˆ†: å¯æ‰©å±•ä¸º"èŠ‚ç‚¹ID+å€¼"ç»“æ„ï¼Œæˆ–ä½¿ç”¨ç´¢å¼•å…ƒç»„åŒºåˆ†

#### Q4: è¿™ä¸ªç®—æ³•åœ¨å®é™…ä¸­æœ‰ä»€ä¹ˆåº”ç”¨ï¼Ÿ

â†’ æ ‡å‡†: æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–
â†’ åŠ åˆ†: ç‰ˆæœ¬æ§åˆ¶ç³»ç»Ÿä¸­æ ‘çš„å˜æ›´è¿½è¸ªï¼Œå½“æ ‘ä¸ºæ»¡äºŒå‰æ ‘æ—¶å¯é‡å»º

## 9. å¤ä¹ è¦ç‚¹æç‚¼

### æ ¸å¿ƒç»“è®º

æŒæ¡æœ¬é¢˜å…³é”®:

1. ç†è§£å‰åº+ååºä¸èƒ½å”¯ä¸€ç¡®å®šäºŒå‰æ ‘
1. ç‰¢è®°"å‰åºç¬¬äºŒä¸ªå…ƒç´ æ˜¯å·¦å­æ ‘æ ¹"
1. é€šè¿‡ååºä¸­å·¦å­æ ‘æ ¹çš„ä½ç½®ç¡®å®šå·¦å­æ ‘å¤§å°
1. é€’å½’æ„å»ºä»»æ„åˆæ³•è§£

### A. å…³é”®è®°å¿†ç‚¹(ğŸŒŸ)

| è®°å¿†ç‚¹     | å£è¯€                       |
| ---------- | -------------------------- |
| æ„é€ æ ¸å¿ƒ   | å‰åºå®šæ ¹ï¼Œååºå®šå·¦å­æ ‘å¤§å° |
| å·¦å­æ ‘æ ¹   | å‰åºç¬¬äºŒä¸ªå…ƒç´              |
| å·¦å­æ ‘å¤§å° | ååºä¸­å·¦å­æ ‘æ ¹çš„ä½ç½®+1     |
| å¤šè§£æƒ…å†µ   | è¿”å›ä»»æ„åˆæ³•è§£             |
| å”¯ä¸€æ€§æ¡ä»¶ | æ»¡äºŒå‰æ ‘æ—¶å¯å”¯ä¸€é‡å»º       |

### B. æ˜“é”™é™·é˜±(âš ï¸)

| é”™è¯¯ç±»å‹       | è§¦å‘åœºæ™¯                  | åº”å¯¹æªæ–½              |
| -------------- | ------------------------- | --------------------- |
| æ··æ·†å·¦å­æ ‘æ ¹   | è¯¯ç”¨pre[0]ä½œä¸ºå·¦å­æ ‘æ ¹    | è®°ä½:å·¦å­æ ‘æ ¹æ˜¯pre[1] |
| ç´¢å¼•è®¡ç®—é”™è¯¯   | å·¦å­æ ‘å¤§å°=left_idx       | åº”ä¸ºleft_idx+1        |
| å¿˜è®°å•èŠ‚ç‚¹å¤„ç† | æœªå¤„ç†preé•¿åº¦ä¸º1çš„æƒ…å†µ    | æ¯æ¬¡é€’å½’å‰æ£€æŸ¥        |
| åˆ‡ç‰‡è¶Šç•Œ       | pre[1+left_size:]è¶…å‡ºèŒƒå›´ | ä½¿ç”¨ç´¢å¼•ä¼ é€’é¿å…åˆ‡ç‰‡  |

### C. é¢è¯•è¯„åˆ†å…³é”®è¯(âœ…)

| å…³é”®è¯           | åº”ç”¨åœºæ™¯         |
| ---------------- | ---------------- |
| å‰åºå®šæ ¹         | æè¿°ç®—æ³•ç¬¬ä¸€æ­¥   |
| ååºå®šå·¦å­æ ‘å¤§å° | æè¿°å­æ ‘åˆ’åˆ†ä¾æ® |
| é€’å½’åˆ’åˆ†         | å‘½åç®—æ³•èŒƒå¼     |
| å¤šè§£å¤„ç†         | è§£é‡Šè¿”å›ä»»æ„è§£   |
| æ»¡äºŒå‰æ ‘å”¯ä¸€æ€§   | è®¨è®ºå”¯ä¸€é‡å»ºæ¡ä»¶ |

### D. å¤ä¹ å»ºè®®(ğŸ“šğŸš€)

```
æ ¸å¿ƒæ¨¡å¼: éå†åºåˆ—é‡å»ºæ ‘(è¾¹ç•Œæƒ…å†µ)
â”œâ”€â”€ å¿…è¦æ¡ä»¶: å‰åº+ååº + é¢˜ç›®ä¿è¯æœ‰è§£
â”œâ”€â”€ æœ¬è´¨: ç»“æ„ä¸åºåˆ—çš„éƒ¨åˆ†æ˜ å°„
â”œâ”€â”€ æ–¹æ³•: é€’å½’åˆ’åˆ†
â”‚   â”œâ”€â”€ å‰åºç¬¬äºŒä¸ªå…ƒç´ =å·¦å­æ ‘æ ¹
â”‚   â””â”€â”€ ååºä¸­å·¦å­æ ‘æ ¹ä½ç½®=å·¦å­æ ‘å¤§å°
â”œâ”€â”€ ä¼˜åŒ–: å“ˆå¸Œé¢„å¤„ç† â†’ O(n)
â”œâ”€â”€ åº”ç”¨: ç‰ˆæœ¬æ§åˆ¶ã€åºåˆ—åŒ–
â””â”€â”€ æ‰©å±•: Nå‰æ ‘ã€æ»¡äºŒå‰æ ‘å”¯ä¸€é‡å»º
```

### E. è§£é¢˜æ¨¡æ¿

```text
// åŸºç¡€ç‰ˆ
å‡½æ•° constructFromPrePost(pre, post):
    if pre ä¸ºç©º: return null
    root = TreeNode(pre[0])
    if pre é•¿åº¦ä¸º1: return root
    left_root_val = pre[1]
    left_idx = post.index(left_root_val)
    left_size = left_idx + 1
    root.left = constructFromPrePost(pre[1:1+left_size], post[0:left_size])
    root.right = constructFromPrePost(pre[1+left_size:], post[left_size:-1])
    return root

// ä¼˜åŒ–ç‰ˆ
å‡½æ•° constructFromPrePost(pre, post):
    map = {val: idx for idx, val in enumerate(post)}
    def helper(pre_start, pre_end, post_start, post_end):
        if pre_start >= pre_end: return null
        root = TreeNode(pre[pre_start])
        if pre_start + 1 >= pre_end: return root
        left_root_val = pre[pre_start+1]
        left_size = map[left_root_val] - post_start + 1
        root.left = helper(pre_start+1, pre_start+1+left_size, post_start, post_start+left_size)
        root.right = helper(pre_start+1+left_size, pre_end, post_start+left_size, post_end-1)
        return root
    return helper(0, len(pre), 0, len(post))
```

### æ€»ç»“

å°†ä¸Šè¿°è¦ç‚¹èä¼šè´¯é€šï¼Œå³å¯åœ¨é¢è¯•ä¸­å¿«é€Ÿå‡†ç¡®è§£å†³æ­¤ç±»é—®é¢˜ï¼Œå¹¶å±•ç°å¯¹æ ‘ç»“æ„ä¸éå†å…³ç³»çš„æ·±åˆ»ç†è§£ã€‚ğŸ‰
