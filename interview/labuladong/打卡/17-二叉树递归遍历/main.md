# 二叉树递归遍历

## 二叉树心法

### 思路

- 翻转二叉树

这题能不能用「遍历」的思维模式解决？可以，我写一个 traverse 函数遍历每个节点，让每个节点的左右子节点颠倒过来就行了
单独抽出一个节点，需要让它做什么？让它把自己的左右子节点交换一下
需要在什么时候做？好像前中后序位置都可以

- 填充节点的右侧指针

这题能不能用「遍历」的思维模式解决？很显然，一定可以。每个节点要做的事也很简单，把自己的 next 指针指向右侧节点就行了
传统的 traverse 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「空隙」
所以我们可以在二叉树的基础上进行抽象，你把图中的每一个方框看做一个节点，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点
只要实现一个 traverse 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251127121829388.png)

- 二叉树展开为链表

这题能不能用「分解问题」的思维模式解决？对于一个节点 x，可以执行以下流程：

1. 先利用 flatten(x.left) 和 flatten(x.right) 将 x 的左右子树拉平
1. 将 x 的右子树接到左子树下方，然后将整个左子树作为右子树

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251127122445344.jpeg)

## 构造

二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树

## 后序

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据

那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了

## 序列化

要说序列化和反序列化，得先从 JSON 数据格式说起
JSON 的运用非常广泛，比如我们经常将编程语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了

这就是序列化和反序列化的目的，以某种特定格式组织数据，使得数据可以独立于编程语言

那么假设现在有一棵用 Java 实现的二叉树，我想把它通过某些方式存储下来，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行序列化和反序列化了

Q：如果给你一棵二叉树的前序遍历结果，你是否能够根据这个结果还原出这棵二叉树呢？
A：也许可以，也许不可以，具体要看你给的前序遍历结果是否包含空指针的信息。如果包含了空指针，那么就可以唯一确定一棵二叉树，否则就不行

Q：遍历结果包含空指针的信息，那么就能还原出唯一的一棵二叉树？
A：即便你包含了空指针的信息，也只有前序和后序的遍历结果才能唯一还原二叉树，中序遍历结果做不到。因为前序/后序遍历的结果中，可以确定根节点的位置，而中序遍历的结果中，根节点的位置是无法确定的

当二叉树中节点的值不存在重复时：

- 如果你的序列化结果中不包含空指针的信息，且你只给出一种遍历顺序，那么你无法还原出唯一的一棵二叉树

- 如果你的序列化结果中不包含空指针的信息，且你会给出两种遍历顺序，分两种情况：

1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树
1. 如果你给出前序和后序，那么你无法还原出唯一的一棵二叉树

- 如果你的序列化结果中包含空指针的信息，且你只给出一种遍历顺序，也要分两种情况：

1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树
1. 如果你给出的是中序，那么你无法还原出唯一的一棵二叉树
