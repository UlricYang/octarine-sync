# 栈与队列

队列和栈都是「操作受限」的数据结构。队列只能在一端插入元素，另一端删除元素；栈只能在某一端插入和删除元素。说白了就是把数组链表提供的 API 删掉了一部分，只保留头尾操作元素的 API 给你用。形象地理解，队列只允许在队尾插入元素，在队头删除元素，栈只允许在栈顶插入元素，从栈顶删除元素

队列是一种「先进先出」的数据结构，栈是一种「先进后出」的数据结构

## 链表实现

### 栈

直接调用双链表(container/list)的 API 就可以了。把双链表的尾部作为栈顶，在双链表尾部增删元素的时间复杂度都是 O(1)，符合要求。当然，你也可以把双链表的头部作为栈顶，因为双链表头部增删元素的时间复杂度也是 O(1)，所以这样实现也是一样的

### 队列

把双链表(container/list)的尾部作为队尾，把双链表的头部作为队头，在双链表的头尾增删元素的复杂度都是 O(1)，符合队列 API 的要求。当然，你也可以反过来，把双链表的头部作为队尾，双链表的尾部作为队头。类似栈的实现，只要改一改 list 的调用方法就行了

## 数组实现

### 栈

把动态数组([]int)的尾部作为栈顶，然后调用动态数组的 API 就行了。因为数组尾部增删元素的时间复杂度都是O(1)，符合栈的要求。因为数组头部增删元素的时间复杂度都是O(n)，不符合要求

### 队列

环形数组 中实现的 CycleArray 类，用数组作为底层数据结构实现队列。直接复用 CycleArray，就可以实现标准队列了。当然，一些编程语言也有内置的环形数组实现

## 单调栈算法模版

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」等

把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的下一个更大元素呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案

### 模板

- for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了

- 这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n2)，但是实际上这个算法的复杂度只有O(n)。分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度

```go
func calculateGreaterElement(nums []int) []int {
    n := len(nums)
    // 存放答案的数组
    res := make([]int, n)
    s := make([]int, 0)
    // 倒着往栈里放
    for i := n - 1; i >= 0; i-- {
        // 判定个子高矮
        for len(s) != 0 && s[len(s) - 1] <= nums[i] {
            // 矮个起开，反正也被挡着了
            s = s[:len(s)-1]
        }
        // nums[i] 身后的更大元素
        if len(s) == 0 {
            res[i] = -1
        } else {
            res[i] = s[len(s) - 1]
        }
        s = append(s, nums[i])
    }
    return res
}
```

### 处理环形数组

对于这种需求，常用套路就是将数组长度翻倍：最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果

## 单调队列

就是一个「队列」，只是使用了一点巧妙的方法，使得队列中的元素全都是单调递增（或递减）的

主要是为了解决下面这个场景：给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值

如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的时间顺序，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系

「单调队列」这个数据结构主要用来辅助解决滑动窗口相关的问题

### 模版

```go
import (
	"container/list"
)

type MonotonicQueue struct {
    maxq list.List
}

func (mq *MonotonicQueue) push(n int) {
    // 将小于 n 的元素全部删除
    for mq.maxq.Len() > 0 && mq.maxq.Back().Value.(int) < n {
        mq.maxq.Remove(mq.maxq.Back())
    }
    // 然后将 n 加入尾部
    mq.maxq.PushBack(n)
}

func (mq *MonotonicQueue) max() int {
    return mq.maxq.Front().Value.(int)
}

func (mq *MonotonicQueue) pop(n int) {
    if n == mq.maxq.Front().Value.(int) {
        mq.maxq.Remove(mq.maxq.Front())
    }
}

func maxSlidingWindow(nums []int, k int) []int {
    window := MonotonicQueue{maxq: list.List{}}
    res := []int{}

    for i := 0; i < len(nums); i++ {
        if i < k-1 {
            // 先填满窗口的前 k - 1
            window.push(nums[i])
        } else {
            // 窗口向前滑动，加入新数字
            window.push(nums[i])
            // 记录当前窗口的最大值
            res = append(res, window.max())
            // 移出旧数字
            window.pop(nums[i-k+1])
        }
    }
    return res
}
```
