# 二叉树

## 基础

1. 每个节点下方直接相连的节点称为子节点，上方直接相连的节点称为父节点
1. 以子节点为根的树称为子树
1. 我们称最上方那个没有父节点的节点为根节点，称最下层没有子节点的节点为叶子节点
1. 我们称从根节点到最下方叶子节点经过的节点个数为二叉树的最大深度/高度

### 满二叉树

满二叉树就是每一层节点都是满的，整棵树像一个正三角形：满二叉树有个优势，就是它的节点个数很好算。假设深度为 h，那么总节点数就是 2^h - 1，等比数列求和

### 完全二叉树

完全二叉树是指，二叉树的每一层的节点都紧凑靠左排列，且除了最后一层，其他每层都必须是满的
由于它的节点紧凑排列，如果从左到右从上到下对它的每个节点编号，那么父子节点的索引存在明显的规律
完全二叉树可以用数组来存储，不需要真的构建链式节点
完全二叉树的左右子树中，至少有一棵是满二叉树

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251126130344719.jpeg)

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251126130721950.png)

### 二叉搜索树（Binary Search Tree）

对于树中的每个节点，其左子树的每个节点的值都要小于这个节点的值，右子树的每个节点的值都要大于这个节点的值。你可以简单记为「左小右大」
BST 是非常常用的数据结构。因为左小右大的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在

### 高度平衡二叉树（Height-Balanced Binary Tree）

它的「每个节点」的左右子树的高度差不超过 1。要注意是每个节点，而不仅仅是根节点
假设高度平衡二叉树中共有 N 个节点，那么高度平衡二叉树的高度是O(logN)。如果能保证树的高度为
O(logN)，那么这些数据结构的增删查改效率就会很高；反之，如果树很不平衡，那么这棵树其实就等同于单链表，在树中进行增删查改的效率就会大幅降低

### 自平衡二叉树（Self-Balanced Binary Tree）

如果我们可以在增删二叉树节点时对树的结构进行一些调整，那么就可以让树的高度始终是平衡的，这就是自平衡二叉树
自平衡的二叉树有很多种实现方式，最经典的就是红黑树，一种自平衡的二叉搜索树。保持树的平衡性，最关键的就是「旋转」操作

## 遍历

二叉树只有递归遍历和层序遍历这两种，再无其他。递归遍历可以衍生出 DFS 算法，层序遍历可以衍生出 BFS 算法

递归遍历二叉树节点的顺序是固定的，但是有三个关键位置，在不同位置插入代码，会产生不同的效果

层序遍历二叉树节点的顺序也是固定的，但是有三种不同的写法，对应不同的场景

### DFS

```go
// 基本的二叉树节点
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// 二叉树的递归遍历框架
func traverse(root *TreeNode) {
    if root == nil {
        return
    }
    // 前序位置
    traverse(root.Left)
    // 中序位置
    traverse(root.Right)
    // 后序位置
}
```

递归遍历的顺序，即 traverse 函数访问节点的顺序确实是固定的。二叉搜索树（BST）的中序遍历结果是有序的，这是 BST 的一个重要性质

适用场景：

- 所有路径：就以二叉树为例，如果要用 BFS 算法来寻找所有路径（根节点到每个叶子节点都是一条路径），队列里面就不能只放节点了，而需要使用二叉树层序遍历的第三种写法，新建一个 State 类，把当前节点以及到达当前节点的路径都存进去，这样才能正确维护每个节点的路径，最终计算出所有路径；而使用 DFS 算法就简单了，它本就是一条树枝一条树枝从左往右遍历的，每条树枝就是一条路径，递归遍历到叶子节点的时候递归路径就是一条树枝，所以 DFS 算法天然适合寻找所有路径

### BFS

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251126121402135.jpeg)

```go
type State struct {
    node  *TreeNode
    depth int
}

func levelOrderTraverse(root *TreeNode) {
    if root == nil {
        return
    }
    q := []State{{root, 1}}

    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        // 访问 cur 节点，同时知道它的路径权重和
        fmt.Printf("depth = %d, val = %d\n", cur.depth, cur.node.Val)

        // 把 cur 的左右子节点加入队列
        if cur.node.Left != nil {
            q = append(q, State{cur.node.Left, cur.depth + 1})
        }
        if cur.node.Right != nil {
            q = append(q, State{cur.node.Right, cur.depth + 1})
        }
    }
}
```

适用场景：

- 最短路径（LC111）：由于 BFS 逐层遍历的逻辑，第一次遇到目标节点时，所经过的路径就是最短路径，算法可能并不需要遍历完所有节点就能提前结束。DFS 遍历当然也可以用来寻找最短路径，但必须遍历完所有节点才能得到最短路径

## 算法核心

二叉树解题的思维模式分两类：

1. 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式

1. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式

无论使用哪种思维模式，你都需要思考：如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作

二叉树这种结构无非就是二叉链表，它没办法简单改写成 for 循环的迭代形式，所以我们遍历二叉树一般都使用递归形式。所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

![](https://raw.githubusercontent.com/UlricYang/FigureBed/main/img/20251126121125043.jpeg)

前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：

- 前序位置的代码在刚刚进入一个二叉树节点的时候执行；

- 后序位置的代码在将要离开一个二叉树节点的时候执行；

- 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行

注意：前中后序「位置」和大家常说的前中后序「遍历」有所区别（你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事）

二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作

## 解题思路

二叉树题目的递归解法可以分两类思路：

1. 遍历一遍二叉树得出答案，对应着 回溯算法核心框架
1. 通过分解问题计算出答案，对应着 动态规划核心框架

遇到一道二叉树的题目时的通用思考过程是：

1. 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现
1. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值
1. 无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做

### 后序位置的特殊之处

仔细观察，前中后序位置的代码，能力依次增强：

- 前序位置的代码只能从函数参数中获取父节点传递来的数据
- 中序位置的代码不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据
- 后序位置的代码最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据

一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了

遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。利用后序位置的题目，一般都使用「分解问题」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点 + 左右子树的子问题

### 以树的视角看 动规 / 回溯 / DFS

动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：

- 动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」
- 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」
- DFS 算法属于遍历的思路，它的关注点在单个「节点」

## 多叉树

```go
type Node struct {
    val      int
    children []*Node
}
```

```go
// N 叉树的遍历框架 - DFS
func traverseNary(root *Node) {
    if root == nil {
        return
    }
    // 前序位置
    for _, child := range root.Children {
        traverseNary(child)
    }
    // 后序位置
}
```

```go
// 多叉树的层序遍历 - BFS
// 每个节点自行维护 State 类，记录深度等信息
type State struct {
    node  *Node
    depth int
}

func levelOrderTraverse(root *Node) {
    if root == nil {
        return
    }
    q := []State{}
    // 记录当前遍历到的层数（根节点视为第 1 层）
    q = append(q, State{root, 1})

    for len(q) > 0 {
        state := q[0]
        q = q[1:]
        cur := state.node
        depth := state.depth
        // 访问 cur 节点，同时知道它所在的层数
        fmt.Printf("depth = %d, val = %d\n", depth, cur.Val)

        for _, child := range cur.Children {
            q = append(q, State{child, depth + 1})
        }
    }
}
```
