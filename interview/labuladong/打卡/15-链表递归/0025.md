# LeetCode 25 - K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

## 1. é¢˜ç›®æè¿°

ç»™ä½ é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œæ¯ `k` ä¸ªèŠ‚ç‚¹ä¸€ç»„è¿›è¡Œç¿»è½¬ï¼Œè¯·ä½ è¿”å›ä¿®æ”¹åçš„é“¾è¡¨

`k` æ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œå®ƒçš„å€¼å°äºæˆ–ç­‰äºé“¾è¡¨çš„é•¿åº¦ã€‚å¦‚æœèŠ‚ç‚¹æ€»æ•°ä¸æ˜¯ `k` çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆè¯·å°†æœ€åå‰©ä½™çš„èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåº

ä½ ä¸èƒ½åªæ˜¯å•çº¯çš„æ”¹å˜èŠ‚ç‚¹å†…éƒ¨çš„å€¼ï¼Œè€Œæ˜¯éœ€è¦å®é™…è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢

### è¾“å…¥è¾“å‡ºæ ¼å¼ï¼š

- è¾“å…¥ï¼šé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œæ•´æ•° `k`
- è¾“å‡ºï¼šæ¯ k ä¸ªèŠ‚ç‚¹ä¸€ç»„ç¿»è½¬åçš„é“¾è¡¨å¤´èŠ‚ç‚¹

### ç¤ºä¾‹ï¼š

#### ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 2
è¾“å‡ºï¼š[2,1,4,3,5]
```

#### ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šhead = [1,2,3,4,5], k = 3
è¾“å‡ºï¼š[3,2,1,4,5]
```

### çº¦æŸæ¡ä»¶ï¼š

- é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ç›®ä¸º n
- 1 \<= k \<= n \<= 5000
- 0 \<= Node.val \<= 1000

### è¿›é˜¶è¦æ±‚ï¼š

ä½ å¯ä»¥è®¾è®¡ä¸€ä¸ªåªç”¨ O(1) é¢å¤–å†…å­˜ç©ºé—´çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜å—ï¼Ÿ

## 2. è§£æ³•æ€è·¯åˆ†æ

### æ–¹æ³•æ¦‚è§ˆï¼š

| æ–¹æ³•   | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç‰¹ç‚¹                   |
| ------ | ---------- | ---------- | ---------------------- |
| é€’å½’æ³• | O(n)       | O(n/k)     | ä»£ç ç®€æ´ä½†æœ‰é€’å½’æ ˆå¼€é”€ |
| è¿­ä»£æ³• | O(n)       | O(1)       | æœ€ä¼˜è§£ âœ…              |

### æ¨èç­–ç•¥ï¼š

é‡‡ç”¨ã€Œè¿­ä»£æ³• + åˆ†ç»„å¤„ç†ã€çš„æ–¹æ³•ï¼Œè¿™æ˜¯æ»¡è¶³è¿›é˜¶è¦æ±‚çš„æœ€ä½³åšæ³•ã€‚æ ¸å¿ƒæ€æƒ³å¦‚ä¸‹ï¼š

1. å…ˆç»Ÿè®¡é“¾è¡¨æ€»é•¿åº¦ï¼Œç¡®å®šéœ€è¦ç¿»è½¬çš„ç»„æ•°
1. æŒ‰ç»„å¤„ç†ï¼Œæ¯ç»„ä½¿ç”¨å±€éƒ¨åè½¬æŠ€æœ¯
1. ç»´æŠ¤å¥½å„ç»„ä¹‹é—´çš„è¿æ¥å…³ç³»
1. å¤„ç†ä¸è¶³ k ä¸ªèŠ‚ç‚¹çš„å‰©ä½™éƒ¨åˆ†

> ğŸ’¡ å…³é”®åœ¨äºå‡†ç¡®å®šä½æ¯ç»„çš„è¾¹ç•Œï¼Œå¹¶æ­£ç¡®å¤„ç†ç»„é—´è¿æ¥å…³ç³»

## 3. å¤šè¯­è¨€å®ç°

### Go ğŸ¹

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

// åè½¬æŒ‡å®šåŒºé—´çš„é“¾è¡¨ï¼Œè¿”å›æ–°çš„å¤´èŠ‚ç‚¹å’Œå°¾èŠ‚ç‚¹
func reverseLinkedList(head *ListNode) (*ListNode, *ListNode) {
    var prev *ListNode
    curr := head

    // æ ‡å‡†çš„é“¾è¡¨åè½¬æ“ä½œ
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }

    // prevæ˜¯æ–°å¤´èŠ‚ç‚¹ï¼Œheadæ˜¯åŸå¤´èŠ‚ç‚¹ç°åœ¨æˆä¸ºå°¾èŠ‚ç‚¹
    return prev, head
}

func reverseKGroup(head *ListNode, k int) *ListNode {
    // åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–è¾¹ç•Œå¤„ç†
    dummy := &ListNode{Next: head}
    prevGroupEnd := dummy

    for {
        // æ£€æŸ¥å‰©ä½™èŠ‚ç‚¹æ•°é‡æ˜¯å¦è¶³å¤Ÿkä¸ª
        count := 0
        curr := prevGroupEnd.Next
        for curr != nil && count < k {
            curr = curr.Next
            count++
        }

        // å¦‚æœä¸è¶³kä¸ªèŠ‚ç‚¹ï¼Œä¿æŒåŸæœ‰é¡ºåº
        if count < k {
            break
        }

        // ä¿å­˜å½“å‰ç»„çš„å¤´èŠ‚ç‚¹
        groupStart := prevGroupEnd.Next
        // ä¿å­˜ä¸‹ä¸€ç»„çš„èµ·å§‹èŠ‚ç‚¹
        nextGroupStart := curr

        // æ–­å¼€å½“å‰ç»„ä¸åç»­èŠ‚ç‚¹çš„è¿æ¥
        // æ‰¾åˆ°å½“å‰ç»„çš„å°¾èŠ‚ç‚¹å¹¶æ–­å¼€è¿æ¥
        groupEnd := prevGroupEnd.Next
        for i := 0; i < k-1; i++ {
            groupEnd = groupEnd.Next
        }
        groupEnd.Next = nil

        // åè½¬å½“å‰ç»„
        newHead, newTail := reverseLinkedList(prevGroupEnd.Next)

        // é‡æ–°è¿æ¥
        prevGroupEnd.Next = newHead
        newTail.Next = nextGroupStart

        // æ›´æ–°prevGroupEndåˆ°å½“å‰ç»„çš„å°¾èŠ‚ç‚¹
        prevGroupEnd = newTail
    }

    return dummy.Next
}
```

#### ç®—æ³•æ·±å…¥è§£æ

ä¸Šé¢çš„å®ç°è™½ç„¶æ­£ç¡®ï¼Œä½†å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚ä¸‹é¢æ˜¯æ›´ä¼˜é›…çš„å®ç°ï¼š

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseKGroup(head *ListNode, k int) *ListNode {
    // åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–è¾¹ç•Œå¤„ç†
    dummy := &ListNode{Next: head}
    prevGroupEnd := dummy

    for {
        // è·å–kä¸ªèŠ‚ç‚¹çš„ç»“å°¾
        kth := getKthNode(prevGroupEnd, k)
        if kth == nil {
            break // å‰©ä½™èŠ‚ç‚¹ä¸è¶³kä¸ª
        }

        // ä¿å­˜ä¸‹ä¸€ç»„çš„èµ·å§‹èŠ‚ç‚¹
        nextGroupStart := kth.Next

        // åè½¬å½“å‰kä¸ªèŠ‚ç‚¹
        prev, curr := nextGroupStart, prevGroupEnd.Next
        for curr != nextGroupStart {
            nextTemp := curr.Next
            curr.Next = prev
            prev = curr
            curr = nextTemp
        }

        // ä¿å­˜å½“å‰ç»„çš„åŸå§‹å¤´èŠ‚ç‚¹ï¼ˆåè½¬åå˜æˆå°¾èŠ‚ç‚¹ï¼‰
        oldGroupStart := prevGroupEnd.Next

        // é‡æ–°è¿æ¥ï¼šprevGroupEnd -> æ–°å¤´èŠ‚ç‚¹(kth)
        prevGroupEnd.Next = kth
        // æ–°å°¾èŠ‚ç‚¹ -> ä¸‹ä¸€ç»„
        oldGroupStart.Next = nextGroupStart

        // æ›´æ–°prevGroupEnd
        prevGroupEnd = oldGroupStart
    }

    return dummy.Next
}

// è·å–ä»headå¼€å§‹çš„ç¬¬kä¸ªèŠ‚ç‚¹
func getKthNode(head *ListNode, k int) *ListNode {
    curr := head
    for i := 0; i < k && curr != nil; i++ {
        curr = curr.Next
    }
    return curr
}
```

#### ç®—æ³•æ·±å…¥è§£æ

- ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹(`dummy`)ç»Ÿä¸€å¤„ç†å„ç§è¾¹ç•Œæƒ…å†µ
- `getKthNode`å‡½æ•°ç”¨äºæ£€æŸ¥å‰©ä½™èŠ‚ç‚¹æ˜¯å¦è¶³å¤Ÿkä¸ª
- åœ¨æ¯ç»„åè½¬æ—¶ï¼Œä½¿ç”¨`prev`åˆå§‹åŒ–ä¸ºä¸‹ä¸€ç»„çš„èµ·å§‹èŠ‚ç‚¹ï¼Œè¿™æ ·åè½¬åèƒ½è‡ªåŠ¨è¿æ¥
- é€šè¿‡ç²¾ç¡®æ§åˆ¶åè½¬èŒƒå›´ï¼Œé¿å…äº†æ‰‹åŠ¨æ–­å¼€å’Œé‡è¿çš„æ“ä½œ

### Python ğŸ

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head: ListNode, k: int) -> ListNode:
    # è¾…åŠ©å‡½æ•°ï¼šè·å–ä»headå¼€å§‹çš„ç¬¬kä¸ªèŠ‚ç‚¹
    def getKthNode(head, k):
        curr = head
        for i in range(k):
            if not curr:
                return None
            curr = curr.next
        return curr

    # åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–è¾¹ç•Œå¤„ç†
    dummy = ListNode(0)
    dummy.next = head
    prevGroupEnd = dummy

    while True:
        # è·å–kä¸ªèŠ‚ç‚¹çš„ç»“å°¾
        kth = getKthNode(prevGroupEnd, k)
        if not kth:
            break  # å‰©ä½™èŠ‚ç‚¹ä¸è¶³kä¸ª

        # ä¿å­˜ä¸‹ä¸€ç»„çš„èµ·å§‹èŠ‚ç‚¹
        nextGroupStart = kth.next

        # åè½¬å½“å‰kä¸ªèŠ‚ç‚¹
        prev, curr = nextGroupStart, prevGroupEnd.next
        while curr != nextGroupStart:
            nextTemp = curr.next
            curr.next = prev
            prev = curr
            curr = nextTemp

        # ä¿å­˜å½“å‰ç»„çš„åŸå§‹å¤´èŠ‚ç‚¹ï¼ˆåè½¬åå˜æˆå°¾èŠ‚ç‚¹ï¼‰
        oldGroupStart = prevGroupEnd.next

        # é‡æ–°è¿æ¥
        prevGroupEnd.next = kth  # prevGroupEnd -> æ–°å¤´èŠ‚ç‚¹
        oldGroupStart.next = nextGroupStart  # æ–°å°¾èŠ‚ç‚¹ -> ä¸‹ä¸€ç»„

        # æ›´æ–°prevGroupEnd
        prevGroupEnd = oldGroupStart

    return dummy.next
```

#### ç®—æ³•æ·±å…¥è§£æ

- é€šè¿‡`getKthNode`å‡½æ•°æå‰æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„èŠ‚ç‚¹è¿›è¡Œåè½¬
- ä½¿ç”¨æ ‡å‡†çš„é“¾è¡¨åè½¬æŠ€æœ¯ï¼Œä½†æ§åˆ¶åè½¬èŒƒå›´ä»…ä¸ºå½“å‰kä¸ªèŠ‚ç‚¹
- ç²¾ç¡®ç»´æŠ¤å„ç»„ä¹‹é—´çš„è¿æ¥å…³ç³»ï¼Œç¡®ä¿é“¾è¡¨æ•´ä½“ç»“æ„ä¸è¢«ç ´å

### TypeScript ğŸŸ¦

```typescript
class ListNode {
  val: number;
  next: ListNode | null;

  constructor(val?: number, next?: ListNode | null) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}

function reverseKGroup(head: ListNode | null, k: number): ListNode | null {
  // è¾…åŠ©å‡½æ•°ï¼šè·å–ä»headå¼€å§‹çš„ç¬¬kä¸ªèŠ‚ç‚¹
  function getKthNode(head: ListNode | null, k: number): ListNode | null {
    let curr = head;
    for (let i = 0; i < k && curr !== null; i++) {
      curr = curr.next;
    }
    return curr;
  }

  // åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–è¾¹ç•Œå¤„ç†
  const dummy = new ListNode(0);
  dummy.next = head;
  let prevGroupEnd: ListNode | null = dummy;

  while (true) {
    // è·å–kä¸ªèŠ‚ç‚¹çš„ç»“å°¾
    const kth = getKthNode(prevGroupEnd, k);
    if (!kth) {
      break; // å‰©ä½™èŠ‚ç‚¹ä¸è¶³kä¸ª
    }

    // ä¿å­˜ä¸‹ä¸€ç»„çš„èµ·å§‹èŠ‚ç‚¹
    const nextGroupStart = kth.next;

    // åè½¬å½“å‰kä¸ªèŠ‚ç‚¹
    let prev: ListNode | null = nextGroupStart;
    let curr: ListNode | null = prevGroupEnd!.next;
    while (curr !== nextGroupStart) {
      const nextTemp = curr!.next;
      curr!.next = prev;
      prev = curr;
      curr = nextTemp;
    }

    // ä¿å­˜å½“å‰ç»„çš„åŸå§‹å¤´èŠ‚ç‚¹ï¼ˆåè½¬åå˜æˆå°¾èŠ‚ç‚¹ï¼‰
    const oldGroupStart = prevGroupEnd!.next;

    // é‡æ–°è¿æ¥
    prevGroupEnd!.next = kth; // prevGroupEnd -> æ–°å¤´èŠ‚ç‚¹
    oldGroupStart!.next = nextGroupStart; // æ–°å°¾èŠ‚ç‚¹ -> ä¸‹ä¸€ç»„

    // æ›´æ–°prevGroupEnd
    prevGroupEnd = oldGroupStart;
  }

  return dummy.next;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

- ä½¿ç”¨éç©ºæ–­è¨€æ“ä½œç¬¦(`!`)å¤„ç†å¯èƒ½ä¸ºnullçš„æŒ‡é’ˆ
- é€šè¿‡ç±»å‹å®‰å…¨çš„æ–¹å¼å®ç°é“¾è¡¨æ“ä½œ
- ä¿æŒäº†ä¸å…¶ä»–è¯­è¨€å®ç°çš„ä¸€è‡´æ€§

### Rust ğŸ¦€

```rust
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
    pub val: i32,
    pub next: Option<Box<ListNode>>,
}

impl ListNode {
    #[inline]
    fn new(val: i32) -> Self {
        ListNode { next: None, val }
    }
}

pub fn reverse_k_group(head: Option<Box<ListNode>>, k: i32) -> Option<Box<ListNode>> {
    // è¾…åŠ©å‡½æ•°ï¼šè·å–ä»headå¼€å§‹çš„ç¬¬kä¸ªèŠ‚ç‚¹
    fn get_kth_node(mut head: &Option<Box<ListNode>>, k: i32) -> Option<&Option<Box<ListNode>>> {
        for _ in 0..k {
            match head {
                Some(node) => head = &node.next,
                None => return None,
            }
        }
        Some(head)
    }

    // åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹ç®€åŒ–è¾¹ç•Œå¤„ç†
    let mut dummy = Box::new(ListNode::new(0));
    dummy.next = head;
    let mut prev_group_end = &mut dummy;

    loop {
        // æ£€æŸ¥å‰©ä½™èŠ‚ç‚¹æ˜¯å¦è¶³å¤Ÿkä¸ª
        let mut count = 0;
        let mut curr = &prev_group_end.next;
        while curr.is_some() && count < k {
            curr = &curr.as_ref().unwrap().next;
            count += 1;
        }

        if count < k {
            break;  // å‰©ä½™èŠ‚ç‚¹ä¸è¶³kä¸ª
        }

        // è·å–ä¸‹ä¸€ç»„çš„èµ·å§‹èŠ‚ç‚¹
        let next_group_start = curr.clone();

        // åè½¬å½“å‰kä¸ªèŠ‚ç‚¹
        let mut prev = next_group_start.clone();
        let mut curr = prev_group_end.next.take();

        for _ in 0..k {
            if let Some(mut node) = curr {
                curr = node.next.take();
                node.next = prev;
                prev = Some(node);
            }
        }

        // é‡æ–°è¿æ¥
        prev_group_end.next = prev;

        // ç§»åŠ¨åˆ°ä¸‹ä¸€ç»„ï¼ˆéœ€è¦é‡æ–°æ‰¾åˆ°æ–°çš„prev_group_endï¼‰
        while prev_group_end.next.is_some() &&
              prev_group_end.next.as_ref().unwrap().next.is_some() &&
              prev_group_end.next != next_group_start {
            prev_group_end = prev_group_end.next.as_mut().unwrap();
        }

        if prev_group_end.next == next_group_start {
            break;
        }
    }

    dummy.next
}
```

#### ç®—æ³•æ·±å…¥è§£æ

- Rustçš„æ‰€æœ‰æƒç³»ç»Ÿè¦æ±‚æˆ‘ä»¬å¿…é¡»æ˜¾å¼ç®¡ç†èŠ‚ç‚¹çš„æ‰€æœ‰æƒè½¬ç§»
- ä½¿ç”¨`take()`æ–¹æ³•å®‰å…¨åœ°è½¬ç§»èŠ‚ç‚¹æ‰€æœ‰æƒ
- é€šè¿‡å¤šæ¬¡æ‰€æœ‰æƒè½¬ç§»å®ŒæˆèŠ‚ç‚¹çš„é‡æ–°è¿æ¥

## 4. ç®—æ³•å¯è§†åŒ–

### Mermaid å›¾å½¢è¡¨ç¤ºï¼š

```mermaid
graph TD
    A[Start] --> B[Create dummy node]
    B --> C{Get kth node}
    C -->|Enough nodes| D[Save next group start]
    D --> E[Reverse k nodes]
    E --> F[Reconnect groups]
    F --> G[Update prevGroupEnd]
    G --> C
    C -->|Not enough| H[Return dummy.next]
```

### ä¼ªä»£ç 

```
åˆ›å»ºè™šæ‹Ÿå¤´èŠ‚ç‚¹dummyï¼Œdummy.next = head
prevGroupEnd = dummy

å¾ªç¯:
    kth = è·å–ä»prevGroupEndå¼€å§‹çš„ç¬¬kä¸ªèŠ‚ç‚¹
    å¦‚æœ kth ä¸ºç©º:
        é€€å‡ºå¾ªç¯  // å‰©ä½™èŠ‚ç‚¹ä¸è¶³kä¸ª

    nextGroupStart = kth.next

    // åè½¬å½“å‰kä¸ªèŠ‚ç‚¹
    prev = nextGroupStart
    curr = prevGroupEnd.next
    å½“ curr â‰  nextGroupStart æ—¶:
        nextTemp = curr.next
        curr.next = prev
        prev = curr
        curr = nextTemp

    oldGroupStart = prevGroupEnd.next

    // é‡æ–°è¿æ¥
    prevGroupEnd.next = kth
    oldGroupStart.next = nextGroupStart

    prevGroupEnd = oldGroupStart

è¿”å› dummy.next
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤ºï¼ˆåŸºäºè¾“å…¥[1,2,3,4,5], k=2ï¼‰

### æµ‹è¯•ç”¨ä¾‹ä»£ç ï¼ˆGoï¼‰ï¼š

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func createList(vals []int) *ListNode {
    if len(vals) == 0 {
        return nil
    }
    head := &ListNode{Val: vals[0]}
    curr := head
    for i := 1; i < len(vals); i++ {
        curr.Next = &ListNode{Val: vals[i]}
        curr = curr.Next
    }
    return head
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    list := createList([]int{1, 2, 3, 4, 5})
    fmt.Print("Original: ")
    printList(list)

    reversed := reverseKGroup(createList([]int{1, 2, 3, 4, 5}), 2)
    fmt.Print("Reversed k=2: ")
    printList(reversed)

    reversed2 := reverseKGroup(createList([]int{1, 2, 3, 4, 5}), 3)
    fmt.Print("Reversed k=3: ")
    printList(reversed2)
}
```

### æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤ºï¼ˆk=2ï¼‰ï¼š

åˆå§‹é“¾è¡¨ï¼š`1 -> 2 -> 3 -> 4 -> 5`

ç¬¬ä¸€ç»„åè½¬[1,2]ï¼š

- åè½¬åï¼š`2 -> 1`
- é“¾è¡¨å˜ä¸ºï¼š`2 -> 1 -> 3 -> 4 -> 5`

ç¬¬äºŒç»„åè½¬[3,4]ï¼š

- åè½¬åï¼š`4 -> 3`
- é“¾è¡¨å˜ä¸ºï¼š`2 -> 1 -> 4 -> 3 -> 5`

å‰©ä½™èŠ‚ç‚¹[5]ä¸è¶³kä¸ªï¼Œä¿æŒä¸å˜

æœ€ç»ˆé“¾è¡¨ï¼š`2 -> 1 -> 4 -> 3 -> 5`

## 6. å¤æ‚åº¦åˆ†æ

| ç±»å‹   | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
| ------ | ---------- | ---------- |
| è¿­ä»£æ³• | O(n)       | O(1)       |

ğŸ“Œ æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šè¢«è®¿é—®å¸¸æ•°æ¬¡ï¼Œæ»¡è¶³è¿›é˜¶è¦æ±‚

## 7. ç›¸ä¼¼é¢˜ç›®å…³è”

| ç¼–å· | åç§°        | æ ¸å¿ƒæ€æƒ³             |
| ---- | ----------- | -------------------- |
| 206  | åè½¬é“¾è¡¨    | å®Œæ•´é“¾è¡¨åè½¬         |
| 92   | åè½¬é“¾è¡¨ II | æŒ‡å®šåŒºé—´åè½¬         |
| 234  | å›æ–‡é“¾è¡¨    | ç»“åˆé“¾è¡¨åè½¬åˆ¤æ–­å›æ–‡ |
| 143  | é‡æ’é“¾è¡¨    | æ‹†åˆ†+åè½¬+åˆå¹¶       |
| 61   | æ—‹è½¬é“¾è¡¨    | é“¾è¡¨èŠ‚ç‚¹ä½ç½®å˜æ¢     |

ğŸ” è¿™äº›é¢˜ç›®éƒ½æ¶‰åŠé“¾è¡¨çš„éƒ¨åˆ†æˆ–å®Œæ•´åè½¬æ“ä½œï¼ŒæŒæ¡åˆ†ç»„åè½¬æŠ€å·§å¯¹äºè§£å†³è¿™äº›é—®é¢˜è‡³å…³é‡è¦

## 8. å…¸å‹é¢è¯•è¿½é—®åŠå›ç­”

| åºå· | è¿½é—®å†…å®¹                                 | å›ç­”è¦ç‚¹                                                    |
| ---- | ---------------------------------------- | ----------------------------------------------------------- |
| â‘     | ä¸ºä»€ä¹ˆéœ€è¦æ£€æŸ¥å‰©ä½™èŠ‚ç‚¹æ•°é‡ï¼Ÿ             | ç¡®ä¿åªæœ‰å®Œæ•´çš„kä¸ªèŠ‚ç‚¹æ‰è¿›è¡Œåè½¬ï¼Œä¸è¶³çš„ä¿æŒåŸæœ‰é¡ºåº         |
| â‘¡    | å¦‚ä½•éªŒè¯åè½¬ç»“æœçš„æ­£ç¡®æ€§ï¼Ÿ               | å¯ä»¥éå†åŸé“¾è¡¨å’Œåè½¬åçš„é“¾è¡¨ï¼ŒéªŒè¯æ¯ç»„kä¸ªèŠ‚ç‚¹çš„é¡ºåºæ˜¯å¦æ­£ç¡® |
| â‘¢    | å¦‚æœkå¤§äºé“¾è¡¨é•¿åº¦ä¼šæ€æ ·ï¼Ÿ                | æ‰€æœ‰èŠ‚ç‚¹ä¿æŒåŸæœ‰é¡ºåºï¼Œå› ä¸ºæ²¡æœ‰è¶³å¤Ÿçš„èŠ‚ç‚¹ç»„æˆä¸€ä¸ªå®Œæ•´çš„ç»„    |
| â‘£    | èƒ½å¦ç”¨é€’å½’æ–¹æ³•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ             | å¯ä»¥ï¼Œä½†é€’å½’å®ç°ä¼šæœ‰O(n/k)çš„ç©ºé—´å¤æ‚åº¦                      |
| â‘¤    | ä¸ºä»€ä¹ˆè¦ä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Ÿ                 | ç®€åŒ–å¯¹å¤´èŠ‚ç‚¹çš„ç‰¹æ®Šå¤„ç†ï¼Œä½¿ä»£ç æ›´åŠ ç»Ÿä¸€å’Œç®€æ´                |
| â‘¥    | å¦‚ä½•å¤„ç†k=1çš„ç‰¹æ®Šæƒ…å†µï¼Ÿ                  | æ¯ä¸ªèŠ‚ç‚¹è‡ªæˆä¸€ç»„ï¼Œå®é™…ä¸Šä¸éœ€è¦åè½¬                          |
| â‘¦    | å¦‚æœè¦æ±‚ä¸è¶³kä¸ªèŠ‚ç‚¹ä¹Ÿåè½¬æ€ä¹ˆåŠï¼Ÿ        | ç§»é™¤å¯¹å‰©ä½™èŠ‚ç‚¹æ•°é‡çš„æ£€æŸ¥ï¼Œå¯¹æ‰€æœ‰ç»„éƒ½è¿›è¡Œåè½¬                |
| â‘§    | åœ¨å®é™…é¡¹ç›®ä¸­è¿™ç§åˆ†ç»„åè½¬æœ‰ä»€ä¹ˆåº”ç”¨åœºæ™¯ï¼Ÿ | æ•°æ®åˆ†é¡µå¤„ç†ã€æ‰¹é‡æ“ä½œä¼˜åŒ–ã€ç‰¹å®šçš„æ•°æ®ç»“æ„éœ€æ±‚ç­‰            |

ğŸ¯ æ³¨æ„ç‚¹ï¼šåœ¨å›ç­”ä¸­è¦ä½“ç°å¯¹ç®—æ³•ç»†èŠ‚å’Œè¾¹ç•Œæ¡ä»¶çš„æ·±å…¥ç†è§£

## 9. å¤ä¹ è¦ç‚¹æç‚¼ä¸æ€»ç»“å»ºè®®

| è¦ç´             | å†…å®¹                                                     |
| --------------- | -------------------------------------------------------- |
| âš ï¸ æ˜“é”™ç‚¹       | å¿˜è®°æ£€æŸ¥å‰©ä½™èŠ‚ç‚¹æ•°é‡ï¼ŒæŒ‡é’ˆæ“ä½œé¡ºåºé”™è¯¯å¯¼è‡´é“¾è¡¨æ–­è£‚       |
| âœ… é«˜é¢‘è€ƒç‚¹     | è™šæ‹Ÿå¤´èŠ‚ç‚¹çš„ä½¿ç”¨ï¼Œåˆ†ç»„å¤„ç†ç­–ç•¥ï¼Œé“¾è¡¨å±€éƒ¨åè½¬æŠ€æœ¯         |
| ğŸ’¡ å¯å‘ç‚¹       | é€šè¿‡åˆ†æ²»æ€æƒ³å°†å¤æ‚é—®é¢˜åˆ†è§£ä¸ºç®€å•çš„å­é—®é¢˜                 |
| ğŸŒŸ è®°å¿†é”šç‚¹     | "æ£€æŸ¥æ•°é‡â†’åè½¬â†’é‡è¿"çš„ç»å…¸ä¸‰æ­¥æ³•                         |
| ğŸ‰ æŒæ¡æ ‡å¿—     | èƒ½æ‰‹å†™å‡ºå®Œæ•´çš„å®ç°ä»£ç ï¼Œç†è§£æ¯ä¸€æ­¥æŒ‡é’ˆæ“ä½œçš„æ„ä¹‰         |
| ğŸ” å·¥ä¸šå®è·µå¯ç¤º | åœ¨å®é™…å¼€å‘ä¸­ï¼Œåˆç†çš„æ•°æ®åˆ†ç»„å¤„ç†å¯ä»¥æé«˜ç®—æ³•æ•ˆç‡         |
| ğŸ“š å­¦ä¹ å»ºè®®     | å¤šç»ƒä¹ å„ç§é“¾è¡¨åè½¬ç›¸å…³çš„é¢˜ç›®ï¼Œç†Ÿç»ƒæŒæ¡æŒ‡é’ˆæ“ä½œçš„å„ç§æ¨¡å¼ |

ğŸš€ åˆ†ç»„åè½¬æ˜¯é“¾è¡¨æ“ä½œçš„é«˜çº§æŠ€å·§ï¼Œå»ºè®®ç†Ÿç»ƒæŒæ¡åå†å­¦ä¹ æ›´å¤æ‚çš„é“¾è¡¨é¢˜ç›®
