# LeetCode 234 - å›æ–‡é“¾è¡¨

## 1. é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`ï¼Œè¯·åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› `true`ï¼›å¦åˆ™ï¼Œè¿”å› `false`

### è¾“å…¥è¾“å‡ºæ ¼å¼ï¼š

- è¾“å…¥ï¼šé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head`
- è¾“å‡ºï¼šå¸ƒå°”å€¼è¡¨ç¤ºæ˜¯å¦æ˜¯å›æ–‡é“¾è¡¨

### ç¤ºä¾‹ï¼š

#### ç¤ºä¾‹ 1ï¼š

```
è¾“å…¥ï¼šhead = [1,2,2,1]
è¾“å‡ºï¼štrue
```

#### ç¤ºä¾‹ 2ï¼š

```
è¾“å…¥ï¼šhead = [1,2]
è¾“å‡ºï¼šfalse
```

### çº¦æŸæ¡ä»¶ï¼š

- é“¾è¡¨ä¸­èŠ‚ç‚¹æ•°ç›®èŒƒå›´æ˜¯ `[1, 10^5]`
- `0 <= Node.val <= 9`

### è¿›é˜¶è¦æ±‚ï¼š

èƒ½å¦ç”¨ O(n) æ—¶é—´å¤æ‚åº¦å’Œ O(1) ç©ºé—´å¤æ‚åº¦è§£å†³æ­¤é¢˜ï¼Ÿ

## 2. è§£æ³•æ€è·¯åˆ†æ

### æ–¹æ³•æ¦‚è§ˆï¼š

| æ–¹æ³•                  | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | ç‰¹ç‚¹                    |
| --------------------- | ---------- | ---------- | ----------------------- |
| æš´åŠ›æ•°ç»„å­˜å‚¨          | O(n)       | O(n)       | æ˜“æ‡‚ä½†ä¸ç¬¦åˆè¿›é˜¶è¦æ±‚    |
| å¿«æ…¢æŒ‡é’ˆ+åè½¬ååŠé“¾è¡¨ | O(n)       | O(1)       | æœ€ä¼˜è§£ï¼Œæ»¡è¶³è¿›é˜¶è¦æ±‚ âœ… |

### æ¨èç­–ç•¥ï¼š

é‡‡ç”¨ã€Œå¿«æ…¢æŒ‡é’ˆ + åè½¬ååŠéƒ¨åˆ†é“¾è¡¨ã€çš„æ–¹å¼ï¼Œæ˜¯æ»¡è¶³è¿›é˜¶è¦æ±‚çš„æœ€ä½³åšæ³•ã€‚æ ¸å¿ƒæ€æƒ³å¦‚ä¸‹ï¼š

1. ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°é“¾è¡¨ä¸­ç‚¹ï¼›
1. å°†é“¾è¡¨ååŠéƒ¨åˆ†åè½¬ï¼›
1. åŒæ­¥æ¯”è¾ƒå‰åä¸¤éƒ¨åˆ†é“¾è¡¨çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼›
1. è‹¥å…¨éƒ¨åŒ¹é…ï¼Œåˆ™ä¸ºå›æ–‡é“¾è¡¨

> ğŸ’¡ ä¸ºä»€ä¹ˆè¦åè½¬ååŠéƒ¨åˆ†ï¼Ÿå› ä¸ºé“¾è¡¨åªèƒ½å‘å‰éå†ï¼Œæ— æ³•é€†åºè®¿é—®ã€‚å°†ååŠæ®µåè½¬åï¼Œå°±å¯ä»¥ç”¨ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»å‰å‘åæ‰«æå¯¹æ¯”äº†

## 3. å¤šè¯­è¨€å®ç°

### Go ğŸ¹

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func isPalindrome(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return true // ç©ºé“¾è¡¨æˆ–åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¿…ç„¶æ˜¯å›æ–‡é“¾è¡¨
    }

    slow, fast := head, head
    // å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    var prev *ListNode
    curr := slow
    // åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }

    firstHalf := head
    secondHalf := prev
    result := true

    // å¯¹æ¯”å‰åŠå’Œåè½¬åçš„ååŠ
    for result && secondHalf != nil {
        if firstHalf.Val != secondHalf.Val {
            result = false
        }
        firstHalf = firstHalf.Next
        secondHalf = secondHalf.Next
    }

    return result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

- `slow`, `fast`: åˆå§‹æŒ‡å‘å¤´èŠ‚ç‚¹ï¼Œç”¨äºå¯»æ‰¾é“¾è¡¨ä¸­ç‚¹
- å¾ªç¯ä¸­ï¼Œ`fast` æ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œ`slow` èµ°ä¸€æ­¥ï¼Œæœ€ç»ˆ `slow` æŒ‡å‘ä¸­ç‚¹
- æ¥ä¸‹æ¥é€šè¿‡è¿­ä»£æ–¹å¼å°† `slow` å¼€å§‹çš„é“¾è¡¨è¿›è¡ŒåŸåœ°åè½¬
- æœ€ç»ˆä½¿ç”¨ `firstHalf` å’Œ `secondHalf` æŒ‡é’ˆåŒæ­¥æ‰«æå¹¶é€ä¸€æ¯”è¾ƒèŠ‚ç‚¹å€¼

### Python ğŸ

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def isPalindrome(head: ListNode) -> bool:
    if not head or not head.next:
        return True

    slow = fast = head
    # å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    prev = None
    curr = slow
    # åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp

    first_half = head
    second_half = prev
    result = True

    # å¯¹æ¯”å›æ–‡ç»“æ„
    while result and second_half:
        if first_half.val != second_half.val:
            result = False
        first_half = first_half.next
        second_half = second_half.next

    return result
```

#### ç®—æ³•æ·±å…¥è§£æ

- ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆå®šä½ä¸­ç‚¹ï¼Œåˆ©ç”¨é“¾è¡¨ç»“æ„å¤©ç„¶æ”¯æŒå•å‘éå†çš„ä¼˜åŠ¿
- é€šè¿‡å¯¹ååŠé“¾è¡¨è¿›è¡Œå°±åœ°åè½¬æ“ä½œï¼ŒèŠ‚çœäº†é¢å¤–ç©ºé—´å¼€é”€
- æœ€åé€šè¿‡åŒæŒ‡é’ˆä»å‰åˆ°ååŒæ­¥æ‰«ææ¥åˆ¤æ–­æ˜¯å¦æ„æˆå›æ–‡åºåˆ—

### TypeScript ğŸŸ¦

```typescript
class ListNode {
  val: number;
  next: ListNode | null;

  constructor(val?: number, next?: ListNode | null) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}

function isPalindrome(head: ListNode | null): boolean {
  if (!head || !head.next) return true;

  let slow: ListNode | null = head;
  let fast: ListNode | null = head;

  // å¿«æ…¢æŒ‡é’ˆæ‰¾åˆ°ä¸­ç‚¹
  while (fast !== null && fast.next !== null) {
    slow = slow!.next;
    fast = fast.next.next;
  }

  let prev: ListNode | null = null;
  let current: ListNode | null = slow;

  // åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
  while (current !== null) {
    const nextTemp = current.next;
    current.next = prev;
    prev = current;
    current = nextTemp;
  }

  let firstHalf: ListNode | null = head;
  let secondHalf: ListNode | null = prev;
  let result = true;

  // æ¯”è¾ƒå‰åä¸¤æ®µé“¾è¡¨
  while (result && secondHalf !== null) {
    if (firstHalf!.val !== secondHalf.val) {
      result = false;
    }
    firstHalf = firstHalf!.next;
    secondHalf = secondHalf.next;
  }

  return result;
}
```

#### ç®—æ³•æ·±å…¥è§£æ

- ä¸ Go å®ç°ç±»ä¼¼ï¼Œå…ˆé€šè¿‡å¿«æ…¢æŒ‡é’ˆç¡®å®šä¸­é—´èŠ‚ç‚¹
- å†é€šè¿‡é“¾è¡¨åŸåœ°åè½¬æŠ€å·§ï¼Œå°†ååŠéƒ¨åˆ†ç¿»è½¬ä»¥ä¾¿å¯¹ç§°æ¯”è¾ƒ
- ä½¿ç”¨ç±»å‹å®‰å…¨çš„ç©ºæ£€æŸ¥æœºåˆ¶ç¡®ä¿ä¸ä¼šè§¦å‘è¿è¡Œæ—¶é”™è¯¯

### Rust ğŸ¦€

```rust
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct ListNode {
    pub val: i32,
    pub next: Option<Box<ListNode>>,
}

impl ListNode {
    #[inline]
    fn new(val: i32) -> Self {
        ListNode { next: None, val }
    }
}

pub fn is_palindrome(head: Option<Box<ListNode>>) -> bool {
    let mut head = head;
    if head.is_none() || head.as_ref().unwrap().next.is_none() {
        return true;
    }

    let mut slow = &head;
    let mut fast = &head;

    // å¿«æ…¢æŒ‡é’ˆæŸ¥æ‰¾ä¸­ç‚¹
    while fast.is_some() && fast.as_ref().unwrap().next.is_some() {
        slow = &slow.as_ref().unwrap().next;
        fast = &fast.as_ref().unwrap().next.as_ref().unwrap().next;
    }

    let mut prev: Option<Box<ListNode>> = None;
    let mut current = slow.clone();

    // åè½¬ååŠéƒ¨åˆ†é“¾è¡¨
    while let Some(mut node) = current {
        current = node.next.take();
        node.next = prev;
        prev = Some(node);
    }

    let mut first_half = &head;
    let mut second_half = &prev;
    let mut result = true;

    // æ¯”è¾ƒå‰åŠä¸åè½¬åçš„ååŠ
    while result && second_half.is_some() {
        if first_half.as_ref().unwrap().val != second_half.as_ref().unwrap().val {
            result = false;
        }
        first_half = &first_half.as_ref().unwrap().next;
        second_half = &second_half.as_ref().unwrap().next;
    }

    result
}
```

#### ç®—æ³•æ·±å…¥è§£æ

- Rust çš„æ‰€æœ‰æƒç³»ç»Ÿè¦æ±‚æˆ‘ä»¬å¿…é¡»æ˜¾å¼ç®¡ç†èµ„æºï¼Œåœ¨é“¾è¡¨åè½¬è¿‡ç¨‹ä¸­å°¤ä¸ºå…³é”®
- ä½¿ç”¨ `.take()` å®‰å…¨å–å‡ºå½“å‰èŠ‚ç‚¹çš„ `next` å¼•ç”¨ï¼Œé˜²æ­¢å€Ÿç”¨å†²çª
- ä¿è¯é“¾è¡¨è¢«æ­£ç¡®æ‹†åˆ†ä¸ºå‰åä¸¤æ®µï¼Œå¹¶å„è‡ªæ‹¥æœ‰å®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸæ§åˆ¶

## 4. ç®—æ³•å¯è§†åŒ–

### Mermaid å›¾å½¢è¡¨ç¤ºï¼š

```mermaid
graph TD
    A[Start] --> B{Head exists?}
    B -- Yes --> C{Only one node?}
    C -- Yes --> D[Return true]
    C -- No --> E[Fast & Slow Pointers to find mid]
    E --> F[Reverse second half]
    F --> G[Compare both halves]
    G --> H{Values equal?}
    H -- All equal --> I[Return true]
    H -- Any mismatch --> J[Return false]
```

### ä¼ªä»£ç 

```
åˆå§‹åŒ– slow = head, fast = head
while fast â‰  nil å¹¶ä¸” fast.next â‰  nil:
    slow = slow.next
    fast = fast.next.next

åè½¬ slow å¼€å§‹çš„é“¾è¡¨ï¼Œå¾—åˆ° prev
åˆå§‹åŒ– first_half = head, second_half = prev
while second_half â‰  nil:
    å¦‚æœ first_half.value â‰  second_half.value:
        è¿”å› false
    first_half = first_half.next
    second_half = second_half.next
è¿”å› true
```

## 5. æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤ºï¼ˆåŸºäºä¸‰ç§è¾“å…¥ï¼‰

ä»¥ä¸‹æ˜¯å¯¹ä¸‰ç§å…¸å‹è¾“å…¥è¿›è¡Œçš„æ‰§è¡Œè½¨è¿¹æ¨¡æ‹Ÿ

| è¾“å…¥        | ç»“æœ |
| ----------- | ---- |
| `[1,2,2,1]` | âœ…   |
| `[1,2]`     | âŒ   |
| `[1]`       | âœ…   |

### æµ‹è¯•ç”¨ä¾‹ä»£ç ï¼ˆGoï¼‰ï¼š

```go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func createList(vals []int) *ListNode {
	dummy := &ListNode{}
	curr := dummy
	for _, v := range vals {
		curr.Next = &ListNode{Val: v}
		curr = curr.Next
	}
	return dummy.Next
}

func printList(head *ListNode) {
	for head != nil {
		fmt.Printf("%d ", head.Val)
		head = head.Next
	}
	fmt.Println()
}

func main() {
	list1 := createList([]int{1, 2, 2, 1})
	list2 := createList([]int{1, 2})
	list3 := createList([]int{1})

	fmt.Println(isPalindrome(list1)) // true
	fmt.Println(isPalindrome(list2)) // false
	fmt.Println(isPalindrome(list3)) // true
}
```

### æ‰§è¡Œè¿‡ç¨‹æ¼”ç¤ºï¼ˆlist1=[1,2,2,1]ï¼‰ï¼š

| æ­¥éª¤ | slow | fast | first_half | second_half | å½“å‰å€¼æ¯”è¾ƒ | æ˜¯å¦ç»§ç»­ |
| ---- | ---- | ---- | ---------- | ----------- | ---------- | -------- |
| 1    | 1    | 1    | 1          | 2           | 1 vs 2     | false âŒ |
| 2    | 2    | 2    | 2          | 1           | 2 vs 1     | false âŒ |
| 3    | 2    | null | 2          | null        | -          | ç»ˆæ­¢     |

æœ€ç»ˆè¾“å‡ºï¼š`true`

## 6. å¤æ‚åº¦åˆ†æ

| ç±»å‹            | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ |
| --------------- | ---------- | ---------- |
| å¿«æ…¢æŒ‡é’ˆ+åè½¬æ³• | O(n)       | O(1)       |
| æ•°ç»„æ³•          | O(n)       | O(n)       |

ğŸ“Œ ä¼˜åŠ¿åœ¨äºåšåˆ°äº†çœŸæ­£çš„å¸¸æ•°ç©ºé—´å ç”¨ï¼Œç¬¦åˆé¢˜ç›®è¿›é˜¶è¦æ±‚

## 7. ç›¸ä¼¼é¢˜ç›®å…³è”

| ç¼–å· | åç§°                    | æ ¸å¿ƒæ€æƒ³           |
| ---- | ----------------------- | ------------------ |
| 141  | ç¯å½¢é“¾è¡¨                | å¿«æ…¢æŒ‡é’ˆæ£€æµ‹ç¯     |
| 206  | åè½¬é“¾è¡¨                | åŸåœ°é“¾è¡¨åè½¬       |
| 143  | é‡æ’é“¾è¡¨                | æ‹†åˆ† + åè½¬ + æ’å…¥ |
| 876  | é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹          | å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹     |
| 19   | åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬ N ä¸ªèŠ‚ç‚¹ | åŒæŒ‡é’ˆæŠ€å·§å®šä½ä½ç½® |

ğŸ” ä¸Šè¿°é¢˜ç›®å‡ä½“ç°äº†é“¾è¡¨å¸¸ç”¨æŠ€å·§ç»„åˆ â€”â€” å¿«æ…¢æŒ‡é’ˆã€åŸåœ°ä¿®æ”¹ã€åŒæŒ‡é’ˆæ‰«æç­‰ï¼ŒæŒæ¡è¿™äº›æ¨¡å¼å³å¯è½»æ¾åº”å¯¹å¤§å¤šæ•°é“¾è¡¨é¢è¯•å˜ä½“

## 8. å…¸å‹é¢è¯•è¿½é—®åŠå›ç­”

| åºå· | è¿½é—®å†…å®¹                                     | å›ç­”è¦ç‚¹                                                                                   |
| ---- | -------------------------------------------- | ------------------------------------------------------------------------------------------ |
| â‘     | å¦‚ä½•åœ¨ä¸æ”¹å˜åŸå§‹é“¾è¡¨çš„å‰æä¸‹åˆ¤æ–­æ˜¯å¦å›æ–‡ï¼Ÿ   | å¯ä»¥å¤åˆ¶ä¸€ä»½é“¾è¡¨å†åšåè½¬æ“ä½œï¼Œæˆ–è€…ä½¿ç”¨é€’å½’æ–¹æ³•è‡ªåº•å‘ä¸Šæ¯”å¯¹ã€‚                               |
| â‘¡    | å¦‚æœè¦æ”¯æŒå¤šçº¿ç¨‹ç¯å¢ƒä¸‹å¹¶å‘è®¿é—®æ€ä¹ˆåŠï¼Ÿ       | éœ€è¦ç”¨é”ä¿æŠ¤é“¾è¡¨è¯»å†™æ“ä½œï¼ŒåŒæ—¶å»ºè®®é‡‡ç”¨ä¸å¯å˜å‰¯æœ¬ä»£æ›¿ç›´æ¥ä¿®æ”¹ã€‚                             |
| â‘¢    | ä¸ºä»€ä¹ˆä¸èƒ½ç”¨å“ˆå¸Œè¡¨æ¥ä¼˜åŒ–è¿™ä¸ªç®—æ³•ï¼Ÿ           | å› ä¸ºéœ€è¦å®Œæ•´ä¿å­˜æ‰€æœ‰å…ƒç´ é¡ºåºæ‰èƒ½å®Œæˆæ¯”è¾ƒï¼Œåè€Œå¢åŠ ç©ºé—´è´Ÿæ‹…ã€‚                               |
| â‘£    | å¦‚ä½•é¿å…ä¿®æ”¹åŸå§‹é“¾è¡¨ï¼Ÿ                       | åœ¨å®é™…åº”ç”¨ä¸­å¯åœ¨è¿”å›å‰é‡æ–°åè½¬å›æ¥ï¼Œä»¥æ¢å¤åŸçŠ¶ã€‚                                           |
| â‘¤    | é™¤äº†åè½¬é“¾è¡¨è¿˜æœ‰ä»€ä¹ˆæ–¹æ³•å¯ä»¥å®ç° O(1) ç©ºé—´ï¼Ÿ | é€’å½’ä¹Ÿå¯ä»¥è¾¾åˆ°ç›®æ ‡ï¼Œä½†ç”±äºå‡½æ•°è°ƒç”¨æ ˆä»ç„¶å ç”¨äº† O(n) ç©ºé—´ï¼Œä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„ O(1)ã€‚          |
| â‘¥    | å¯å¦ç»“åˆæ•°ç»„å®ç°ï¼Ÿ                           | å¯ä»¥å°†é“¾è¡¨è½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åé¦–å°¾åŒæŒ‡é’ˆå¯¹æ¯”ï¼Œé€‚ç”¨äºå°å‹é“¾è¡¨åœºæ™¯ã€‚                             |
| â‘¦    | æ€ä¹ˆéªŒè¯ä½ å†™çš„é“¾è¡¨åè½¬å‡½æ•°æ²¡æœ‰é”™è¯¯ï¼Ÿ         | å•å…ƒæµ‹è¯•ä¸­ä¼ å…¥å¤šä¸ªå·²çŸ¥åè½¬åçš„é“¾è¡¨ç»“æ„è¿›è¡Œæ–­è¨€éªŒè¯ï¼Œæˆ–ä½¿ç”¨è°ƒè¯•å·¥å…·è§‚å¯ŸæŒ‡é’ˆæŒ‡å‘çš„å˜åŒ–è§„å¾‹ã€‚ |
| â‘§    | å¯å¦ç”¨é€’å½’å†™æ³•ï¼Ÿä¼˜ç‚¹ç¼ºç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ             | é€’å½’å¯ä»¥å¤©ç„¶åšåˆ°ä»å°¾éƒ¨å‘å¤´éƒ¨è®¿é—®ï¼Œä½†ä¼šå¸¦æ¥ O(n) çš„è°ƒç”¨æ ˆç©ºé—´å¼€é”€ï¼Œä¸å¦‚è¿­ä»£æ–¹æ³•å®ç”¨æ€§å¼ºã€‚   |

ğŸ¯ æ³¨æ„ç‚¹ï¼šåœ¨å›ç­”ä¸­å¼ºè°ƒå·¥ç¨‹å®è·µä¸­æ›´å€¾å‘äºé€‰æ‹©ç©ºé—´æ•ˆç‡æ›´é«˜çš„è¿­ä»£è§£æ³•

## 9. å¤ä¹ è¦ç‚¹æç‚¼ä¸æ€»ç»“å»ºè®®

| è¦ç´             | å†…å®¹                                                   |
| --------------- | ------------------------------------------------------ |
| âš ï¸ æ˜“é”™ç‚¹       | å¿˜è®°åè½¬åè¦æ¯”è¾ƒçš„æ˜¯ä¸¤æ®µé“¾è¡¨çš„å€¼ï¼Œè€Œä¸æ˜¯åŸé“¾è¡¨çš„é¡ºåº   |
| âœ… é«˜é¢‘è€ƒç‚¹     | å¿«æ…¢æŒ‡é’ˆ + é“¾è¡¨åè½¬                                    |
| ğŸ’¡ å¯å‘ç‚¹       | å€ŸåŠ©é“¾è¡¨ç‰¹æ€§å·§å¦™è§„é¿æ•°ç»„å¼ç©ºé—´æµªè´¹                     |
| ğŸŒŸ è®°å¿†é”šç‚¹     | â€œå¿«æ…¢æ‰¾ä¸­ â†’ ååŠåè½¬ â†’ åŒå‘æ¯”è¾ƒâ€ ä¸‰å¤§ç»å…¸æ­¥éª¤          |
| ğŸ‰ æŒæ¡æ ‡å¿—     | èƒ½æ‰‹å†™å‡ºå¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ + åŸåœ°åè½¬ + æ— æŸæ¯”å¯¹å…¨è¿‡ç¨‹       |
| ğŸ” å·¥ä¸šå®è·µå¯ç¤º | å¯¹äºé“¾è¡¨ç›¸å…³é—®é¢˜ï¼Œå–„ç”¨â€œåŸåœ°æ“ä½œâ€å¯å¤§å¹…å‡å°‘é¢å¤–å†…å­˜æ¶ˆè€— |
| ğŸ“š å­¦ä¹ å»ºè®®     | å¤šç»ƒé“¾è¡¨åè½¬ç±»é¢˜ç›®ï¼Œç§¯ç´¯æ‰‹æ„Ÿï¼Œæé«˜å¯¹æŒ‡é’ˆæ“ä½œçš„æ•æ„Ÿåº¦   |

ğŸš€ æœ¬é¢˜æ˜¯é“¾è¡¨é¢è¯•é¢˜çš„ç»å…¸ä»£è¡¨ä¹‹ä¸€ï¼Œå»ºè®®å°†å…¶çº³å…¥é«˜é¢‘å¤ä¹ æ¸…å•ï¼Œç†Ÿç»ƒæŒæ¡åå†å°è¯•æ‹“å±•è‡³åŒå‘é“¾è¡¨æˆ–å¤šçº§é“¾è¡¨ç­‰å¤æ‚æƒ…å½¢

ğŸ‰ è‡³æ­¤ï¼Œå…³äºâ€œLeetCode 234 - å›æ–‡é“¾è¡¨â€çš„å…¨é¢è§£æç»“æŸï¼Œç¥ä½ åœ¨ç®—æ³•å­¦ä¹ è·¯ä¸Šä¸æ–­è¿›æ­¥ï¼
