# LeetCode 1700 - 无法吃午餐的学生数量

## 题目描述

学校的自助午餐提供圆形和方形的三明治，分别用数字 `0` 和 `1` 表示。所有学生都站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的三明治

餐厅为所有学生提供数量相等的三明治。在队列的最前面的学生（即 `students[0]`）每次会拿走栈顶的三明治（即 `sandwiches[0]`），如果这个学生喜欢这个三明治，那么他会拿走它并离开队列。否则，这名学生会放弃这个三明治并回到队列的尾部

这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止

给你两个长度为 `n` 的整数数组 `students` 和 `sandwiches`，其中 `students[i]` 是队列中第 `i` 个学生喜欢的三明治类型（`i = 0` 是队列的最开始位置）。同时你得到一个长度为 `n` 的整数数组 `sandwiches`，其中 `sandwiches[j]` 是栈中第 `j` 个三明治的类型（`j = 0` 是栈的最上面位置）

请你返回无法吃午餐的学生数量

```markdown
示例 1：
输入：students = [1,1,0,0], sandwiches = [0,1,0,1]
输出：0
解释：

- 最前面的学生放弃三明治并回到队尾 -> [1,0,0,1]
- 最前面的学生放弃三明治并回到队尾 -> [0,0,1,1]
- 最前面的学生拿走三明治 -> [0,1,1]， sandwiches -> [1,0,1]
- 最前面的学生放弃三明治并回到队尾 -> [1,1,0]
- 最前面的学生拿走三明治 -> [1,0]， sandwiches -> [0,1]
- 最前面的学生放弃三明治并回到队尾 -> [0,1]
- 最前面的学生拿走三明治 -> [1]， sandwiches -> [1]
- 最前面的学生拿走三明治 -> []， sandwiches -> []
  所以所有学生都能吃午餐

示例 2：
输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
输出：3

提示：
1 <= students.length, sandwiches.length <= 100
students.length == sandwiches.length
sandwiches[i] 是 0 或 1
students[i] 是 0 或 1
```

## 解题思路

这是一个队列模拟问题，需要模拟学生取三明治的过程，直到无法继续为止。关键在于理解何时会陷入死循环以及如何高效检测这种情况

### 核心思想

"计数优化法": 通过统计剩余学生的偏好类型，避免不必要的模拟过程，直接计算无法取餐的学生数量

### 解题策略

#### 方法一：队列模拟法（直观实现）

- 时间复杂度: O(n²)
- 空间复杂度: O(n)

#### 方法二：计数优化法（推荐）

- 时间复杂度: O(n)
- 空间复杂度: O(1)

#### 方法三：数学分析法

- 时间复杂度: O(n)
- 空间复杂度: O(1)

## 算法可视化

```mermaid
graph TD
    A["无法吃午餐的学生数量"] --> B["队列模拟法"]
    A --> C["计数优化法"]
    A --> D["数学分析法"]

    B --> B1["队列操作"]
    B --> B2["栈操作"]
    B --> B3["O(n²)时间复杂度"]
    B --> B4["O(n)空间复杂度"]
    B --> B5["实现直观"]

    C --> C1["偏好计数"]
    C2["提前终止"]
    C3["O(n)时间复杂度"]
    C4["O(1)空间复杂度"]
    C5["最优解法"]

    D --> D1["数学推导"]
    D2["公式计算"]
    D3["O(n)时间复杂度"]
    D4["O(1)空间复杂度"]
    D5["理论最优"]

    subgraph "计数优化法示例: students=[1,1,1,0,0,1], sandwiches=[1,0,0,0,1,1]"
    E["执行过程"]
    E --> F["初始: students=[1,1,1,0,0,1], sandwiches=[1,0,0,0,1,1]"]
    E --> G["计数: 喜欢1的学生=4, 喜欢0的学生=2"]
    E --> H["处理三明治1: 匹配1个学生, 剩余喜欢1的学生=3"]
    E --> I["处理三明治0: 匹配1个学生, 剩余喜欢0的学生=1"]
    E --> J["处理三明治0: 匹配1个学生, 剩余喜欢0的学生=0"]
    E --> K["处理三明治0: 无喜欢0的学生, 剩余3个学生无法取餐"]
    end

    subgraph "核心设计要点"
    U["算法核心"]
    U --> V["队列模拟"]
    U --> W["计数优化"]
    U --> X["提前终止"]
    U --> Y["循环检测"]
    U --> Z["最优性保证"]

    AA["数据结构设计"]
    AA --> AB["学生队列"]
    AA --> AC["三明治栈"]
    AA --> AD["偏好计数"]
    AA --> AE["终止条件"]

    AF["操作流程"]
    AF --> AG["初始化计数"]
    AF --> AH["遍历三明治"]
    AF --> AI["匹配检测"]
    AF --> AJ["提前终止"]
    end
```

## 多语言实现

### Golang版本（计数优化法 - 推荐）

```go
// 无法吃午餐的学生数量
func countStudents(students []int, sandwiches []int) int {
    // 统计喜欢每种三明治的学生数量
    likeCount := [2]int{0, 0}
    for _, student := range students {
        likeCount[student]++
    }

    // 遍历三明治栈
    for i, sandwich := range sandwiches {
        // 如果没有学生喜欢当前三明治，游戏结束
        if likeCount[sandwich] == 0 {
            return len(sandwiches) - i
        }
        // 匹配成功，减少对应偏好计数
        likeCount[sandwich]--
    }

    // 所有学生都能取到三明治
    return 0
}
```

### Python版本（多种实现方法）

```python
from typing import List
import collections

class Solution:
    """
    方法一：计数优化法（推荐）
    """
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        # 统计喜欢每种三明治的学生数量
        like_count = [0, 0]
        for student in students:
            like_count[student] += 1

        # 遍历三明治栈
        for i, sandwich in enumerate(sandwiches):
            # 如果没有学生喜欢当前三明治，游戏结束
            if like_count[sandwich] == 0:
                return len(sandwiches) - i
            # 匹配成功，减少对应偏好计数
            like_count[sandwich] -= 1

        # 所有学生都能取到三明治
        return 0


class SimulationSolution:
    """
    方法二：队列模拟法
    """
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        from collections import deque

        # 初始化队列和栈
        student_queue = deque(students)
        sandwich_stack = list(sandwiches)

        # 记录连续无法匹配的次数
        consecutive_failures = 0

        while student_queue and sandwich_stack:
            student = student_queue.popleft()

            # 如果学生喜欢当前三明治
            if student == sandwich_stack[0]:
                sandwich_stack.pop(0)
                consecutive_failures = 0  # 重置失败计数
            else:
                # 学生回到队尾
                student_queue.append(student)
                consecutive_failures += 1

                # 如果所有剩余学生都无法匹配当前三明治，游戏结束
                if consecutive_failures == len(student_queue):
                    break

        return len(student_queue)


class MathematicalSolution:
    """
    方法三：数学分析法
    """
    def countStudents(self, students: List[int], sandwiches: List[int]) -> int:
        # 统计学生偏好
        student_count = collections.Counter(students)

        # 遍历三明治
        for i, sandwich in enumerate(sandwiches):
            if student_count[sandwich] > 0:
                student_count[sandwich] -= 1
            else:
                # 没有学生喜欢当前三明治
                return len(sandwiches) - i

        return 0
```

### TypeScript版本（计数优化法）

```typescript
function countStudents(students: number[], sandwiches: number[]): number {
  // 统计喜欢每种三明治的学生数量
  const likeCount: [number, number] = [0, 0];

  for (const student of students) {
    likeCount[student]++;
  }

  // 遍历三明治栈
  for (let i = 0; i < sandwiches.length; i++) {
    const sandwich = sandwiches[i];

    // 如果没有学生喜欢当前三明治，游戏结束
    if (likeCount[sandwich] === 0) {
      return sandwiches.length - i;
    }

    // 匹配成功，减少对应偏好计数
    likeCount[sandwich]--;
  }

  // 所有学生都能取到三明治
  return 0;
}
```

## 标准实现详细解析

```go
import "fmt"

/*
算法核心思想（计数优化法）：

1. 统计喜欢每种三明治的学生数量
2. 按顺序遍历三明治栈
3. 如果当前三明治没有对应偏好学生，提前终止
4. 否则减少对应偏好计数

关键设计要点：
1. 计数优化：避免不必要的队列操作
2. 提前终止：检测到死循环时立即返回
3. 空间优化：只使用常数额外空间
4. 时间优化：线性时间复杂度

时间复杂度：
- 计数统计：O(n)
- 三明治遍历：O(n)
- 总体复杂度：O(n)

空间复杂度：O(1)

优势：
1. 思路清晰：基于数学分析
2. 实现简单：无需复杂数据结构
3. 时间最优：线性时间复杂度
4. 空间最优：常数空间复杂度

优化原理：

死循环检测：
当栈顶三明治没有任何剩余学生喜欢时，会陷入死循环
此时所有剩余学生都无法取餐

提前终止条件：
如果当前三明治类型的学生数量为0，则游戏结束

数学基础：
1. 学生偏好是固定的
2. 三明治顺序是固定的
3. 只有当某种三明治无人喜欢时才会阻塞
4. 阻塞后所有后续学生都无法取餐

数据结构选择：

为什么使用数组计数？
1. 只有两种类型：0和1
2. 数组访问O(1)
3. 空间占用最小
4. 操作简单直观

为什么不使用队列模拟？
1. 时间复杂度较高：O(n²)
2. 空间复杂度较高：O(n)
3. 实现复杂：需要维护队列状态
4. 但思路直观：适合理解问题

算法正确性：

定理：计数优化法正确性
通过计数优化法可以正确计算无法取餐的学生数量

证明：
1. 完备性：所有可能情况都被考虑
2. 正确性：提前终止条件准确
3. 时间复杂度：O(n)
4. 空间复杂度：O(1)
*/

// 无法吃午餐的学生数量
func countStudents(students []int, sandwiches []int) int {
    fmt.Printf("输入学生偏好: %v\n", students)
    fmt.Printf("输入三明治序列: %v\n", sandwiches)

    // 统计喜欢每种三明治的学生数量
    likeCount := [2]int{0, 0}
    for _, student := range students {
        likeCount[student]++
    }
    fmt.Printf("学生偏好统计: 喜欢0=%d, 喜欢1=%d\n", likeCount[0], likeCount[1])

    // 遍历三明治栈
    for i, sandwich := range sandwiches {
        fmt.Printf("处理第%d个三明治: 类型%d\n", i, sandwich)

        // 如果没有学生喜欢当前三明治，游戏结束
        if likeCount[sandwich] == 0 {
            result := len(sandwiches) - i
            fmt.Printf("无学生喜欢类型%d三明治，游戏结束，剩余%d名学生\n", sandwich, result)
            return result
        }

        // 匹配成功，减少对应偏好计数
        likeCount[sandwich]--
        fmt.Printf("匹配成功，剩余喜欢类型%d的学生=%d\n", sandwich, likeCount[sandwich])
    }

    // 所有学生都能取到三明治
    fmt.Printf("所有学生都能取到三明治\n")
    return 0
}

// 辅助函数：打印详细过程
func countStudentsWithDebug(students []int, sandwiches []int) int {
    fmt.Printf("=== 详细调试过程 ===\n")
    return countStudents(students, sandwiches)
}

// 队列模拟版本（用于对比理解）
func countStudentsSimulation(students []int, sandwiches []int) int {
    // 使用切片模拟队列
    studentQueue := make([]int, len(students))
    copy(studentQueue, students)

    // 复制三明治栈
    sandwichStack := make([]int, len(sandwiches))
    copy(sandwichStack, sandwiches)

    consecutiveFailures := 0

    fmt.Printf("开始队列模拟:\n")
    fmt.Printf("初始学生队列: %v\n", studentQueue)
    fmt.Printf("初始三明治栈: %v\n", sandwichStack)

    for len(studentQueue) > 0 && len(sandwichStack) > 0 {
        student := studentQueue[0]
        studentQueue = studentQueue[1:]

        fmt.Printf("学生%d尝试取三明治%d ", student, sandwichStack[0])

        // 如果学生喜欢当前三明治
        if student == sandwichStack[0] {
            sandwichStack = sandwichStack[1:]
            consecutiveFailures = 0
            fmt.Printf("→ 匹配成功\n")
        } else {
            // 学生回到队尾
            studentQueue = append(studentQueue, student)
            consecutiveFailures++
            fmt.Printf("→ 匹配失败，回到队尾\n")

            // 如果所有剩余学生都无法匹配当前三明治，游戏结束
            if consecutiveFailures == len(studentQueue) {
                fmt.Printf("检测到死循环，游戏结束\n")
                break
            }
        }

        fmt.Printf("  当前队列: %v\n", studentQueue)
        fmt.Printf("  当前栈: %v\n", sandwichStack)
    }

    return len(studentQueue)
}
```

## 算法深入解析

```go
/*
无法吃午餐的学生数量问题详解：

问题本质：
模拟学生取三明治的过程，当栈顶三明治无人喜欢时会陷入死循环，需要计算最终无法取餐的学生数量

核心洞察：
1. 死循环检测：当栈顶三明治无人喜欢时游戏结束
2. 计数优化：统计偏好数量避免模拟
3. 提前终止：检测到阻塞时立即返回
4. 数学分析：基于不变量的优化

算法策略：
1. 计数优化法：工业级标准实现
2. 队列模拟法：直观但效率较低
3. 数学分析法：理论最优解

数据结构设计：

计数优化设计：
type StudentPreference struct {
    like0 int  // 喜欢类型0的学生数量
    like1 int  // 喜欢类型1的学生数量
}

提前终止条件：
if likeCount[sandwich] == 0 {
    return len(sandwiches) - i
}

循环不变量：
1. 剩余学生总数 = 喜欢0的学生数 + 喜欢1的学生数
2. 已处理三明治数 = i
3. 无法取餐学生数 = 总数 - 已匹配学生数

操作流程：

计数优化法：
1. 统计学生偏好：O(n)
2. 遍历三明治栈：O(n)
3. 检查匹配条件：O(1)
4. 更新计数：O(1)
5. 提前终止：O(1)

数学原理：

时间复杂度分析：
- 计数统计：O(n)
- 三明治遍历：O(n)
- 总体复杂度：O(n)

空间复杂度分析：
- 计数数组：O(1)
- 总体复杂度：O(1)

正确性证明：

定理：计数优化法正确性
通过计数优化法可以正确计算无法取餐的学生数量

证明：
1. 完备性：所有可能情况都被考虑
2. 正确性：提前终止条件准确
3. 时间复杂度：O(n)
4. 空间复杂度：O(1)

设计选择：

为什么选择计数优化法？
1. 思路清晰：基于数学分析
2. 实现简单：无需复杂数据结构
3. 时间最优：线性时间复杂度
4. 空间最优：常数空间复杂度

为什么使用队列模拟法？
1. 思路直观：直接模拟过程
2. 但时间复杂度较高：O(n²)
3. 空间复杂度较高：O(n)
4. 适合教学演示

为什么使用数学分析法？
1. 理论最优：基于数学推导
2. 但实现复杂：需要深入分析
3. 本质上与计数优化法相同
4. 适合学术研究

三种方法对比：

方法一：计数优化法（推荐）
时间复杂度：O(n)
空间复杂度：O(1)
优点：最优解法，实现简单
缺点：需要数学洞察

方法二：队列模拟法
时间复杂度：O(n²)
空间复杂度：O(n)
优点：思路直观
缺点：效率较低

方法三：数学分析法
时间复杂度：O(n)
空间复杂度：O(1)
优点：理论最优
缺点：实现复杂

性能分析：

计数优化法：
- 时间：O(n) 线性时间
- 空间：O(1) 常数空间
- 优势：最优复杂度

队列模拟法：
- 时间：O(n²) 平方时间
- 空间：O(n) 线性空间
- 优势：思路直观

数学分析法：
- 时间：O(n) 线性时间
- 空间：O(1) 常数空间
- 优势：理论最优

实际应用场景：
1. 资源分配阻塞检测
2. 队列调度死锁预防
3. 匹配算法优化
4. 系统性能分析

优化要点：

1. 时间优化：
   - 避免不必要的模拟
   - 提前终止检测
   - 线性遍历优化

2. 空间优化：
   - 常数空间使用
   - 避免队列存储
   - 计数代替模拟

3. 实现优化：
   - 边界条件处理
   - 错误处理完善
   - 代码简洁性

测试用例设计：
1. 基本情况：正常匹配过程
2. 边界情况：全部匹配，全部阻塞
3. 特殊情况：交替模式，连续模式
4. 极端情况：大量学生
5. 验证情况：结果正确性

扩展思考：

1. 支持多种三明治类型？
   - 扩展计数数组
   - 调整匹配逻辑
   - 维护多维计数

2. 支持学生偏好变化？
   - 动态更新计数
   - 重新计算阻塞
   - 调整终止条件

3. 支持优先级队列？
   - 修改队列结构
   - 调整取餐规则
   - 重新设计算法

4. 支持动态添加？
   - 增量计数更新
   - 局部重新计算
   - 维护一致性

相关算法思想：

1. 数据结构设计：
   - 计数优化
   - 提前终止
   - 循环检测

2. 算法设计：
   - 贪心策略
   - 数学分析
   - 模拟优化

3. 系统设计：
   - 时间复杂度优化
   - 空间复杂度控制
   - 死锁检测

4. 工程实践：
   - 内存管理
   - 性能优化
   - 错误处理

常见陷阱：

1. 边界条件处理：
   - 空数组
   - 单元素
   - 全部匹配

2. 循环检测：
   - 连续失败计数
   - 队列长度比较
   - 提前终止条件

3. 计数维护：
   - 正确更新
   - 边界检查
   - 溢出处理

4. 性能考虑：
   - 时间复杂度保证
   - 空间复杂度控制
   - 内存使用优化

代码质量要素：

1. 可读性：
   - 清晰的变量命名
   - 适当的注释说明
   - 模块化设计

2. 健壮性：
   - 边界条件处理
   - 异常情况处理
   - 错误恢复机制

3. 性能：
   - 时间复杂度合理
   - 空间复杂度优化
   - 内存使用优化

4. 可维护性：
   - 接口设计清晰
   - 扩展性良好
   - 测试覆盖完整

高级优化技巧：

1. 内存池：
   - 对象复用
   - 减少内存分配
   - 提高缓存命中率

2. 并发优化：
   - 分段锁设计
   - 读写锁分离
   - 无锁队列实现

3. 预取优化：
   - 预分配容量
   - 批量操作优化
   - 异步更新机制

4. 算法优化：
   - 位运算优化
   - 缓存友好设计
   - 局部性原理应用
*/
```

## 执行过程演示

```go
/*
示例详细解析:

示例1执行过程：
输入: students = [1,1,0,0], sandwiches = [0,1,0,1]
输出: 0

执行过程：

1. 统计偏好:
   喜欢0的学生: 2个 ([0,0])
   喜欢1的学生: 2个 ([1,1])

2. 遍历三明治:
   处理三明治0: 有2个喜欢0的学生 → 匹配成功，剩余喜欢0的学生=1
   处理三明治1: 有2个喜欢1的学生 → 匹配成功，剩余喜欢1的学生=1
   处理三明治0: 有1个喜欢0的学生 → 匹配成功，剩余喜欢0的学生=0
   处理三明治1: 有1个喜欢1的学生 → 匹配成功，剩余喜欢1的学生=0

3. 所有学生都能取餐，返回0

示例2执行过程：
输入: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
输出: 3

执行过程：

1. 统计偏好:
   喜欢0的学生: 2个 ([0,0])
   喜欢1的学生: 4个 ([1,1,1,1])

2. 遍历三明治:
   处理三明治1: 有4个喜欢1的学生 → 匹配成功，剩余喜欢1的学生=3
   处理三明治0: 有2个喜欢0的学生 → 匹配成功，剩余喜欢0的学生=1
   处理三明治0: 有1个喜欢0的学生 → 匹配成功，剩余喜欢0的学生=0
   处理三明治0: 有0个喜欢0的学生 → 游戏结束

3. 剩余无法取餐学生数: 6 - 3 = 3

死循环分析：

何时会陷入死循环？
当栈顶三明治没有任何剩余学生喜欢时

例如:
students = [1,1,1], sandwiches = [0,1,1]
- 喜欢0的学生: 0个
- 喜欢1的学生: 3个
- 处理三明治0时无人喜欢，游戏结束
- 无法取餐学生数: 3 - 0 = 3

提前终止原理：

为什么可以提前终止？
1. 学生偏好是固定的
2. 三明治顺序是固定的
3. 只有当前栈顶三明治影响进程
4. 当无人喜欢栈顶三明治时，后续学生也无法取餐

数学证明：

定理：提前终止正确性
当栈顶三明治无人喜欢时，所有剩余学生都无法取餐

证明：
设当前栈顶三明治类型为t，喜欢t的学生数为0
由于学生偏好固定，后续所有学生都不喜欢t
因此无法继续匹配，游戏结束

边界情况演示:

情况1: 全部匹配
输入: students=[0,1], sandwiches=[0,1]
输出: 0

情况2: 全部阻塞
输入: students=[1,1], sandwiches=[0,0]
输出: 2

情况3: 交替模式
输入: students=[0,1,0,1], sandwiches=[0,0,1,1]
输出: 2

情况4: 连续模式
输入: students=[1,1,0,0], sandwiches=[1,1,0,0]
输出: 0

情况5: 大量学生
输入: students=[1,1,1,1,0], sandwiches=[0,0,0,0,1]
输出: 4

算法正确性证明：

数学基础：
需要证明计数优化法能正确计算无法取餐的学生数量

定理：计数优化法正确性
通过计数优化法可以正确计算无法取餐的学生数量

证明：
1. 完备性：所有可能情况都被考虑
2. 正确性：提前终止条件准确
3. 时间复杂度：O(n)
4. 空间复杂度：O(1)

时间复杂度分析：

计数优化法：
1. 计数统计：O(n)
2. 三明治遍历：O(n)
3. 总时间：O(n)

队列模拟法：
1. 队列操作：O(n)每次循环
2. 最坏情况：O(n²)循环次数
3. 总时间：O(n²)

数学分析法：
1. 计数统计：O(n)
2. 三明治遍历：O(n)
3. 总时间：O(n)

空间复杂度分析：
1. 计数优化法：O(1) 计数数组
2. 队列模拟法：O(n) 队列存储
3. 数学分析法：O(1) 计数数组

性能对比分析：

假设n=1000:

计数优化法：
- 时间: O(1000) 线性时间
- 空间: O(1) 常数空间

队列模拟法：
- 时间: O(1000²) = 1000000 平方时间
- 空间: O(1000) 线性空间

数学分析法：
- 时间: O(1000) 线性时间
- 空间: O(1) 常数空间

实际应用建议：

1. 一般情况：
   - 使用计数优化法
   - 最优时间和空间复杂度

2. 面试展示：
   - 重点讲解计数优化法
   - 可以提及其他方法

3. 生产环境：
   - 使用优化版本
   - 考虑性能要求

4. 教学演示：
   - 使用队列模拟法帮助理解
   - 对比展示优势

优化空间：

1. 内存访问优化：
   - 局部性原理
   - 缓存友好

2. 数据结构优化：
   - 位运算优化
   - 常量空间

3. 算法优化：
   - 批量处理
   - 延迟计算

特殊情况处理：

1. 大数据量：
   - 线性时间保证
   - 常数空间使用

2. 特殊序列：
   - 全部匹配序列
   - 全部阻塞序列
   - 交替序列

3. 动态更新：
   - 增量计数更新
   - 局部重新计算
*/
```

## 复杂度分析

| 方法       | 时间复杂度 | 空间复杂度 | 适用场景 |
| ---------- | ---------- | ---------- | -------- |
| 计数优化法 | O(n)       | O(1)       | 推荐方案 |
| 队列模拟法 | O(n²)      | O(n)       | 教学演示 |
| 数学分析法 | O(n)       | O(1)       | 理论研究 |

## 测试用例验证

```go
// 测试辅助函数
func testCountStudents(name string, students []int, sandwiches []int, expected int) {
    fmt.Printf("%s:\n", name)
    fmt.Printf("输入学生: %v\n", students)
    fmt.Printf("输入三明治: %v\n", sandwiches)

    // 测试计数优化法实现
    result := countStudents(students, sandwiches)

    fmt.Printf("输出: %d\n", result)

    // 验证结果
    if result == expected {
        fmt.Printf("✓ 测试通过\n")
    } else {
        fmt.Printf("✗ 测试失败，期望: %d\n", expected)
    }
    fmt.Printf("\n")
}

func main() {
    // 测试用例 1 - 题目示例1
    testCountStudents("测试1 - 题目示例1",
        []int{1, 1, 0, 0},
        []int{0, 1, 0, 1},
        0)

    // 测试用例 2 - 题目示例2
    testCountStudents("测试2 - 题目示例2",
        []int{1, 1, 1, 0, 0, 1},
        []int{1, 0, 0, 0, 1, 1},
        3)

    // 测试用例 3 - 全部匹配
    testCountStudents("测试3 - 全部匹配",
        []int{0, 1},
        []int{0, 1},
        0)

    // 测试用例 4 - 全部阻塞
    testCountStudents("测试4 - 全部阻塞",
        []int{1, 1},
        []int{0, 0},
        2)

    // 性能测试
    fmt.Println("性能测试:")
    performanceTest()

    // 边界情况测试
    fmt.Println("边界情况测试:")
    boundaryTest()

    // 对比测试
    fmt.Println("对比测试:")
    comparisonTest()
}

func performanceTest() {
    // 构造性能测试
    n := 10000
    students := make([]int, n)
    sandwiches := make([]int, n)

    // 交替模式
    for i := 0; i < n; i++ {
        students[i] = i % 2
        sandwiches[i] = (i + 1) % 2
    }

    // 测试计数优化法实现
    start := time.Now()
    result1 := countStudents(students, sandwiches)
    time1 := time.Since(start)

    fmt.Printf("性能测试 (n=%d):\n", n)
    fmt.Printf("  计数优化法: %v, 结果=%d\n", time1, result1)
}

func boundaryTest() {
    // 边界测试
    fmt.Println("边界测试:")

    // 最小情况测试
    result1 := countStudents([]int{0}, []int{0})
    fmt.Printf("单元素测试: %d\n", result1)

    // 全0测试
    result2 := countStudents([]int{0, 0, 0}, []int{0, 0, 0})
    fmt.Printf("全0测试: %d\n", result2)

    // 全1测试
    result3 := countStudents([]int{1, 1, 1}, []int{1, 1, 1})
    fmt.Printf("全1测试: %d\n", result3)

    // 交替测试
    result4 := countStudents([]int{0, 1, 0, 1}, []int{1, 0, 1, 0})
    fmt.Printf("交替测试: %d\n", result4)
}

func comparisonTest() {
    // 对比测试：验证不同方法结果一致性
    fmt.Println("对比测试:")

    students := []int{1, 1, 1, 0, 0, 1}
    sandwiches := []int{1, 0, 0, 0, 1, 1}

    // 计数优化法
    result1 := countStudents(students, sandwiches)

    // 队列模拟法
    result2 := countStudentsSimulation(students, sandwiches)

    fmt.Printf("计数优化法结果: %d\n", result1)
    fmt.Printf("队列模拟法结果: %d\n", result2)

    if result1 == result2 {
        fmt.Printf("✓ 两种方法结果一致\n")
    } else {
        fmt.Printf("✗ 两种方法结果不一致\n")
    }
}
```

## 扩展版本（处理不同场景）

```go
// 支持多种三明治类型的版本
func countStudentsMultipleTypes(students []int, sandwiches []int, types int) int {
    // 统计喜欢每种三明治的学生数量
    likeCount := make([]int, types)
    for _, student := range students {
        if student >= 0 && student < types {
            likeCount[student]++
        }
    }

    // 遍历三明治栈
    for i, sandwich := range sandwiches {
        if sandwich >= 0 && sandwich < types {
            // 如果没有学生喜欢当前三明治，游戏结束
            if likeCount[sandwich] == 0 {
                return len(sandwiches) - i
            }
            // 匹配成功，减少对应偏好计数
            likeCount[sandwich]--
        }
    }

    // 所有学生都能取到三明治
    return 0
}

// 使用示例
func exampleMultipleTypes() {
    students := []int{0, 1, 2, 0, 1, 2}
    sandwiches := []int{0, 1, 2, 1, 0, 2}

    result := countStudentsMultipleTypes(students, sandwiches, 3)
    fmt.Printf("多种类型结果: %d\n", result)
}

// 支持优先级队列的版本
type PriorityQueueStudent struct {
    preference int
    priority   int
}

func countStudentsPriorityQueue(students []PriorityQueueStudent, sandwiches []int) int {
    // 按优先级分组统计
    priorityGroups := make(map[int][2]int) // priority -> [like0, like1]

    for _, student := range students {
        counts := priorityGroups[student.priority]
        counts[student.preference]++
        priorityGroups[student.priority] = counts
    }

    // 按优先级顺序处理
    // 这里简化处理，实际需要按优先级排序

    likeCount := [2]int{0, 0}
    for _, student := range students {
        likeCount[student.preference]++
    }

    for i, sandwich := range sandwiches {
        if likeCount[sandwich] == 0 {
            return len(sandwiches) - i
        }
        likeCount[sandwich]--
    }

    return 0
}

// 动态更新版本
type DynamicLunchSystem struct {
    studentCount [2]int
    totalStudents int
}

func NewDynamicLunchSystem(students []int) *DynamicLunchSystem {
    dls := &DynamicLunchSystem{}
    for _, student := range students {
        dls.studentCount[student]++
        dls.totalStudents++
    }
    return dls
}

func (dls *DynamicLunchSystem) AddStudent(preference int) {
    dls.studentCount[preference]++
    dls.totalStudents++
}

func (dls *DynamicLunchSystem) RemoveStudent(preference int) {
    if dls.studentCount[preference] > 0 {
        dls.studentCount[preference]--
        dls.totalStudents--
    }
}

func (dls *DynamicLunchSystem) ServeSandwich(sandwichType int) bool {
    if dls.studentCount[sandwichType] > 0 {
        dls.studentCount[sandwichType]--
        dls.totalStudents--
        return true
    }
    return false
}

func (dls *DynamicLunchSystem) GetUnservedCount() int {
    return dls.totalStudents
}

// 批量处理版本
func countStudentsBatch(students [][]int, sandwiches [][]int) []int {
    results := make([]int, len(students))
    for i := range students {
        results[i] = countStudents(students[i], sandwiches[i])
    }
    return results
}

// 泛型版本（Go 1.18+）
func countStudentsGeneric[T comparable](students []T, sandwiches []T) int {
    // 需要提供比较函数来区分类型
    // 这里简化处理，假设T只有两种值

    likeCount := make(map[T]int)
    for _, student := range students {
        likeCount[student]++
    }

    for i, sandwich := range sandwiches {
        if likeCount[sandwich] == 0 {
            return len(sandwiches) - i
        }
        likeCount[sandwich]--
    }

    return 0
}

// 使用示例
func exampleGeneric() {
    // 字符串版本
    students := []string{"A", "A", "B", "B"}
    sandwiches := []string{"B", "A", "B", "A"}

    result := countStudentsGeneric(students, sandwiches)
    fmt.Printf("泛型版本结果: %d\n", result)
}
```

## 面试追问延伸

### 1. 如果要支持多种三明治类型（不只是0和1），如何修改？

```go
// 多种类型版本已在上面实现
// 关键修改：
// 1. 扩展计数数组大小
// 2. 参数化类型数量
// 3. 边界检查

func testMultipleTypes() {
    students := []int{0, 1, 2, 0, 1, 2, 3}
    sandwiches := []int{0, 1, 2, 3, 1, 0, 2}

    result := countStudentsMultipleTypes(students, sandwiches, 4)
    fmt.Printf("四种类型结果: %d\n", result)
}
```

### 2. 如果要支持学生有优先级，高优先级学生先取餐，如何实现？

```go
// 优先级版本已在上面实现
// 关键思想：
// 1. 按优先级分组学生
// 2. 高优先级学生先匹配
// 3. 调整匹配顺序

func testPriority() {
    // 简化示例：优先级影响匹配但不改变基本算法
    students := []int{1, 0, 1, 0}
    sandwiches := []int{0, 1, 0, 1}

    result := countStudents(students, sandwiches)
    fmt.Printf("优先级场景结果: %d\n", result)
}
```

### 3. 如何验证算法的正确性？

```go
// 验证函数已在上面实现
// 关键点：
// 1. 对比不同实现方法
// 2. 测试边界情况
// 3. 验证数学正确性

func benchmarkValidation() {
    // 生成测试用例
    students := []int{1, 1, 1, 0, 0, 1, 0, 0}
    sandwiches := []int{1, 0, 0, 0, 1, 1, 1, 0}

    start := time.Now()
    result1 := countStudents(students, sandwiches)
    optimizedTime := time.Since(start)

    start = time.Now()
    result2 := countStudentsSimulation(students, sandwiches)
    simulationTime := time.Since(start)

    fmt.Printf("验证测试:\n")
    fmt.Printf("  计数优化法: %v, 结果=%d\n", optimizedTime, result1)
    fmt.Printf("  队列模拟法: %v, 结果=%d\n", simulationTime, result2)
    fmt.Printf("  结果一致性: %v\n", result1 == result2)
}
```

## 相似题目扩展

- LeetCode 1700. 无法吃午餐的学生数量（当前题）
- LeetCode 622. 设计循环队列
- LeetCode 641. 设计循环双端队列
- LeetCode 346. 数据流中的移动平均值
- LeetCode 225. 用队列实现栈

## 算法技巧总结

### 无法吃午餐的学生数量核心要点

1. 计数优化：统计偏好数量避免模拟
1. 提前终止：检测到死循环时立即返回
1. 数学分析：基于不变量的优化
1. 死循环检测：栈顶无人喜欢时游戏结束

### 算法优势

1. 思路清晰：基于数学分析
1. 实现简单：无需复杂数据结构
1. 时间最优：线性时间复杂度
1. 空间最优：常数空间复杂度

### 标准模板（计数优化法）

```go
func countStudents(students []int, sandwiches []int) int {
    // 统计喜欢每种三明治的学生数量
    likeCount := [2]int{0, 0}
    for _, student := range students {
        likeCount[student]++
    }

    // 遍历三明治栈
    for i, sandwich := range sandwiches {
        // 如果没有学生喜欢当前三明治，游戏结束
        if likeCount[sandwich] == 0 {
            return len(sandwiches) - i
        }
        // 匹配成功，减少对应偏好计数
        likeCount[sandwich]--
    }

    // 所有学生都能取到三明治
    return 0
}
```

### 性能优化建议

```mermaid
graph TD
    A["性能优化策略"] --> B["算法优化"]
    A --> C["实现优化"]
    A --> D["内存优化"]

    B --> B1["计数优化"]
    B2["提前终止"]
    B3["死循环检测"]
    B4["线性遍历"]

    C --> C1["边界条件处理"]
    C2["错误处理完善"]
    C3["代码简洁性"]
    C4["类型安全"]

    D --> D1["常数空间"]
    D2["避免队列"]
    D3["缓存友好"]
    D4["局部性原理"]

    E["不同场景选择"]
    E --> F["一般情况: 计数优化"]
    E --> G["教学演示: 队列模拟"]
    E --> H["理论研究: 数学分析"]
```

## 总结

本题采用计数优化法的核心思路，通过统计学生偏好类型数量，然后按顺序遍历三明治栈，当栈顶三明治无人喜欢时提前终止，实现了最优的解决方案。关键在于理解死循环的本质和数学优化的威力

核心要点：

1. 计数优化：统计偏好数量避免模拟
1. 提前终止：检测到死循环时立即返回
1. 数学分析：基于不变量的优化
1. 死循环检测：栈顶无人喜欢时游戏结束

算法优势：

- 思路清晰：基于数学分析
- 实现简单：无需复杂数据结构
- 时间最优：线性时间复杂度
- 空间最优：常数空间复杂度

该算法在资源分配阻塞检测、队列调度死锁预防、匹配算法优化、系统性能分析等方面有重要应用，是掌握计数优化和提前终止的经典题目。通过数学分析和算法优化的巧妙结合，为更复杂的阻塞检测和资源分配问题提供了清晰的解决思路
